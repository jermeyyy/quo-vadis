# Task 3.1: Create Generator Base Classes

> **Task Status**: ⬜ Not Started  
> **Estimated Effort**: 2-3 days  
> **Dependencies**: Phase 1 Complete, Phase 2 Complete  
> **Blocks**: Task 3.2, Task 3.3, Task 3.4

---

## Objective

Create shared base classes and utilities for the DSL code generators. This eliminates duplicate code across the 7+ existing generators and provides type-safe, reusable building blocks for generating KotlinPoet code.

**Problem Being Solved**:
Currently, each generator (`ScreenRegistryGenerator`, `ContainerRegistryGenerator`, etc.) contains duplicated patterns for:
- Building class names from `KSClassDeclaration`
- Constructing `when` expressions
- Generating import statements
- Creating file specs with consistent structure
- Handling nested class naming

**Solution**:
Extract common patterns into three base components:
1. `DslCodeGenerator` - Abstract base class with shared generator logic
2. `CodeBlockBuilders` - Reusable KotlinPoet `CodeBlock` builders
3. `StringTemplates` - Common string templates for generated code

---

## Files to Create

### File Structure

```
quo-vadis-ksp/src/main/kotlin/com/jermey/quo/vadis/ksp/generators/
├── base/                           # NEW directory
│   ├── DslCodeGenerator.kt         # Abstract base class
│   ├── CodeBlockBuilders.kt        # Shared code block utilities
│   └── StringTemplates.kt          # Reusable string templates
├── dsl/                            # NEW directory (for Task 3.2)
└── legacy/                         # NEW directory (for Task 3.3)
```

---

## File Specifications

### 1. DslCodeGenerator.kt

**Purpose**: Abstract base class providing common functionality for all DSL generators.

```kotlin
package com.jermey.quo.vadis.ksp.generators.base

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSFile
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.writeTo

/**
 * Abstract base class for DSL code generators.
 * 
 * Provides common utilities shared across all generators:
 * - Class name resolution from KSP symbols
 * - File generation helpers
 * - Logging utilities
 * - Import management
 * 
 * @property codeGenerator KSP code generator for writing output files
 * @property logger KSP logger for diagnostic messages
 */
abstract class DslCodeGenerator(
    protected val codeGenerator: CodeGenerator,
    protected val logger: KSPLogger
) {
    /**
     * The package name for generated code.
     * Override in subclasses if different package needed.
     */
    protected open val generatedPackage: String = "com.example.navigation.generated"
    
    /**
     * Resolves a fully qualified class name from a KSClassDeclaration.
     * Handles nested classes correctly (e.g., `Outer.Inner`).
     * 
     * @param declaration The KSP class declaration
     * @return The resolved ClassName
     */
    protected fun resolveClassName(declaration: KSClassDeclaration): ClassName {
        return declaration.toClassName()
    }
    
    /**
     * Resolves a class name string suitable for generated code.
     * Handles nested classes with proper formatting.
     * 
     * @param declaration The KSP class declaration
     * @return String representation for code generation
     */
    protected fun resolveClassNameString(declaration: KSClassDeclaration): String {
        val className = resolveClassName(declaration)
        return if (className.simpleNames.size > 1) {
            // Nested class: join with dots
            className.simpleNames.joinToString(".")
        } else {
            className.simpleName
        }
    }
    
    /**
     * Finds the top-level containing class for a potentially nested class.
     * 
     * @param declaration The KSP class declaration
     * @return The top-level class declaration
     */
    protected fun findTopLevelClass(declaration: KSClassDeclaration): KSClassDeclaration {
        var current = declaration
        while (current.parentDeclaration is KSClassDeclaration) {
            current = current.parentDeclaration as KSClassDeclaration
        }
        return current
    }
    
    /**
     * Creates a FileSpec.Builder with standard configuration.
     * 
     * @param fileName The name of the generated file (without .kt)
     * @param packageName Optional package name override
     * @return Configured FileSpec.Builder
     */
    protected fun createFileBuilder(
        fileName: String,
        packageName: String = generatedPackage
    ): FileSpec.Builder {
        return FileSpec.builder(packageName, fileName)
            .addFileComment(
                """
                |Auto-generated by Quo Vadis KSP processor.
                |Do not modify manually.
                """.trimMargin()
            )
    }
    
    /**
     * Writes a FileSpec to the code generator output.
     * 
     * @param fileSpec The file specification to write
     * @param originatingFiles The source files that triggered generation
     */
    protected fun writeFile(
        fileSpec: FileSpec,
        originatingFiles: List<KSFile>
    ) {
        fileSpec.writeTo(codeGenerator, aggregating = true, originatingFiles)
    }
    
    /**
     * Logs an info message.
     */
    protected fun logInfo(message: String) {
        logger.info("QuoVadis: $message")
    }
    
    /**
     * Logs a warning message.
     */
    protected fun logWarning(message: String) {
        logger.warn("QuoVadis: $message")
    }
    
    /**
     * Logs an error message.
     */
    protected fun logError(message: String, symbol: Any? = null) {
        logger.error("QuoVadis: $message", symbol as? com.google.devtools.ksp.symbol.KSNode)
    }
    
    /**
     * Creates a standard DSL block indentation string.
     */
    protected fun indent(level: Int = 1): String = "    ".repeat(level)
    
    /**
     * Common imports needed by most generators.
     */
    protected val commonImports: List<ClassName> = listOf(
        ClassName("com.jermey.quo.vadis.core.navigation", "NavigationConfig"),
        ClassName("com.jermey.quo.vadis.core.navigation", "Destination"),
        ClassName("kotlin.reflect", "KClass")
    )
    
    companion object {
        const val GENERATED_FILE_NAME = "GeneratedNavigationConfig"
        const val GENERATED_OBJECT_NAME = "GeneratedNavigationConfig"
    }
}
```

### 2. CodeBlockBuilders.kt

**Purpose**: Reusable KotlinPoet `CodeBlock` builders for common generation patterns.

```kotlin
package com.jermey.quo.vadis.ksp.generators.base

import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ksp.toClassName

/**
 * Shared utilities for building KotlinPoet CodeBlocks.
 * 
 * Provides type-safe builders for common patterns used across generators:
 * - DSL block generation
 * - When expressions
 * - Collection initializers
 * - Lambda expressions
 */
object CodeBlockBuilders {
    
    /**
     * Builds a `screen<DestinationType>` DSL block.
     * 
     * @param destinationClass The destination class
     * @param screenContent The composable function call to generate
     * @return CodeBlock for the screen registration
     */
    fun buildScreenBlock(
        destinationClass: ClassName,
        screenContent: CodeBlock
    ): CodeBlock {
        return CodeBlock.builder()
            .addStatement("screen<%T> { dest ->", destinationClass)
            .indent()
            .add(screenContent)
            .unindent()
            .addStatement("}")
            .build()
    }
    
    /**
     * Builds a `screen<DestinationType>` DSL block with simple function call.
     * 
     * @param destinationClass The destination class
     * @param functionName The composable function name
     * @param hasNavigator Whether to pass navigator parameter
     * @param hasDestination Whether to pass destination parameter
     * @return CodeBlock for the screen registration
     */
    fun buildSimpleScreenBlock(
        destinationClass: ClassName,
        functionName: String,
        hasNavigator: Boolean = true,
        hasDestination: Boolean = false
    ): CodeBlock {
        val params = buildList {
            if (hasDestination) add("destination = dest")
            if (hasNavigator) add("navigator = navigator")
        }.joinToString(", ")
        
        return CodeBlock.builder()
            .addStatement("screen<%T> { %L(%L) }", destinationClass, functionName, params)
            .build()
    }
    
    /**
     * Builds a `tabs<ContainerType>` DSL block.
     * 
     * @param containerClass The container destination class
     * @param scopeKey The scope key for this container
     * @param wrapperKey Optional wrapper key
     * @param tabsContent CodeBlock containing tab definitions
     * @return CodeBlock for the tabs container
     */
    fun buildTabsBlock(
        containerClass: ClassName,
        scopeKey: String,
        wrapperKey: String? = null,
        tabsContent: CodeBlock
    ): CodeBlock {
        val builder = CodeBlock.builder()
        
        val params = buildList {
            add("scopeKey = %S")
            if (wrapperKey != null) add("wrapperKey = %S")
        }.joinToString(", ")
        
        val args = buildList<Any> {
            add(containerClass)
            add(scopeKey)
            if (wrapperKey != null) add(wrapperKey)
        }
        
        builder.addStatement("tabs<%T>($params) {", *args.toTypedArray())
        builder.indent()
        builder.add(tabsContent)
        builder.unindent()
        builder.addStatement("}")
        
        return builder.build()
    }
    
    /**
     * Builds a `stack<ContainerType>` DSL block.
     * 
     * @param containerClass The container destination class
     * @param scopeKey The scope key for this container
     * @param stackContent CodeBlock containing stack screen definitions
     * @return CodeBlock for the stack container
     */
    fun buildStackBlock(
        containerClass: ClassName,
        scopeKey: String,
        stackContent: CodeBlock
    ): CodeBlock {
        return CodeBlock.builder()
            .addStatement("stack<%T>(scopeKey = %S) {", containerClass, scopeKey)
            .indent()
            .add(stackContent)
            .unindent()
            .addStatement("}")
            .build()
    }
    
    /**
     * Builds a `panes<ContainerType>` DSL block.
     * 
     * @param containerClass The container destination class
     * @param scopeKey The scope key for this container
     * @param wrapperKey Optional wrapper key
     * @param panesContent CodeBlock containing pane definitions
     * @return CodeBlock for the panes container
     */
    fun buildPanesBlock(
        containerClass: ClassName,
        scopeKey: String,
        wrapperKey: String? = null,
        panesContent: CodeBlock
    ): CodeBlock {
        val builder = CodeBlock.builder()
        
        val params = buildList {
            add("scopeKey = %S")
            if (wrapperKey != null) add("wrapperKey = %S")
        }.joinToString(", ")
        
        val args = buildList<Any> {
            add(containerClass)
            add(scopeKey)
            if (wrapperKey != null) add(wrapperKey)
        }
        
        builder.addStatement("panes<%T>($params) {", *args.toTypedArray())
        builder.indent()
        builder.add(panesContent)
        builder.unindent()
        builder.addStatement("}")
        
        return builder.build()
    }
    
    /**
     * Builds a `tab()` entry for tabs container.
     * 
     * @param destination The destination instance expression
     * @param title Optional tab title
     * @param icon Optional icon expression
     * @return CodeBlock for the tab entry
     */
    fun buildTabEntry(
        destination: String,
        title: String? = null,
        icon: String? = null
    ): CodeBlock {
        val params = buildList {
            add(destination)
            if (title != null) add("title = \"$title\"")
            if (icon != null) add("icon = $icon")
        }.joinToString(", ")
        
        return CodeBlock.of("tab($params)\n")
    }
    
    /**
     * Builds a `tab()` entry with nested stack.
     * 
     * @param destination The destination instance expression
     * @param title Optional tab title
     * @param icon Optional icon expression
     * @param stackContent CodeBlock containing nested stack screens
     * @return CodeBlock for the nested tab entry
     */
    fun buildNestedTabEntry(
        destination: String,
        title: String? = null,
        icon: String? = null,
        stackContent: CodeBlock
    ): CodeBlock {
        val params = buildList {
            add(destination)
            if (title != null) add("title = \"$title\"")
            if (icon != null) add("icon = $icon")
        }.joinToString(", ")
        
        return CodeBlock.builder()
            .addStatement("tab($params) {")
            .indent()
            .add(stackContent)
            .unindent()
            .addStatement("}")
            .build()
    }
    
    /**
     * Builds a `scope()` DSL call.
     * 
     * @param scopeKey The scope key
     * @param destinationClasses List of destination classes in the scope
     * @return CodeBlock for the scope definition
     */
    fun buildScopeBlock(
        scopeKey: String,
        destinationClasses: List<ClassName>
    ): CodeBlock {
        if (destinationClasses.isEmpty()) return CodeBlock.of("")
        
        val classRefs = destinationClasses.joinToString(",\n    ") { "%T::class" }
        val args = destinationClasses.toTypedArray()
        
        return CodeBlock.builder()
            .addStatement(
                "scope(%S,\n    $classRefs\n)",
                scopeKey,
                *args
            )
            .build()
    }
    
    /**
     * Builds a `transition<DestinationType>` DSL call.
     * 
     * @param destinationClass The destination class
     * @param transitionExpression The transition instance expression
     * @return CodeBlock for the transition registration
     */
    fun buildTransitionBlock(
        destinationClass: ClassName,
        transitionExpression: String
    ): CodeBlock {
        return CodeBlock.of("transition<%T>($transitionExpression)\n", destinationClass)
    }
    
    /**
     * Builds a `tabWrapper()` DSL block.
     * 
     * @param wrapperKey The wrapper key
     * @param wrapperContent CodeBlock containing wrapper composable content
     * @return CodeBlock for the tab wrapper registration
     */
    fun buildTabWrapperBlock(
        wrapperKey: String,
        wrapperContent: CodeBlock
    ): CodeBlock {
        return CodeBlock.builder()
            .addStatement("tabWrapper(%S) {", wrapperKey)
            .indent()
            .add(wrapperContent)
            .unindent()
            .addStatement("}")
            .build()
    }
    
    /**
     * Builds a `paneWrapper()` DSL block.
     * 
     * @param wrapperKey The wrapper key
     * @param wrapperContent CodeBlock containing wrapper composable content
     * @return CodeBlock for the pane wrapper registration
     */
    fun buildPaneWrapperBlock(
        wrapperKey: String,
        wrapperContent: CodeBlock
    ): CodeBlock {
        return CodeBlock.builder()
            .addStatement("paneWrapper(%S) {", wrapperKey)
            .indent()
            .add(wrapperContent)
            .unindent()
            .addStatement("}")
            .build()
    }
    
    /**
     * Builds a when expression with destination type matching.
     * 
     * @param subject The expression being matched
     * @param cases List of pairs: (type pattern, result expression)
     * @param elseCase Optional else case
     * @return CodeBlock for the when expression
     */
    fun buildWhenExpression(
        subject: String,
        cases: List<Pair<String, CodeBlock>>,
        elseCase: CodeBlock? = null
    ): CodeBlock {
        val builder = CodeBlock.builder()
            .beginControlFlow("when ($subject)")
        
        cases.forEach { (pattern, result) ->
            builder.addStatement("is $pattern -> ")
            builder.indent()
            builder.add(result)
            builder.unindent()
        }
        
        if (elseCase != null) {
            builder.addStatement("else -> ")
            builder.indent()
            builder.add(elseCase)
            builder.unindent()
        }
        
        builder.endControlFlow()
        return builder.build()
    }
    
    /**
     * Builds a mapOf initialization with type parameters.
     * 
     * @param keyType Type of map keys
     * @param valueType Type of map values
     * @param entries List of pairs for map entries
     * @return CodeBlock for the map initialization
     */
    fun buildMapOf(
        keyType: TypeName,
        valueType: TypeName,
        entries: List<Pair<CodeBlock, CodeBlock>>
    ): CodeBlock {
        if (entries.isEmpty()) {
            return CodeBlock.of("emptyMap()")
        }
        
        val builder = CodeBlock.builder()
            .add("mapOf(\n")
            .indent()
        
        entries.forEachIndexed { index, (key, value) ->
            builder.add(key)
            builder.add(" to ")
            builder.add(value)
            if (index < entries.size - 1) {
                builder.add(",")
            }
            builder.add("\n")
        }
        
        builder.unindent()
            .add(")")
        
        return builder.build()
    }
    
    /**
     * Builds a setOf initialization.
     * 
     * @param elements List of elements
     * @return CodeBlock for the set initialization
     */
    fun buildSetOf(elements: List<CodeBlock>): CodeBlock {
        if (elements.isEmpty()) {
            return CodeBlock.of("emptySet()")
        }
        
        val builder = CodeBlock.builder()
            .add("setOf(\n")
            .indent()
        
        elements.forEachIndexed { index, element ->
            builder.add(element)
            if (index < elements.size - 1) {
                builder.add(",")
            }
            builder.add("\n")
        }
        
        builder.unindent()
            .add(")")
        
        return builder.build()
    }
    
    /**
     * Creates a class reference expression.
     * 
     * @param className The class to reference
     * @return CodeBlock for `ClassName::class`
     */
    fun classReference(className: ClassName): CodeBlock {
        return CodeBlock.of("%T::class", className)
    }
}
```

### 3. StringTemplates.kt

**Purpose**: Reusable string templates for common generated code patterns.

```kotlin
package com.jermey.quo.vadis.ksp.generators.base

/**
 * String templates for commonly generated code patterns.
 * 
 * These templates provide consistent formatting across all generators
 * and centralize string literals for easier maintenance.
 */
object StringTemplates {
    
    // =================================================================
    // FILE HEADERS
    // =================================================================
    
    /**
     * Standard file header comment.
     */
    const val FILE_HEADER = """
        |// Auto-generated by Quo Vadis KSP processor.
        |// Do not modify manually.
    """
    
    /**
     * KDoc for GeneratedNavigationConfig object.
     */
    val NAVIGATION_CONFIG_KDOC = """
        |Auto-generated navigation configuration.
        |
        |This object consolidates all navigation registries into a single,
        |composable configuration using the DSL-based approach.
        |
        |## Usage
        |
        |### One-liner
        |```kotlin
        |QuoVadisNavigation(MainTabs::class)
        |```
        |
        |### Standard
        |```kotlin
        |val navigator = rememberQuoVadisNavigator(MainTabs::class)
        |NavigationHost(navigator, config = GeneratedNavigationConfig)
        |```
        |
        |### Advanced
        |```kotlin
        |NavigationHost(
        |    navigator = navigator,
        |    config = GeneratedNavigationConfig + FeatureModuleConfig
        |)
        |```
    """.trimMargin()
    
    // =================================================================
    // SECTION COMMENTS
    // =================================================================
    
    /**
     * Section separator line.
     */
    const val SECTION_SEPARATOR = "// ═══════════════════════════════════════════════"
    
    /**
     * Creates a section header comment.
     * @param title The section title
     * @return Formatted section header string
     */
    fun sectionHeader(title: String): String = """
        |$SECTION_SEPARATOR
        |// $title
        |$SECTION_SEPARATOR
    """.trimMargin()
    
    // Section header constants
    val SCREENS_SECTION = sectionHeader("SCREENS")
    val CONTAINERS_SECTION = sectionHeader("CONTAINERS")
    val SCOPES_SECTION = sectionHeader("SCOPES")
    val TRANSITIONS_SECTION = sectionHeader("TRANSITIONS")
    val WRAPPERS_SECTION = sectionHeader("WRAPPERS")
    val DEEP_LINKS_SECTION = sectionHeader("DEEP LINKS")
    
    // =================================================================
    // DEPRECATION MESSAGES
    // =================================================================
    
    /**
     * Deprecation message for old registry objects.
     */
    fun deprecatedRegistryMessage(registryName: String): String = """
        |This registry is deprecated. Use GeneratedNavigationConfig instead.
        |
        |Migration:
        |```kotlin
        |// Before
        |val registry = $registryName
        |
        |// After
        |val registry = GeneratedNavigationConfig.${registryName.removePrefix("Generated").decapitalize()}
        |```
    """.trimMargin()
    
    /**
     * Deprecation message for old NavNode builder functions.
     */
    fun deprecatedBuilderMessage(functionName: String, containerClass: String): String = """
        |This function is deprecated. Use GeneratedNavigationConfig.buildNavNode() instead.
        |
        |Migration:
        |```kotlin
        |// Before
        |val node = $functionName()
        |
        |// After
        |val node = GeneratedNavigationConfig.buildNavNode($containerClass::class)
        |```
    """.trimMargin()
    
    // =================================================================
    // CODE SNIPPETS
    // =================================================================
    
    /**
     * Template for NavigationConfig implementation delegation.
     */
    const val CONFIG_DELEGATION_TEMPLATE = """
        |override val screenRegistry = config.screenRegistry
        |override val wrapperRegistry = config.wrapperRegistry
        |override val scopeRegistry = config.scopeRegistry
        |override val transitionRegistry = config.transitionRegistry
        |override val containerRegistry = config.containerRegistry
        |override val deepLinkHandler = config.deepLinkHandler
        |
        |override fun buildNavNode(
        |    destinationClass: KClass<out Destination>,
        |    key: String?,
        |    parentKey: String?
        |): NavNode? = config.buildNavNode(destinationClass, key, parentKey)
        |
        |override fun plus(other: NavigationConfig): NavigationConfig =
        |    CompositeNavigationConfig(this, other)
    """
    
    /**
     * Template for roots property.
     */
    fun rootsPropertyTemplate(rootClasses: List<String>): String {
        val classRefs = rootClasses.joinToString(",\n        ") { "$it::class" }
        return """
            |/**
            | * Root destinations available for navigation.
            | */
            |val roots: Set<KClass<out Destination>> = setOf(
            |    $classRefs
            |)
        """.trimMargin()
    }
    
    // =================================================================
    // PARAMETER PATTERNS
    // =================================================================
    
    /**
     * Common parameter names used in generated code.
     */
    object Params {
        const val DESTINATION = "destination"
        const val NAVIGATOR = "navigator"
        const val SCOPE = "scope"
        const val KEY = "key"
        const val PARENT_KEY = "parentKey"
        const val SCOPE_KEY = "scopeKey"
        const val WRAPPER_KEY = "wrapperKey"
        const val INITIAL_TAB = "initialTab"
        const val INITIAL_PANE = "initialPane"
    }
    
    // =================================================================
    // TYPE NAMES
    // =================================================================
    
    /**
     * Common type name strings.
     */
    object Types {
        const val DESTINATION = "Destination"
        const val NAVIGATOR = "Navigator"
        const val NAV_NODE = "NavNode"
        const val K_CLASS = "KClass"
        const val NAV_TRANSITION = "NavTransition"
        const val SCREEN_REGISTRY = "ScreenRegistry"
        const val WRAPPER_REGISTRY = "WrapperRegistry"
        const val SCOPE_REGISTRY = "ScopeRegistry"
        const val TRANSITION_REGISTRY = "TransitionRegistry"
        const val CONTAINER_REGISTRY = "ContainerRegistry"
        const val DEEP_LINK_HANDLER = "DeepLinkHandler"
        const val NAVIGATION_CONFIG = "NavigationConfig"
    }
    
    // =================================================================
    // ERROR MESSAGES
    // =================================================================
    
    /**
     * Error message templates for KSP processing errors.
     */
    object Errors {
        fun noScreenForDestination(destClass: String) = 
            "No @Screen annotation found for destination: $destClass"
        
        fun duplicateRegistration(type: String, key: String) =
            "Duplicate $type registration for key: $key"
        
        fun invalidContainerType(className: String) =
            "Invalid container type: $className. Must be @Tabs, @Stack, or @Pane"
        
        fun missingRequiredAnnotation(annotation: String, className: String) =
            "Missing required @$annotation annotation on: $className"
        
        fun cyclicDependency(path: List<String>) =
            "Cyclic dependency detected: ${path.joinToString(" -> ")}"
        
        fun invalidScopeKey(scopeKey: String) =
            "Invalid scope key: $scopeKey. Scope keys must be non-empty strings."
    }
    
    // =================================================================
    // UTILITIES
    // =================================================================
    
    /**
     * Extension to decapitalize first character (Kotlin standard library equivalent).
     */
    private fun String.decapitalize(): String {
        return if (isNotEmpty() && this[0].isUpperCase()) {
            this[0].lowercaseChar() + substring(1)
        } else {
            this
        }
    }
}
```

---

## Dependencies

### This Task Depends On

| Dependency | Description | Status |
|------------|-------------|--------|
| Phase 1 Complete | DSL types to reference in templates | Required |
| Phase 2 Complete | `navigationConfig { }` function signature | Required |
| KotlinPoet | Code generation library | ✅ Available |
| KSP | Symbol processing APIs | ✅ Available |

### What This Task Blocks

| Task | Dependency Type |
|------|-----------------|
| Task 3.2 (NavigationConfigGenerator) | Uses base classes |
| Task 3.3 (Refactor Existing Generators) | Uses base classes |
| Task 3.4 (Processor Orchestration) | Uses base classes |

---

## Acceptance Criteria Checklist

### DslCodeGenerator.kt
- [ ] Abstract class with protected constructor taking `CodeGenerator` and `KSPLogger`
- [ ] `resolveClassName()` correctly handles nested classes
- [ ] `resolveClassNameString()` produces valid code strings
- [ ] `findTopLevelClass()` traverses to root class
- [ ] `createFileBuilder()` produces consistent file structure
- [ ] `writeFile()` properly delegates to KSP CodeGenerator
- [ ] Logging methods work correctly
- [ ] Common imports list is complete and accurate

### CodeBlockBuilders.kt
- [ ] `buildScreenBlock()` produces valid DSL syntax
- [ ] `buildSimpleScreenBlock()` handles all parameter combinations
- [ ] `buildTabsBlock()` produces valid tabs DSL
- [ ] `buildStackBlock()` produces valid stack DSL
- [ ] `buildPanesBlock()` produces valid panes DSL
- [ ] `buildTabEntry()` handles optional parameters correctly
- [ ] `buildNestedTabEntry()` produces nested structure
- [ ] `buildScopeBlock()` handles empty and non-empty cases
- [ ] `buildTransitionBlock()` produces valid transition DSL
- [ ] `buildTabWrapperBlock()` produces valid wrapper DSL
- [ ] `buildPaneWrapperBlock()` produces valid wrapper DSL
- [ ] `buildWhenExpression()` produces compilable when blocks
- [ ] `buildMapOf()` handles empty and non-empty cases
- [ ] `buildSetOf()` handles empty and non-empty cases
- [ ] All generated code is properly formatted

### StringTemplates.kt
- [ ] FILE_HEADER is valid Kotlin comment
- [ ] NAVIGATION_CONFIG_KDOC is valid KDoc
- [ ] Section headers are visually distinct and consistent
- [ ] Deprecation messages provide clear migration paths
- [ ] CONFIG_DELEGATION_TEMPLATE is valid Kotlin code
- [ ] Error messages are clear and actionable
- [ ] All string templates pass Kotlin compilation when used

### Code Quality
- [ ] No compilation errors or warnings
- [ ] KDoc documentation for all public members
- [ ] Follows existing project code style
- [ ] Package structure matches specification
- [ ] Internal visibility used where appropriate

### Testing
- [ ] Unit tests for `resolveClassName()` with nested classes
- [ ] Unit tests for all `CodeBlockBuilders` methods
- [ ] Verify generated CodeBlocks produce valid Kotlin
- [ ] Unit tests for edge cases (empty lists, null parameters)
- [ ] Integration test: Use base classes in simple generator

---

## Implementation Notes

### Design Decisions

1. **Object vs Class for Builders**
   - `CodeBlockBuilders` as object (stateless, no need for instances)
   - `StringTemplates` as object (constants and pure functions)
   - `DslCodeGenerator` as abstract class (needs state for codeGenerator/logger)

2. **CodeBlock vs String**
   - Prefer `CodeBlock` for any code that includes types (uses `%T` formatting)
   - Use `String` templates only for static code sections

3. **Visibility**
   - Base classes in `generators/base/` package
   - Protected members in `DslCodeGenerator` for subclass access
   - Public members in objects for cross-package use

### Patterns from Existing Generators

**From ScreenRegistryGenerator.kt (lines 186-196)**:
```kotlin
// Pattern for building destination class names
private fun buildDestinationClassName(screen: ScreenInfo): String {
    val topLevelClass = findTopLevelClass(screen.destination)
    val topLevelClassName = topLevelClass.simpleName.asString()
    
    if (screen.destination == topLevelClass) {
        return topLevelClassName
    }
    
    return "$topLevelClassName.${screen.destination.simpleName.asString()}"
}
```
This pattern should be extracted to `DslCodeGenerator.resolveClassNameString()`.

**From NavNodeBuilderGenerator.kt (lines 406-420)**:
```kotlin
// Pattern for building class name with proper nesting
private fun buildClassName(declaration: KSClassDeclaration): String {
    val names = mutableListOf<String>()
    var current: KSClassDeclaration? = declaration
    while (current != null) {
        names.add(0, current.simpleName.asString())
        current = current.parentDeclaration as? KSClassDeclaration
    }
    return names.joinToString(".")
}
```
This pattern should be consolidated with the above.

### Potential Issues

1. **KotlinPoet Version Compatibility**
   - Ensure `ksp.toClassName()` extension is available
   - May need to add KSP KotlinPoet integration dependency

2. **Multi-Module Package Names**
   - `generatedPackage` may need to be dynamic based on user project
   - Consider reading from KSP options

3. **Import Collisions**
   - Some destination classes may have same simple name
   - Rely on KotlinPoet's import management

---

## Testing Strategy

### Unit Tests

```kotlin
class CodeBlockBuildersTest {
    
    @Test
    fun `buildScreenBlock produces valid DSL syntax`() {
        val className = ClassName("com.example", "HomeDestination")
        val content = CodeBlock.of("HomeScreen(navigator = navigator)")
        
        val result = CodeBlockBuilders.buildScreenBlock(className, content)
        
        // Verify output structure
        assertThat(result.toString()).contains("screen<HomeDestination>")
        assertThat(result.toString()).contains("HomeScreen(navigator = navigator)")
    }
    
    @Test
    fun `buildTabsBlock includes all parameters`() {
        val className = ClassName("com.example", "MainTabs")
        val content = CodeBlock.of("tab(MainTabs.Home)")
        
        val result = CodeBlockBuilders.buildTabsBlock(
            containerClass = className,
            scopeKey = "MainScope",
            wrapperKey = "mainWrapper",
            tabsContent = content
        )
        
        assertThat(result.toString()).contains("tabs<MainTabs>")
        assertThat(result.toString()).contains("scopeKey = \"MainScope\"")
        assertThat(result.toString()).contains("wrapperKey = \"mainWrapper\"")
    }
    
    @Test
    fun `buildScopeBlock handles empty list`() {
        val result = CodeBlockBuilders.buildScopeBlock("empty", emptyList())
        assertThat(result.toString()).isEmpty()
    }
}
```

### Integration Tests

```kotlin
class DslCodeGeneratorIntegrationTest {
    
    @Test
    fun `generated code compiles successfully`() {
        // Generate code using base classes
        // Compile using Kotlin compiler
        // Verify no errors
    }
}
```

---

## Estimated Effort Breakdown

| Activity | Time |
|----------|------|
| Create directory structure | 0.25 days |
| Implement `DslCodeGenerator.kt` | 0.75 days |
| Implement `CodeBlockBuilders.kt` | 1 day |
| Implement `StringTemplates.kt` | 0.5 days |
| Unit tests | 0.5 days |
| Integration testing with existing generators | 0.5 days |
| Documentation & review | 0.5 days |
| **Total** | **2-3 days** |

---

## Related Files

- [Phase 3 Summary](./SUMMARY.md)
- [Task 3.2 - NavigationConfigGenerator](./TASK-3.2-navigation-config-generator.md)
- [Task 3.3 - Refactor Existing Generators](./TASK-3.3-refactor-existing-generators.md)
- [Task 3.4 - Processor Orchestration](./TASK-3.4-processor-orchestration.md)

### Current Generator Files for Reference
- [ScreenRegistryGenerator.kt](quo-vadis-ksp/src/main/kotlin/com/jermey/quo/vadis/ksp/generators/ScreenRegistryGenerator.kt)
- [NavNodeBuilderGenerator.kt](quo-vadis-ksp/src/main/kotlin/com/jermey/quo/vadis/ksp/generators/NavNodeBuilderGenerator.kt)
- [ScopeRegistryGenerator.kt](quo-vadis-ksp/src/main/kotlin/com/jermey/quo/vadis/ksp/generators/ScopeRegistryGenerator.kt)
