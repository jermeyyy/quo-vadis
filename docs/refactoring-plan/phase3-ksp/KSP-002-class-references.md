# KSP-002: Create NavNode Builder Generator

## Task Metadata

| Property | Value |
|----------|-------|
| **Task ID** | KSP-002 |
| **Task Name** | Create NavNode Builder Generator |
| **Phase** | Phase 4: KSP Processor Rewrite |
| **Complexity** | High |
| **Estimated Time** | 4-5 days |
| **Dependencies** | KSP-001 (Annotation Extractors) |
| **Blocked By** | KSP-001 |
| **Blocks** | KSP-003, KSP-004 |

---

## Overview

This task implements the **NavNodeBuilderGenerator**—the core code generator that transforms extracted annotation metadata into `build{Name}NavNode()` functions. These functions construct the initial NavNode tree structure for navigation containers (`@Stack`, `@Tab`, `@Pane`).

### Purpose

The NavNode Builder Generator:

1. **Consumes** intermediate models from KSP-001 extractors
2. **Generates** type-safe builder functions for each container annotation
3. **Creates** properly structured NavNode trees (StackNode, TabNode, PaneNode)
4. **Outputs** Kotlin source files to the KSP generated directory

---

## Generated Output Location

```
build/generated/ksp/commonMain/kotlin/{package}/generated/
├── HomeDestinationNavNodeBuilder.kt    # For @Stack
├── ProfileDestinationNavNodeBuilder.kt # For @Stack
├── MainTabsNavNodeBuilder.kt           # For @Tab
├── CatalogPaneNavNodeBuilder.kt        # For @Pane
```

---

## Generator Implementation

### NavNodeBuilderGenerator

```kotlin
package com.jermey.quo.vadis.ksp.generators

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.jermey.quo.vadis.ksp.models.*
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ksp.writeTo

/**
 * Generates build{Name}NavNode() functions for navigation containers.
 *
 * This generator creates functions that construct initial NavNode trees
 * from @Stack, @Tab, and @Pane annotations.
 */
class NavNodeBuilderGenerator(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) {
    
    companion object {
        private const val GENERATED_PACKAGE_SUFFIX = "generated"
    }
    
    /**
     * Generate NavNode builder for a @Stack container.
     */
    fun generateStackBuilder(stackInfo: StackInfo) {
        val packageName = "${stackInfo.packageName}.$GENERATED_PACKAGE_SUFFIX"
        val fileName = "${stackInfo.className}NavNodeBuilder"
        
        val fileSpec = FileSpec.builder(packageName, fileName)
            .addFileComment("Generated by Quo Vadis KSP - DO NOT EDIT")
            .addImport("com.jermey.quo.vadis.core.navigation.core", "StackNode")
            .addImport("com.jermey.quo.vadis.core.navigation.core", "ScreenNode")
            .addImport(stackInfo.packageName, stackInfo.className)
            .addFunction(buildStackNodeFunction(stackInfo))
            .build()
        
        fileSpec.writeTo(codeGenerator, Dependencies(false))
    }
    
    /**
     * Generate NavNode builder for a @Tab container.
     */
    fun generateTabBuilder(tabInfo: TabInfo, stackBuilders: Map<String, StackInfo>) {
        val packageName = "${tabInfo.packageName}.$GENERATED_PACKAGE_SUFFIX"
        val fileName = "${tabInfo.className}NavNodeBuilder"
        
        val fileSpec = FileSpec.builder(packageName, fileName)
            .addFileComment("Generated by Quo Vadis KSP - DO NOT EDIT")
            .addImport("com.jermey.quo.vadis.core.navigation.core", "TabNode")
            .addImport(tabInfo.packageName, tabInfo.className)
            .apply {
                // Add imports for tab root graph builders
                tabInfo.tabs.forEach { tabItem ->
                    val rootGraphName = tabItem.rootGraphClass.simpleName.asString()
                    val rootGraphPackage = tabItem.rootGraphClass.packageName.asString()
                    addImport("$rootGraphPackage.$GENERATED_PACKAGE_SUFFIX", "build${rootGraphName}NavNode")
                }
            }
            .addFunction(buildTabNodeFunction(tabInfo))
            .build()
        
        fileSpec.writeTo(codeGenerator, Dependencies(false))
    }
    
    /**
     * Generate NavNode builder for a @Pane container.
     */
    fun generatePaneBuilder(paneInfo: PaneInfo) {
        val packageName = "${paneInfo.packageName}.$GENERATED_PACKAGE_SUFFIX"
        val fileName = "${paneInfo.className}NavNodeBuilder"
        
        val fileSpec = FileSpec.builder(packageName, fileName)
            .addFileComment("Generated by Quo Vadis KSP - DO NOT EDIT")
            .addImport("com.jermey.quo.vadis.core.navigation.core", "PaneNode")
            .addImport("com.jermey.quo.vadis.core.navigation.core", "PaneConfiguration")
            .addImport("com.jermey.quo.vadis.core.navigation.core", "PaneRole")
            .addImport("com.jermey.quo.vadis.core.navigation.core", "AdaptStrategy")
            .addImport("com.jermey.quo.vadis.core.navigation.core", "PaneBackBehavior")
            .addImport(paneInfo.packageName, paneInfo.className)
            .addFunction(buildPaneNodeFunction(paneInfo))
            .build()
        
        fileSpec.writeTo(codeGenerator, Dependencies(false))
    }
    
    // =========================================================================
    // Private Builder Functions
    // =========================================================================
    
    private fun buildStackNodeFunction(stackInfo: StackInfo): FunSpec {
        val startDest = stackInfo.resolvedStartDestination
            ?: throw IllegalStateException("No start destination for ${stackInfo.className}")
        
        return FunSpec.builder("build${stackInfo.className}NavNode")
            .addKdoc("""
                |Builds the initial NavNode tree for the "${stackInfo.name}" stack.
                |
                |@param key Unique key for the root StackNode
                |@param parentKey Parent node key, or null if root
                |@return A [StackNode] with [${stackInfo.className}.${startDest.className}] as start destination
            """.trimMargin())
            .addParameter(
                ParameterSpec.builder("key", String::class)
                    .defaultValue("%S", "${stackInfo.name}-stack")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("parentKey", String::class.asTypeName().copy(nullable = true))
                    .defaultValue("null")
                    .build()
            )
            .returns(ClassName("com.jermey.quo.vadis.core.navigation.core", "StackNode"))
            .addCode(buildStackNodeCode(stackInfo, startDest))
            .build()
    }
    
    private fun buildStackNodeCode(stackInfo: StackInfo, startDest: DestinationInfo): CodeBlock {
        return CodeBlock.builder()
            .addStatement("return StackNode(")
            .indent()
            .addStatement("key = key,")
            .addStatement("parentKey = parentKey,")
            .addStatement("children = listOf(")
            .indent()
            .addStatement("ScreenNode(")
            .indent()
            .addStatement("key = %S,", "\$key/${startDest.className.lowercase()}")
            .addStatement("parentKey = key,")
            .addStatement("destination = %T.%L", 
                ClassName(stackInfo.packageName, stackInfo.className),
                startDest.className
            )
            .unindent()
            .addStatement(")")
            .unindent()
            .addStatement(")")
            .unindent()
            .addStatement(")")
            .build()
    }
    
    private fun buildTabNodeFunction(tabInfo: TabInfo): FunSpec {
        val initialTabIndex = tabInfo.tabs.indexOfFirst { 
            it.destination.className == tabInfo.initialTab 
        }.takeIf { it >= 0 } ?: 0
        
        return FunSpec.builder("build${tabInfo.className}NavNode")
            .addKdoc("""
                |Builds the initial NavNode tree for the "${tabInfo.name}" tab container.
                |
                |@param key Unique key for the root TabNode
                |@param parentKey Parent node key, or null if root
                |@param initialTabIndex Index of the initially active tab (default: $initialTabIndex)
                |@return A [TabNode] with parallel stacks for each tab
            """.trimMargin())
            .addParameter(
                ParameterSpec.builder("key", String::class)
                    .defaultValue("%S", "${tabInfo.name}-tabs")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("parentKey", String::class.asTypeName().copy(nullable = true))
                    .defaultValue("null")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("initialTabIndex", Int::class)
                    .defaultValue("%L", initialTabIndex)
                    .build()
            )
            .returns(ClassName("com.jermey.quo.vadis.core.navigation.core", "TabNode"))
            .addCode(buildTabNodeCode(tabInfo))
            .build()
    }
    
    private fun buildTabNodeCode(tabInfo: TabInfo): CodeBlock {
        val builder = CodeBlock.builder()
            .addStatement("return TabNode(")
            .indent()
            .addStatement("key = key,")
            .addStatement("parentKey = parentKey,")
            .addStatement("stacks = listOf(")
            .indent()
        
        tabInfo.tabs.forEachIndexed { index, tabItem ->
            val rootGraphName = tabItem.rootGraphClass.simpleName.asString()
            val tabKey = tabItem.destination.className.lowercase()
            
            builder.addStatement(
                "build${rootGraphName}NavNode(key = %S, parentKey = key)%L",
                "\$key/$tabKey",
                if (index < tabInfo.tabs.size - 1) "," else ""
            )
        }
        
        builder
            .unindent()
            .addStatement("),")
            .addStatement("activeStackIndex = initialTabIndex")
            .unindent()
            .addStatement(")")
        
        return builder.build()
    }
    
    private fun buildPaneNodeFunction(paneInfo: PaneInfo): FunSpec {
        return FunSpec.builder("build${paneInfo.className}NavNode")
            .addKdoc("""
                |Builds the initial NavNode tree for the "${paneInfo.name}" pane container.
                |
                |@param key Unique key for the root PaneNode
                |@param parentKey Parent node key, or null if root
                |@param activePaneRole Initially active pane role
                |@return A [PaneNode] configured for adaptive layouts
            """.trimMargin())
            .addParameter(
                ParameterSpec.builder("key", String::class)
                    .defaultValue("%S", "${paneInfo.name}-pane")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("parentKey", String::class.asTypeName().copy(nullable = true))
                    .defaultValue("null")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("activePaneRole", ClassName("com.jermey.quo.vadis.core.navigation.core", "PaneRole"))
                    .defaultValue("PaneRole.PRIMARY")
                    .build()
            )
            .returns(ClassName("com.jermey.quo.vadis.core.navigation.core", "PaneNode"))
            .addCode(buildPaneNodeCode(paneInfo))
            .build()
    }
    
    private fun buildPaneNodeCode(paneInfo: PaneInfo): CodeBlock {
        val builder = CodeBlock.builder()
            .addStatement("return PaneNode(")
            .indent()
            .addStatement("key = key,")
            .addStatement("parentKey = parentKey,")
            .addStatement("paneConfigurations = mapOf(")
            .indent()
        
        paneInfo.panes.forEachIndexed { index, paneItem ->
            val rootGraphName = paneItem.rootGraphClass.simpleName.asString()
            val paneKey = paneItem.destination.className.lowercase()
            
            builder.addStatement(
                "PaneRole.%L to PaneConfiguration(",
                paneItem.role.name
            )
            builder.indent()
            builder.addStatement(
                "content = build${rootGraphName}NavNode(key = %S, parentKey = key),",
                "\$key/$paneKey"
            )
            builder.addStatement(
                "adaptStrategy = AdaptStrategy.%L",
                paneItem.adaptStrategy.name
            )
            builder.unindent()
            builder.addStatement(")%L", if (index < paneInfo.panes.size - 1) "," else "")
        }
        
        builder
            .unindent()
            .addStatement("),")
            .addStatement("activePaneRole = activePaneRole,")
            .addStatement("backBehavior = PaneBackBehavior.%L", paneInfo.backBehavior.name)
            .unindent()
            .addStatement(")")
        
        return builder.build()
    }
}
```

---

## Generated Code Examples

### Input: @Stack Annotation

```kotlin
@Stack(name = "home", startDestination = "Feed")
sealed class HomeDestination : Destination {
    
    @Destination(route = "home/feed")
    data object Feed : HomeDestination()
    
    @Destination(route = "home/detail/{id}")
    data class Detail(val id: String) : HomeDestination()
}
```

### Output: HomeDestinationNavNodeBuilder.kt

```kotlin
// Generated by Quo Vadis KSP - DO NOT EDIT
package com.example.generated

import com.jermey.quo.vadis.core.navigation.core.StackNode
import com.jermey.quo.vadis.core.navigation.core.ScreenNode
import com.example.HomeDestination

/**
 * Builds the initial NavNode tree for the "home" stack.
 *
 * @param key Unique key for the root StackNode
 * @param parentKey Parent node key, or null if root
 * @return A [StackNode] with [HomeDestination.Feed] as start destination
 */
fun buildHomeDestinationNavNode(
    key: String = "home-stack",
    parentKey: String? = null
): StackNode = StackNode(
    key = key,
    parentKey = parentKey,
    children = listOf(
        ScreenNode(
            key = "$key/feed",
            parentKey = key,
            destination = HomeDestination.Feed
        )
    )
)
```

---

### Input: @Tab Annotation

```kotlin
@Tab(name = "main", initialTab = "Home")
sealed class MainTabs : Destination {
    
    @TabItem(label = "Home", icon = "home", rootGraph = HomeDestination::class)
    @Destination(route = "tab/home")
    data object Home : MainTabs()
    
    @TabItem(label = "Profile", icon = "person", rootGraph = ProfileDestination::class)
    @Destination(route = "tab/profile")
    data object Profile : MainTabs()
}
```

### Output: MainTabsNavNodeBuilder.kt

```kotlin
// Generated by Quo Vadis KSP - DO NOT EDIT
package com.example.generated

import com.jermey.quo.vadis.core.navigation.core.TabNode
import com.example.MainTabs
import com.example.generated.buildHomeDestinationNavNode
import com.example.generated.buildProfileDestinationNavNode

/**
 * Builds the initial NavNode tree for the "main" tab container.
 *
 * @param key Unique key for the root TabNode
 * @param parentKey Parent node key, or null if root
 * @param initialTabIndex Index of the initially active tab (default: 0)
 * @return A [TabNode] with parallel stacks for each tab
 */
fun buildMainTabsNavNode(
    key: String = "main-tabs",
    parentKey: String? = null,
    initialTabIndex: Int = 0
): TabNode = TabNode(
    key = key,
    parentKey = parentKey,
    stacks = listOf(
        buildHomeDestinationNavNode(
            key = "$key/home",
            parentKey = key
        ),
        buildProfileDestinationNavNode(
            key = "$key/profile",
            parentKey = key
        )
    ),
    activeStackIndex = initialTabIndex
)
```

---

### Input: @Pane Annotation

```kotlin
@Pane(name = "catalog", backBehavior = PaneBackBehavior.POP_UNTIL_CONTENT_CHANGE)
sealed class CatalogPane : Destination {
    
    @PaneItem(role = PaneRole.PRIMARY, adaptStrategy = AdaptStrategy.HIDE, rootGraph = ListDestination::class)
    @Destination(route = "catalog/list")
    data object List : CatalogPane()
    
    @PaneItem(role = PaneRole.SUPPORTING, adaptStrategy = AdaptStrategy.LEVITATE, rootGraph = DetailDestination::class)
    @Destination(route = "catalog/detail")
    data object Detail : CatalogPane()
}
```

### Output: CatalogPaneNavNodeBuilder.kt

```kotlin
// Generated by Quo Vadis KSP - DO NOT EDIT
package com.example.generated

import com.jermey.quo.vadis.core.navigation.core.PaneNode
import com.jermey.quo.vadis.core.navigation.core.PaneConfiguration
import com.jermey.quo.vadis.core.navigation.core.PaneRole
import com.jermey.quo.vadis.core.navigation.core.AdaptStrategy
import com.jermey.quo.vadis.core.navigation.core.PaneBackBehavior
import com.example.CatalogPane
import com.example.generated.buildListDestinationNavNode
import com.example.generated.buildDetailDestinationNavNode

/**
 * Builds the initial NavNode tree for the "catalog" pane container.
 *
 * @param key Unique key for the root PaneNode
 * @param parentKey Parent node key, or null if root
 * @param activePaneRole Initially active pane role
 * @return A [PaneNode] configured for adaptive layouts
 */
fun buildCatalogPaneNavNode(
    key: String = "catalog-pane",
    parentKey: String? = null,
    activePaneRole: PaneRole = PaneRole.PRIMARY
): PaneNode = PaneNode(
    key = key,
    parentKey = parentKey,
    paneConfigurations = mapOf(
        PaneRole.PRIMARY to PaneConfiguration(
            content = buildListDestinationNavNode(key = "$key/list", parentKey = key),
            adaptStrategy = AdaptStrategy.HIDE
        ),
        PaneRole.SUPPORTING to PaneConfiguration(
            content = buildDetailDestinationNavNode(key = "$key/detail", parentKey = key),
            adaptStrategy = AdaptStrategy.LEVITATE
        )
    ),
    activePaneRole = activePaneRole,
    backBehavior = PaneBackBehavior.POP_UNTIL_CONTENT_CHANGE
)
```

---

## Implementation Steps

### Step 1: Set Up Generator Class (Day 1 - 4 hours)

Create `NavNodeBuilderGenerator.kt` with:
- Constructor accepting `CodeGenerator` and `KSPLogger`
- KotlinPoet setup and imports
- Basic file generation structure

### Step 2: Implement Stack Builder (Day 1 - 4 hours)

Implement `generateStackBuilder()`:
- Parse `StackInfo` from KSP-001
- Generate `build{Name}NavNode()` function
- Create proper ScreenNode for start destination

### Step 3: Implement Tab Builder (Day 2 - 6 hours)

Implement `generateTabBuilder()`:
- Parse `TabInfo` from KSP-001
- Reference child stack builders
- Handle `initialTabIndex` calculation
- Generate stacks list with proper keys

### Step 4: Implement Pane Builder (Day 3 - 6 hours)

Implement `generatePaneBuilder()`:
- Parse `PaneInfo` from KSP-001
- Generate `PaneConfiguration` map
- Handle role and adaptStrategy enums
- Include backBehavior configuration

### Step 5: Integration with Processor (Day 4 - 4 hours)

Wire generator into `QuoVadisSymbolProcessor`:
- Call extractors to get container info
- Invoke appropriate generator methods
- Handle dependencies between tab/stack builders

### Step 6: Testing & Validation (Day 4-5 - 8 hours)

- Unit tests for each generator method
- Integration tests with sample annotations
- Verify generated code compiles
- Test runtime behavior of generated builders

---

## Files Affected

| File | Action | Description |
|------|--------|-------------|
| `quo-vadis-ksp/src/main/kotlin/.../generators/NavNodeBuilderGenerator.kt` | Create | Main builder generator class |
| `quo-vadis-ksp/src/main/kotlin/.../QuoVadisSymbolProcessor.kt` | Modify | Wire generator into processing pipeline |

---

## Acceptance Criteria

- [ ] `NavNodeBuilderGenerator` class implemented with full KDoc
- [ ] `generateStackBuilder()` creates valid StackNode builders
- [ ] `generateTabBuilder()` creates valid TabNode builders with correct tab references
- [ ] `generatePaneBuilder()` creates valid PaneNode builders with proper configurations
- [ ] Generated files placed in `build/generated/ksp/commonMain/kotlin/{package}/generated/`
- [ ] Generated code compiles without errors
- [ ] Generated builder functions are properly typed (return StackNode, TabNode, PaneNode)
- [ ] Default parameters work correctly (key, parentKey, initialTabIndex, etc.)
- [ ] Tab builders correctly reference stack builders from other packages
- [ ] Unit tests for each generation scenario
- [ ] Integration test demonstrating full generation pipeline

---

## Testing Notes

### Unit Test Examples

```kotlin
class NavNodeBuilderGeneratorTest {
    
    @Test
    fun `generates StackNode for @Stack annotation`() {
        val source = """
            @Stack(name = "test", startDestination = "Home")
            sealed class TestDestination : Destination {
                @Destination(route = "home")
                data object Home : TestDestination()
            }
        """.trimIndent()
        
        val result = compile(source)
        
        assertThat(result.exitCode).isEqualTo(KotlinCompilation.ExitCode.OK)
        assertThat(result.generatedFiles).contains("TestDestinationNavNodeBuilder.kt")
        
        val generated = result.generatedSourceOf("TestDestinationNavNodeBuilder")
        assertThat(generated).contains("fun buildTestDestinationNavNode(")
        assertThat(generated).contains("StackNode(")
        assertThat(generated).contains("ScreenNode(")
        assertThat(generated).contains("destination = TestDestination.Home")
    }
    
    @Test
    fun `generates TabNode with correct stack references`() {
        // Given @Tab with two @TabItem referencing different stacks
        // When generated
        // Then TabNode builder calls both stack builders
    }
    
    @Test
    fun `generates PaneNode with all configurations`() {
        // Given @Pane with PRIMARY and SUPPORTING panes
        // When generated
        // Then PaneNode includes both PaneConfiguration entries
    }
}
```

### Integration Test

```kotlin
class GeneratedCodeIntegrationTest {
    
    @Test
    fun `generated NavNode tree is navigable`() {
        val tree = buildMainTabsNavNode()
        val navigator = DefaultNavigator(tree)
        
        // Verify initial state
        assertThat(navigator.currentNode.value).isInstanceOf(TabNode::class)
        
        // Navigate within home tab
        navigator.navigate(HomeDestination.Detail("123"))
        assertThat(navigator.currentDestination.value)
            .isEqualTo(HomeDestination.Detail("123"))
    }
}
```

---

## References

- [INDEX.md](../INDEX.md) - Phase 4 KSP Overview
- [KSP-001](./KSP-001-graph-type-enum.md) - Annotation Extractors (prerequisite)
- [CORE-001](../phase1-core/CORE-001-navnode-hierarchy.md) - NavNode definitions
