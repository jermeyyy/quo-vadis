# KSP-004: Create NavNode Builder Generator

## Task Metadata

| Property | Value |
|----------|-------|
| **Task ID** | KSP-004 |
| **Task Name** | Create NavNode Builder Generator |
| **Phase** | Phase 3: KSP Processor Updates |
| **Complexity** | High |
| **Estimated Time** | 4-5 days |
| **Dependencies** | KSP-002, KSP-003 |
| **Blocked By** | KSP-002, KSP-003 |
| **Blocks** | KSP-005, KSP-006 |

---

## Overview

This task creates a new KSP generator that produces `build{GraphName}NavNode()` functions. These functions return `NavNode` tree structures based on `@Graph` annotations, enabling the new tree-based navigation architecture.

### Generated Output

For each `@Graph` annotated class, the generator produces:

```kotlin
// Input:
@Graph("main", type = GraphType.STACK, startDestination = "Home")
sealed class MainDestination : Destination {
    @Route("home") data object Home : MainDestination()
    @Route("profile") data class Profile(val userId: String) : MainDestination()
}

// Generated:
fun buildMainDestinationNavNode(
    key: String = "main-root",
    parentKey: String? = null
): NavNode {
    return StackNode(
        key = key,
        parentKey = parentKey,
        children = listOf(
            ScreenNode(
                key = "$key/home",
                parentKey = key,
                destination = MainDestination.Home
            )
        )
    )
}
```

---

## File Location

```
quo-vadis-ksp/src/main/kotlin/com/jermey/quo/vadis/ksp/NavNodeGenerator.kt
```

---

## Implementation

### NavNodeGenerator Class

```kotlin
package com.jermey.quo.vadis.ksp

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.jermey.quo.vadis.annotations.GraphType
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.buildCodeBlock

/**
 * Generates NavNode builder functions from @Graph annotated classes.
 *
 * This generator produces `build{ClassName}NavNode()` functions that return
 * properly structured NavNode trees based on the graph type:
 *
 * - [GraphType.STACK]: Generates [StackNode] with [ScreenNode] children
 * - [GraphType.TAB]: Generates [TabNode] with [StackNode] per tab
 * - [GraphType.PANE]: Generates [PaneNode] with pane children
 *
 * ## Generated Functions
 *
 * ```kotlin
 * // For stack graphs
 * fun buildMainDestinationNavNode(
 *     key: String = "main-root",
 *     parentKey: String? = null
 * ): NavNode
 *
 * // For tab graphs
 * fun buildMainTabsNavNode(
 *     key: String = "tabs-root",
 *     parentKey: String? = null,
 *     activeTabIndex: Int = 0
 * ): NavNode
 *
 * // For pane graphs
 * fun buildAdaptiveNavNode(
 *     key: String = "pane-root",
 *     parentKey: String? = null,
 *     activePaneIndex: Int = 0
 * ): NavNode
 * ```
 */
class NavNodeGenerator(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) {

    /**
     * Generate NavNode builder functions for all provided graph infos.
     *
     * @param graphInfos List of extracted graph information
     */
    fun generate(graphInfos: List<GraphInfo>) {
        graphInfos.forEach { graphInfo ->
            try {
                generateNavNodeBuilder(graphInfo)
            } catch (e: Exception) {
                logger.error(
                    "Failed to generate NavNode builder for ${graphInfo.className}: ${e.message}",
                    graphInfo.graphClass
                )
            }
        }
    }

    /**
     * Generate a NavNode builder function for a single graph.
     */
    private fun generateNavNodeBuilder(graphInfo: GraphInfo) {
        val fileName = "${graphInfo.className}NavNodeBuilder"
        val fileSpec = FileSpec.builder(graphInfo.packageName, fileName)
            .addFileComment(
                """
                |Generated by Quo Vadis KSP Processor.
                |Do not modify this file manually.
                """.trimMargin()
            )
            .addFunction(generateBuilderFunction(graphInfo))
            .apply {
                // Add helper functions if needed
                if (graphInfo.isTabGraph || graphInfo.isPaneGraph) {
                    addFunction(generateKeyGeneratorHelper())
                }
            }
            .build()

        val dependencies = Dependencies(
            aggregating = false,
            sources = arrayOf(graphInfo.graphClass.containingFile!!)
        )

        codeGenerator.createNewFile(
            dependencies = dependencies,
            packageName = graphInfo.packageName,
            fileName = fileName
        ).bufferedWriter().use { writer ->
            fileSpec.writeTo(writer)
        }

        logger.info("Generated $fileName.kt")
    }

    /**
     * Generate the main builder function based on graph type.
     */
    private fun generateBuilderFunction(graphInfo: GraphInfo): FunSpec {
        return when (graphInfo.graphType) {
            GraphType.STACK -> generateStackBuilderFunction(graphInfo)
            GraphType.TAB -> generateTabBuilderFunction(graphInfo)
            GraphType.PANE -> generatePaneBuilderFunction(graphInfo)
        }
    }

    // =========================================================================
    // Stack Graph Generation
    // =========================================================================

    /**
     * Generate builder function for STACK type graphs.
     *
     * ```kotlin
     * fun buildMainDestinationNavNode(
     *     key: String = "main-root",
     *     parentKey: String? = null
     * ): NavNode {
     *     return StackNode(
     *         key = key,
     *         parentKey = parentKey,
     *         children = listOf(
     *             ScreenNode(
     *                 key = "$key/home",
     *                 parentKey = key,
     *                 destination = MainDestination.Home
     *             )
     *         )
     *     )
     * }
     * ```
     */
    private fun generateStackBuilderFunction(graphInfo: GraphInfo): FunSpec {
        val functionName = "build${graphInfo.className}NavNode"
        val defaultKey = "${graphInfo.graphName}-root"

        val startDestination = graphInfo.resolvedStartDestination
            ?: run {
                logger.warn("No start destination found for ${graphInfo.className}")
                null
            }

        return FunSpec.builder(functionName)
            .addKdoc(
                """
                |Build a NavNode tree for the ${graphInfo.graphName} navigation graph.
                |
                |@param key Unique identifier for the root StackNode
                |@param parentKey Key of the parent node, or null if this is the root
                |@return A [StackNode] containing the initial navigation state
                """.trimMargin()
            )
            .addParameter(
                ParameterSpec.builder("key", String::class)
                    .defaultValue("%S", defaultKey)
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("parentKey", String::class.asNullable())
                    .defaultValue("null")
                    .build()
            )
            .returns(QuoVadisClassNames.NAV_NODE)
            .addCode(generateStackNodeCode(graphInfo, startDestination))
            .build()
    }

    /**
     * Generate code block for creating a StackNode.
     */
    private fun generateStackNodeCode(
        graphInfo: GraphInfo,
        startDestination: DestinationInfo?
    ): CodeBlock {
        return buildCodeBlock {
            addStatement("return %T(", QuoVadisClassNames.STACK_NODE)
            indent()
            addStatement("key = key,")
            addStatement("parentKey = parentKey,")

            if (startDestination != null) {
                addStatement("children = listOf(")
                indent()
                addStatement("%T(", QuoVadisClassNames.SCREEN_NODE)
                indent()
                addStatement("key = %P,", "\$key/${startDestination.route}")
                addStatement("parentKey = key,")

                // Generate destination reference
                val destClassName = ClassName(
                    graphInfo.packageName,
                    graphInfo.className,
                    startDestination.name
                )

                if (startDestination.isObject) {
                    addStatement("destination = %T", destClassName)
                } else {
                    // Data class - need to create instance with default values
                    addStatement("destination = %T(/* provide default values */)", destClassName)
                }

                unindent()
                addStatement(")")
                unindent()
                addStatement(")")
            } else {
                addStatement("children = emptyList()")
            }

            unindent()
            addStatement(")")
        }
    }

    // =========================================================================
    // Tab Graph Generation
    // =========================================================================

    /**
     * Generate builder function for TAB type graphs.
     *
     * ```kotlin
     * fun buildMainTabsNavNode(
     *     key: String = "tabs-root",
     *     parentKey: String? = null,
     *     activeTabIndex: Int = 0
     * ): NavNode {
     *     return TabNode(
     *         key = key,
     *         parentKey = parentKey,
     *         stacks = listOf(
     *             StackNode(
     *                 key = "$key/home",
     *                 parentKey = key,
     *                 children = listOf(/* home screen */)
     *             ),
     *             StackNode(
     *                 key = "$key/profile",
     *                 parentKey = key,
     *                 children = listOf(/* profile screen */)
     *             )
     *         ),
     *         activeStackIndex = activeTabIndex
     *     )
     * }
     * ```
     */
    private fun generateTabBuilderFunction(graphInfo: GraphInfo): FunSpec {
        val functionName = "build${graphInfo.className}NavNode"
        val defaultKey = "${graphInfo.graphName}-tabs"

        // Determine initial tab index
        val initialTabIndex = graphInfo.startDestinationName?.let { startName ->
            graphInfo.destinations.indexOfFirst { it.name == startName }
        }?.takeIf { it >= 0 } ?: 0

        return FunSpec.builder(functionName)
            .addKdoc(
                """
                |Build a TabNode tree for the ${graphInfo.graphName} tab navigation.
                |
                |Each destination in the graph becomes a separate tab with its own stack.
                |
                |@param key Unique identifier for the root TabNode
                |@param parentKey Key of the parent node, or null if this is the root
                |@param activeTabIndex Index of the initially active tab (0-based)
                |@return A [TabNode] containing parallel stacks for each tab
                """.trimMargin()
            )
            .addParameter(
                ParameterSpec.builder("key", String::class)
                    .defaultValue("%S", defaultKey)
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("parentKey", String::class.asNullable())
                    .defaultValue("null")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("activeTabIndex", Int::class)
                    .defaultValue("%L", initialTabIndex)
                    .build()
            )
            .returns(QuoVadisClassNames.NAV_NODE)
            .addCode(generateTabNodeCode(graphInfo))
            .build()
    }

    /**
     * Generate code block for creating a TabNode.
     */
    private fun generateTabNodeCode(graphInfo: GraphInfo): CodeBlock {
        return buildCodeBlock {
            addStatement("return %T(", QuoVadisClassNames.TAB_NODE)
            indent()
            addStatement("key = key,")
            addStatement("parentKey = parentKey,")
            addStatement("stacks = listOf(")
            indent()

            graphInfo.destinations.forEachIndexed { index, destination ->
                val isLast = index == graphInfo.destinations.lastIndex
                addStatement("%T(", QuoVadisClassNames.STACK_NODE)
                indent()
                addStatement("key = %P,", "\$key/${destination.route}")
                addStatement("parentKey = key,")
                addStatement("children = listOf(")
                indent()
                addStatement("%T(", QuoVadisClassNames.SCREEN_NODE)
                indent()
                addStatement("key = %P,", "\$key/${destination.route}/root")
                addStatement("parentKey = %P,", "\$key/${destination.route}")

                val destClassName = ClassName(
                    graphInfo.packageName,
                    graphInfo.className,
                    destination.name
                )

                if (destination.isObject) {
                    addStatement("destination = %T", destClassName)
                } else {
                    addStatement("destination = %T(/* provide default values */)", destClassName)
                }

                unindent()
                addStatement(")")
                unindent()
                addStatement(")")
                unindent()
                addStatement(")${if (isLast) "" else ","}")
            }

            unindent()
            addStatement("),")
            addStatement("activeStackIndex = activeTabIndex")
            unindent()
            addStatement(")")
        }
    }

    // =========================================================================
    // Pane Graph Generation
    // =========================================================================

    /**
     * Generate builder function for PANE type graphs.
     *
     * ```kotlin
     * fun buildAdaptiveNavNode(
     *     key: String = "pane-root",
     *     parentKey: String? = null,
     *     activePaneIndex: Int = 0
     * ): NavNode {
     *     return PaneNode(
     *         key = key,
     *         parentKey = parentKey,
     *         panes = listOf(
     *             StackNode(key = "$key/list", ...),
     *             StackNode(key = "$key/detail", ...)
     *         ),
     *         activePaneIndex = activePaneIndex
     *     )
     * }
     * ```
     */
    private fun generatePaneBuilderFunction(graphInfo: GraphInfo): FunSpec {
        val functionName = "build${graphInfo.className}NavNode"
        val defaultKey = "${graphInfo.graphName}-pane"

        return FunSpec.builder(functionName)
            .addKdoc(
                """
                |Build a PaneNode tree for the ${graphInfo.graphName} adaptive layout.
                |
                |Each destination in the graph becomes a pane that can be displayed
                |simultaneously in split-view or master-detail configurations.
                |
                |@param key Unique identifier for the root PaneNode
                |@param parentKey Key of the parent node, or null if this is the root
                |@param activePaneIndex Index of the pane with navigation focus (0-based)
                |@return A [PaneNode] containing multiple display panes
                """.trimMargin()
            )
            .addParameter(
                ParameterSpec.builder("key", String::class)
                    .defaultValue("%S", defaultKey)
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("parentKey", String::class.asNullable())
                    .defaultValue("null")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("activePaneIndex", Int::class)
                    .defaultValue("0")
                    .build()
            )
            .returns(QuoVadisClassNames.NAV_NODE)
            .addCode(generatePaneNodeCode(graphInfo))
            .build()
    }

    /**
     * Generate code block for creating a PaneNode.
     */
    private fun generatePaneNodeCode(graphInfo: GraphInfo): CodeBlock {
        return buildCodeBlock {
            addStatement("return %T(", QuoVadisClassNames.PANE_NODE)
            indent()
            addStatement("key = key,")
            addStatement("parentKey = parentKey,")
            addStatement("panes = listOf(")
            indent()

            graphInfo.destinations.forEachIndexed { index, destination ->
                val isLast = index == graphInfo.destinations.lastIndex
                // Each pane is a StackNode that can hold navigation history
                addStatement("%T(", QuoVadisClassNames.STACK_NODE)
                indent()
                addStatement("key = %P,", "\$key/${destination.route}")
                addStatement("parentKey = key,")
                addStatement("children = listOf(")
                indent()
                addStatement("%T(", QuoVadisClassNames.SCREEN_NODE)
                indent()
                addStatement("key = %P,", "\$key/${destination.route}/root")
                addStatement("parentKey = %P,", "\$key/${destination.route}")

                val destClassName = ClassName(
                    graphInfo.packageName,
                    graphInfo.className,
                    destination.name
                )

                if (destination.isObject) {
                    addStatement("destination = %T", destClassName)
                } else {
                    addStatement("destination = %T(/* provide default values */)", destClassName)
                }

                unindent()
                addStatement(")")
                unindent()
                addStatement(")")
                unindent()
                addStatement(")${if (isLast) "" else ","}")
            }

            unindent()
            addStatement("),")
            addStatement("activePaneIndex = activePaneIndex")
            unindent()
            addStatement(")")
        }
    }

    // =========================================================================
    // Helper Function Generation
    // =========================================================================

    /**
     * Generate a helper function for creating unique keys.
     */
    private fun generateKeyGeneratorHelper(): FunSpec {
        return FunSpec.builder("generateChildKey")
            .addModifiers(KModifier.PRIVATE)
            .addParameter("parentKey", String::class)
            .addParameter("suffix", String::class)
            .returns(String::class)
            .addStatement("return %P", "\$parentKey/\$suffix")
            .build()
    }

    // =========================================================================
    // Utility Extensions
    // =========================================================================

    /**
     * Extension to get nullable class type for KotlinPoet.
     */
    private fun Class<*>.asNullable() =
        ClassName.bestGuess(this.canonicalName).copy(nullable = true)
}
```

---

## Implementation Steps

### Step 1: Create NavNodeGenerator Class (1 day)

Create the basic generator structure with:
- Constructor taking `CodeGenerator` and `KSPLogger`
- `generate()` method accepting `List<GraphInfo>`
- Basic file generation scaffolding

### Step 2: Implement Stack Graph Generation (1 day)

Implement `generateStackBuilderFunction()`:
- Generate function signature with key/parentKey parameters
- Create StackNode with initial ScreenNode
- Handle data object vs data class destinations

### Step 3: Implement Tab Graph Generation (1 day)

Implement `generateTabBuilderFunction()`:
- Generate function with activeTabIndex parameter
- Create TabNode with StackNode per destination
- Wire up proper key generation for nested nodes

### Step 4: Implement Pane Graph Generation (0.5 days)

Implement `generatePaneBuilderFunction()`:
- Similar structure to tab generation
- Create PaneNode with StackNode per pane

### Step 5: Integration with Symbol Processor (0.5 days)

Update `QuoVadisSymbolProcessor` to invoke `NavNodeGenerator`:

```kotlin
class QuoVadisSymbolProcessor(...) : SymbolProcessor {
    private val navNodeGenerator = NavNodeGenerator(codeGenerator, logger)

    override fun process(resolver: Resolver): List<KSAnnotated> {
        // ... existing processing ...
        
        // Generate NavNode builders
        navNodeGenerator.generate(graphInfos)
        
        // ... rest of processing ...
    }
}
```

### Step 6: Unit Tests (1 day)

Create comprehensive tests for all generation paths.

---

## Generated Code Examples

### Stack Graph

```kotlin
// Input
@Graph("main", startDestination = "Home")
sealed class MainDestination : Destination {
    @Route("home") data object Home : MainDestination()
    @Route("profile") data class Profile(val userId: String) : MainDestination()
}

// Output: MainDestinationNavNodeBuilder.kt
/**
 * Generated by Quo Vadis KSP Processor.
 * Do not modify this file manually.
 */
package com.example.navigation

import com.jermey.quo.vadis.core.navigation.core.NavNode
import com.jermey.quo.vadis.core.navigation.core.ScreenNode
import com.jermey.quo.vadis.core.navigation.core.StackNode

/**
 * Build a NavNode tree for the main navigation graph.
 *
 * @param key Unique identifier for the root StackNode
 * @param parentKey Key of the parent node, or null if this is the root
 * @return A [StackNode] containing the initial navigation state
 */
fun buildMainDestinationNavNode(
    key: String = "main-root",
    parentKey: String? = null
): NavNode {
    return StackNode(
        key = key,
        parentKey = parentKey,
        children = listOf(
            ScreenNode(
                key = "$key/home",
                parentKey = key,
                destination = MainDestination.Home
            )
        )
    )
}
```

### Tab Graph

```kotlin
// Input
@Graph("bottomNav", type = GraphType.TAB)
sealed class BottomNavDestination : Destination {
    @Route("home") data object Home : BottomNavDestination()
    @Route("search") data object Search : BottomNavDestination()
    @Route("profile") data object Profile : BottomNavDestination()
}

// Output: BottomNavDestinationNavNodeBuilder.kt
fun buildBottomNavDestinationNavNode(
    key: String = "bottomNav-tabs",
    parentKey: String? = null,
    activeTabIndex: Int = 0
): NavNode {
    return TabNode(
        key = key,
        parentKey = parentKey,
        stacks = listOf(
            StackNode(
                key = "$key/home",
                parentKey = key,
                children = listOf(
                    ScreenNode(
                        key = "$key/home/root",
                        parentKey = "$key/home",
                        destination = BottomNavDestination.Home
                    )
                )
            ),
            StackNode(
                key = "$key/search",
                parentKey = key,
                children = listOf(
                    ScreenNode(
                        key = "$key/search/root",
                        parentKey = "$key/search",
                        destination = BottomNavDestination.Search
                    )
                )
            ),
            StackNode(
                key = "$key/profile",
                parentKey = key,
                children = listOf(
                    ScreenNode(
                        key = "$key/profile/root",
                        parentKey = "$key/profile",
                        destination = BottomNavDestination.Profile
                    )
                )
            )
        ),
        activeStackIndex = activeTabIndex
    )
}
```

### Pane Graph

```kotlin
// Input
@Graph("adaptive", type = GraphType.PANE)
sealed class AdaptiveDestination : Destination {
    @Route("list") data object List : AdaptiveDestination()
    @Route("detail") data object Detail : AdaptiveDestination()
}

// Output: AdaptiveDestinationNavNodeBuilder.kt
fun buildAdaptiveDestinationNavNode(
    key: String = "adaptive-pane",
    parentKey: String? = null,
    activePaneIndex: Int = 0
): NavNode {
    return PaneNode(
        key = key,
        parentKey = parentKey,
        panes = listOf(
            StackNode(
                key = "$key/list",
                parentKey = key,
                children = listOf(
                    ScreenNode(
                        key = "$key/list/root",
                        parentKey = "$key/list",
                        destination = AdaptiveDestination.List
                    )
                )
            ),
            StackNode(
                key = "$key/detail",
                parentKey = key,
                children = listOf(
                    ScreenNode(
                        key = "$key/detail/root",
                        parentKey = "$key/detail",
                        destination = AdaptiveDestination.Detail
                    )
                )
            )
        ),
        activePaneIndex = activePaneIndex
    )
}
```

---

## Edge Cases

### Data Class Destinations

For destinations that are data classes (with parameters), the generator should:

1. Generate a TODO comment or use reflection for default instantiation
2. Consider generating overloaded functions with destination factories:

```kotlin
fun buildMainDestinationNavNode(
    key: String = "main-root",
    parentKey: String? = null,
    startDestination: MainDestination = MainDestination.Home
): NavNode {
    return StackNode(
        key = key,
        parentKey = parentKey,
        children = listOf(
            ScreenNode(
                key = "$key/${startDestination.route}",
                parentKey = key,
                destination = startDestination
            )
        )
    )
}
```

### Empty Graphs

```kotlin
@Graph("empty")
sealed class EmptyGraph : Destination
// Should generate StackNode with empty children list
```

### Nested Data Classes

For complex destinations with nested types, ensure proper qualified name resolution.

---

## Files Affected

| File | Action | Description |
|------|--------|-------------|
| `quo-vadis-ksp/.../NavNodeGenerator.kt` | Create | New generator class |
| `quo-vadis-ksp/.../QuoVadisSymbolProcessor.kt` | Modify | Integrate NavNodeGenerator |

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| KSP-002 (Class References) | Hard | Required for NavNode class names |
| KSP-003 (GraphInfo.graphType) | Hard | Required to determine node type |
| CORE-001 (NavNode Hierarchy) | Soft | Generated code references these classes |

---

## Acceptance Criteria

- [ ] `NavNodeGenerator` class created in `quo-vadis-ksp`
- [ ] Generates `build{ClassName}NavNode()` for STACK graphs
- [ ] Generates `build{ClassName}NavNode()` for TAB graphs with `activeTabIndex` parameter
- [ ] Generates `build{ClassName}NavNode()` for PANE graphs with `activePaneIndex` parameter
- [ ] Generated functions have proper KDoc documentation
- [ ] Key generation produces unique, deterministic keys
- [ ] Handles data object destinations (direct reference)
- [ ] Handles data class destinations (with TODO or factory parameter)
- [ ] Integrated with `QuoVadisSymbolProcessor`
- [ ] Unit tests for all graph types
- [ ] Generated code compiles without errors

---

## Testing Notes

```kotlin
@Test
fun `generates StackNode for STACK graph`() {
    val source = """
        @Graph("test")
        sealed class TestGraph : Destination {
            @Route("home") data object Home : TestGraph()
        }
    """.trimIndent()

    val generated = compile(source)
    
    assertContains(generated, "fun buildTestGraphNavNode(")
    assertContains(generated, "StackNode(")
    assertContains(generated, "ScreenNode(")
    assertContains(generated, "destination = TestGraph.Home")
}

@Test
fun `generates TabNode for TAB graph`() {
    val source = """
        @Graph("tabs", type = GraphType.TAB)
        sealed class TabsGraph : Destination {
            @Route("a") data object A : TabsGraph()
            @Route("b") data object B : TabsGraph()
        }
    """.trimIndent()

    val generated = compile(source)
    
    assertContains(generated, "TabNode(")
    assertContains(generated, "stacks = listOf(")
    assertContains(generated, "activeStackIndex = activeTabIndex")
}

@Test
fun `generates PaneNode for PANE graph`() {
    val source = """
        @Graph("panes", type = GraphType.PANE)
        sealed class PanesGraph : Destination {
            @Route("list") data object List : PanesGraph()
            @Route("detail") data object Detail : PanesGraph()
        }
    """.trimIndent()

    val generated = compile(source)
    
    assertContains(generated, "PaneNode(")
    assertContains(generated, "panes = listOf(")
    assertContains(generated, "activePaneIndex = activePaneIndex")
}

@Test
fun `generates unique keys for nested nodes`() {
    val source = """
        @Graph("test", type = GraphType.TAB)
        sealed class TestGraph : Destination {
            @Route("a") data object A : TestGraph()
            @Route("b") data object B : TestGraph()
        }
    """.trimIndent()

    val generated = compile(source)
    
    // Verify unique key patterns
    assertContains(generated, "\"\$key/a\"")
    assertContains(generated, "\"\$key/b\"")
    assertContains(generated, "\"\$key/a/root\"")
    assertContains(generated, "\"\$key/b/root\"")
}
```

---

## Future Enhancements

### Lazy Initialization for Tabs

Consider generating lazy tab initialization to reduce initial memory:

```kotlin
fun buildTabsNavNodeLazy(
    key: String = "tabs-root",
    parentKey: String? = null,
    activeTabIndex: Int = 0
): TabNode {
    return TabNode(
        key = key,
        parentKey = parentKey,
        stacks = (0 until 3).map { index ->
            if (index == activeTabIndex) {
                createStackForTab(index, key)
            } else {
                emptyStackForTab(index, key)
            }
        },
        activeStackIndex = activeTabIndex
    )
}
```

### Custom Start Destinations

Support providing custom start destinations at call site:

```kotlin
fun buildMainNavNode(
    key: String = "main-root",
    parentKey: String? = null,
    customStartDestination: MainDestination? = null
): NavNode
```

---

## References

- [INDEX](../INDEX.md) - Phase 3 Overview
- [KSP-002](./KSP-002-class-references.md) - NavNode class references
- [KSP-003](./KSP-003-graph-extractor.md) - GraphInfo with graphType
- [CORE-001](../phase1-core/CORE-001-navnode-hierarchy.md) - NavNode definitions
- [Current GraphBuilderGenerator](../../../quo-vadis-ksp/src/main/kotlin/com/jermey/quo/vadis/ksp/GraphBuilderGenerator.kt)
