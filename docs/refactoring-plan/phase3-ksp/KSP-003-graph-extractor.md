# KSP-003: Create Screen Registry Generator

## Task Metadata

| Property | Value |
|----------|-------|
| **Task ID** | KSP-003 |
| **Task Name** | Create Screen Registry Generator |
| **Phase** | Phase 4: KSP Processor Rewrite |
| **Complexity** | Medium |
| **Estimated Time** | 2-3 days |
| **Dependencies** | KSP-001 (Annotation Extractors) |
| **Blocked By** | KSP-001 |
| **Blocks** | None |

---

## Overview

This task creates the **Screen Registry Generator**—a KSP code generator that produces `GeneratedScreenRegistry.kt`, mapping destination types to their corresponding composable screen functions. The registry serves as the central dispatch mechanism for rendering screen content based on the current destination.

### Purpose

The `ScreenRegistryGenerator` consumes `ScreenInfo` models (extracted by `ScreenExtractor` from KSP-001) and generates a type-safe registry that:

1. **Maps destinations to composables**: Creates a `when` expression dispatching to `@Screen`-annotated functions
2. **Handles multiple function signatures**: Supports simple, destination-parameterized, and shared-scope functions
3. **Provides content availability checks**: Generates `hasContent()` for runtime destination validation

### Data Flow

```
@Screen annotations  →  ScreenExtractor  →  List<ScreenInfo>
                                                   ↓
                                         ScreenRegistryGenerator
                                                   ↓
                                       GeneratedScreenRegistry.kt
```

---

## Module Structure

```
quo-vadis-ksp/src/main/kotlin/com/jermey/quo/vadis/ksp/
├── extractors/
│   └── ScreenExtractor.kt          # From KSP-001 (input)
│
├── generators/
│   └── ScreenRegistryGenerator.kt  # THIS TASK
│
└── models/
    └── ScreenInfo.kt               # From KSP-001 (input)
```

---

## Generated Output

### GeneratedScreenRegistry.kt

The generator produces a single registry object implementing the `ScreenRegistry` interface.

```kotlin
// File: GeneratedScreenRegistry.kt
package com.example.generated

import androidx.compose.animation.AnimatedVisibilityScope
import androidx.compose.animation.SharedTransitionScope
import androidx.compose.runtime.Composable
import com.jermey.quo.vadis.core.navigation.core.Destination
import com.jermey.quo.vadis.core.navigation.core.Navigator
import com.jermey.quo.vadis.core.navigation.core.ScreenRegistry
import com.example.HomeDestination
import com.example.ProfileDestination
import com.example.screens.*

/**
 * KSP-generated screen registry mapping destinations to composable content.
 *
 * Generated from @Screen annotations found in the codebase.
 * DO NOT EDIT - This file is auto-generated by Quo Vadis KSP processor.
 */
object GeneratedScreenRegistry : ScreenRegistry {
    
    @Composable
    override fun Content(
        destination: Destination,
        navigator: Navigator,
        sharedTransitionScope: SharedTransitionScope?,
        animatedVisibilityScope: AnimatedVisibilityScope?
    ) {
        when (destination) {
            // HomeDestination screens
            is HomeDestination.Feed -> FeedScreen(navigator)
            is HomeDestination.Detail -> DetailScreen(destination, navigator)
            is HomeDestination.Gallery -> GalleryScreen(
                destination,
                navigator,
                sharedTransitionScope!!,
                animatedVisibilityScope!!
            )
            
            // ProfileDestination screens
            is ProfileDestination.Overview -> ProfileOverviewScreen(navigator)
            is ProfileDestination.Settings -> SettingsScreen(destination, navigator)
            
            else -> error("No screen registered for destination: $destination")
        }
    }
    
    override fun hasContent(destination: Destination): Boolean = when (destination) {
        is HomeDestination.Feed,
        is HomeDestination.Detail,
        is HomeDestination.Gallery,
        is ProfileDestination.Overview,
        is ProfileDestination.Settings -> true
        else -> false
    }
}
```

---

## Implementation

### ScreenRegistryGenerator

```kotlin
package com.jermey.quo.vadis.ksp.generators

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.jermey.quo.vadis.ksp.QuoVadisClassNames
import com.jermey.quo.vadis.ksp.models.ScreenInfo
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ksp.writeTo

/**
 * Generates the screen registry mapping destinations to composable content.
 *
 * Consumes [ScreenInfo] models and produces a single `GeneratedScreenRegistry.kt`
 * file containing:
 * - `object GeneratedScreenRegistry : ScreenRegistry`
 * - `Content()` composable with `when` expression dispatching to @Screen functions
 * - `hasContent()` method for destination availability checks
 *
 * ## Function Signature Handling
 *
 * The generator handles three function signatures:
 * 1. **Simple**: `fun FeedScreen(navigator: Navigator)`
 * 2. **With destination**: `fun DetailScreen(destination: Detail, navigator: Navigator)`
 * 3. **With shared scopes**: `fun GalleryScreen(destination: Gallery, navigator: Navigator, sharedTransitionScope: SharedTransitionScope, animatedVisibilityScope: AnimatedVisibilityScope)`
 */
class ScreenRegistryGenerator(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) {
    
    companion object {
        private const val GENERATED_PACKAGE = "com.jermey.quo.vadis.generated"
        private const val REGISTRY_NAME = "GeneratedScreenRegistry"
    }
    
    /**
     * Generate the screen registry from extracted screen information.
     *
     * @param screens List of ScreenInfo models from ScreenExtractor
     */
    fun generate(screens: List<ScreenInfo>) {
        if (screens.isEmpty()) {
            logger.warn("No @Screen annotations found, skipping registry generation")
            return
        }
        
        val fileSpec = buildFileSpec(screens)
        
        val dependencies = Dependencies(
            aggregating = true,
            sources = screens.map { it.functionDeclaration.containingFile!! }.toTypedArray()
        )
        
        fileSpec.writeTo(codeGenerator, dependencies)
        
        logger.info("Generated $REGISTRY_NAME with ${screens.size} screen bindings")
    }
    
    private fun buildFileSpec(screens: List<ScreenInfo>): FileSpec {
        return FileSpec.builder(GENERATED_PACKAGE, REGISTRY_NAME)
            .addFileComment("DO NOT EDIT - Auto-generated by Quo Vadis KSP processor")
            .addImports(screens)
            .addType(buildRegistryObject(screens))
            .build()
    }
    
    private fun FileSpec.Builder.addImports(screens: List<ScreenInfo>): FileSpec.Builder {
        // Core imports
        addImport("androidx.compose.runtime", "Composable")
        addImport("androidx.compose.animation", "AnimatedVisibilityScope")
        addImport("androidx.compose.animation", "SharedTransitionScope")
        addImport(QuoVadisClassNames.DESTINATION.packageName, QuoVadisClassNames.DESTINATION.simpleName)
        addImport(QuoVadisClassNames.NAVIGATOR.packageName, QuoVadisClassNames.NAVIGATOR.simpleName)
        addImport(QuoVadisClassNames.SCREEN_REGISTRY.packageName, QuoVadisClassNames.SCREEN_REGISTRY.simpleName)
        
        // Screen function imports
        screens.forEach { screen ->
            addImport(screen.packageName, screen.functionName)
        }
        
        // Destination class imports
        screens.map { it.destinationClass }
            .distinctBy { it.qualifiedName?.asString() }
            .forEach { destClass ->
                val packageName = destClass.packageName.asString()
                val parentClass = destClass.parentDeclaration?.simpleName?.asString()
                val className = if (parentClass != null) parentClass else destClass.simpleName.asString()
                addImport(packageName, className)
            }
        
        return this
    }
    
    private fun buildRegistryObject(screens: List<ScreenInfo>): TypeSpec {
        return TypeSpec.objectBuilder(REGISTRY_NAME)
            .addKdoc("""
                KSP-generated screen registry mapping destinations to composable content.
                
                Generated from @Screen annotations found in the codebase.
                DO NOT EDIT - This file is auto-generated by Quo Vadis KSP processor.
            """.trimIndent())
            .addSuperinterface(QuoVadisClassNames.SCREEN_REGISTRY)
            .addFunction(buildContentFunction(screens))
            .addFunction(buildHasContentFunction(screens))
            .build()
    }
    
    private fun buildContentFunction(screens: List<ScreenInfo>): FunSpec {
        val whenCases = screens
            .groupBy { it.destinationClass.parentDeclaration?.simpleName?.asString() }
            .flatMap { (parent, groupedScreens) ->
                val comment = if (parent != null) "// $parent screens" else "// Screens"
                listOf(comment) + groupedScreens.map { buildWhenCase(it) }
            }
            .joinToString("\n")
        
        return FunSpec.builder("Content")
            .addAnnotation(ClassName("androidx.compose.runtime", "Composable"))
            .addModifiers(KModifier.OVERRIDE)
            .addParameter("destination", QuoVadisClassNames.DESTINATION)
            .addParameter("navigator", QuoVadisClassNames.NAVIGATOR)
            .addParameter(
                ParameterSpec.builder(
                    "sharedTransitionScope",
                    ClassName("androidx.compose.animation", "SharedTransitionScope").copy(nullable = true)
                ).build()
            )
            .addParameter(
                ParameterSpec.builder(
                    "animatedVisibilityScope",
                    ClassName("androidx.compose.animation", "AnimatedVisibilityScope").copy(nullable = true)
                ).build()
            )
            .addCode("""
                when (destination) {
                    $whenCases
                    
                    else -> error("No screen registered for destination: ${'$'}destination")
                }
            """.trimIndent())
            .build()
    }
    
    private fun buildWhenCase(screen: ScreenInfo): String {
        val destClassName = buildDestinationClassName(screen)
        val functionCall = buildFunctionCall(screen)
        return "is $destClassName -> $functionCall"
    }
    
    private fun buildDestinationClassName(screen: ScreenInfo): String {
        val destClass = screen.destinationClass
        val parentClass = destClass.parentDeclaration?.simpleName?.asString()
        val simpleName = destClass.simpleName.asString()
        return if (parentClass != null) "$parentClass.$simpleName" else simpleName
    }
    
    private fun buildFunctionCall(screen: ScreenInfo): String {
        val funcName = screen.functionName
        val args = mutableListOf<String>()
        
        // Add destination parameter if needed
        if (screen.hasDestinationParam) {
            args.add("destination")
        }
        
        // Navigator is always passed
        args.add("navigator")
        
        // Add shared transition scopes if needed
        if (screen.hasSharedTransitionScope) {
            args.add("sharedTransitionScope!!")
        }
        if (screen.hasAnimatedVisibilityScope) {
            args.add("animatedVisibilityScope!!")
        }
        
        return "$funcName(${args.joinToString(", ")})"
    }
    
    private fun buildHasContentFunction(screens: List<ScreenInfo>): FunSpec {
        val destPatterns = screens
            .map { buildDestinationClassName(it) }
            .joinToString(",\n        is ") { it }
        
        return FunSpec.builder("hasContent")
            .addModifiers(KModifier.OVERRIDE)
            .addParameter("destination", QuoVadisClassNames.DESTINATION)
            .returns(Boolean::class)
            .addCode("""
                return when (destination) {
                    is $destPatterns -> true
                    else -> false
                }
            """.trimIndent())
            .build()
    }
}
```

### QuoVadisClassNames (additions)

```kotlin
// Add to existing QuoVadisClassNames.kt
object QuoVadisClassNames {
    // ... existing class names ...
    
    val SCREEN_REGISTRY = ClassName("com.jermey.quo.vadis.core.navigation.core", "ScreenRegistry")
    val DESTINATION = ClassName("com.jermey.quo.vadis.core.navigation.core", "Destination")
    val NAVIGATOR = ClassName("com.jermey.quo.vadis.core.navigation.core", "Navigator")
}
```

---

## Function Signature Handling

The generator handles three distinct `@Screen` function signatures:

### Signature 1: Simple (Navigator only)

**Input:**
```kotlin
@Screen(HomeDestination.Feed::class)
@Composable
fun FeedScreen(navigator: Navigator) { }
```

**Generated call:**
```kotlin
is HomeDestination.Feed -> FeedScreen(navigator)
```

### Signature 2: With Destination Parameter

**Input:**
```kotlin
@Screen(HomeDestination.Detail::class)
@Composable
fun DetailScreen(destination: HomeDestination.Detail, navigator: Navigator) { }
```

**Generated call:**
```kotlin
is HomeDestination.Detail -> DetailScreen(destination, navigator)
```

### Signature 3: With Shared Transition Scopes

**Input:**
```kotlin
@Screen(HomeDestination.Gallery::class)
@Composable
fun GalleryScreen(
    destination: HomeDestination.Gallery,
    navigator: Navigator,
    sharedTransitionScope: SharedTransitionScope,
    animatedVisibilityScope: AnimatedVisibilityScope
) { }
```

**Generated call:**
```kotlin
is HomeDestination.Gallery -> GalleryScreen(
    destination,
    navigator,
    sharedTransitionScope!!,
    animatedVisibilityScope!!
)
```

---

## Implementation Steps

### Step 1: Create Generator Class (Day 1 - 4 hours)

Create `ScreenRegistryGenerator.kt` with:
- Basic file generation structure
- KotlinPoet FileSpec building
- Import management

### Step 2: Implement Content Function Generation (Day 1 - 3 hours)

Build the `Content()` function with:
- `when` expression structure
- Grouped destination comments
- Proper function call generation

### Step 3: Implement Function Signature Detection (Day 2 - 4 hours)

Handle all three function signatures:
- Detect `hasDestinationParam` from ScreenInfo
- Detect `hasSharedTransitionScope` and `hasAnimatedVisibilityScope`
- Generate appropriate argument lists

### Step 4: Implement hasContent Function (Day 2 - 2 hours)

Generate the `hasContent()` method:
- Build destination pattern list
- Handle nested sealed class destinations

### Step 5: Add QuoVadisClassNames (Day 2 - 1 hour)

Add required class name constants for type-safe references.

### Step 6: Wire into Main Processor (Day 3 - 2 hours)

Integrate generator into `QuoVadisSymbolProcessor`:
```kotlin
val screens = screenExtractor.extractAll(resolver)
screenRegistryGenerator.generate(screens)
```

### Step 7: Write Unit Tests (Day 3 - 4 hours)

Test all scenarios:
- Empty screen list handling
- Single screen generation
- Multiple screens with different signatures
- Grouped destination comments

---

## Edge Cases

### No @Screen Annotations

```kotlin
// If no @Screen annotations found
// Generator logs warning and skips file generation
```

### Missing Destination for Screen

```kotlin
// @Screen referencing non-existent destination
// Error reported by ScreenExtractor during extraction phase
```

### Duplicate Destination Bindings

```kotlin
// Two @Screen annotations for same destination
@Screen(HomeDestination.Feed::class)
fun FeedScreenA(navigator: Navigator) { }

@Screen(HomeDestination.Feed::class)
fun FeedScreenB(navigator: Navigator) { }

// Generator should warn and use first encountered
```

### Nested Sealed Class Destinations

```kotlin
// Properly handles deeply nested destinations
sealed class MainGraph : Destination {
    sealed class Home : MainGraph() {
        data object Feed : Home()
    }
}

// Generated: is MainGraph.Home.Feed -> FeedScreen(navigator)
```

---

## Files Affected

| File | Action | Description |
|------|--------|-------------|
| `quo-vadis-ksp/src/main/kotlin/.../generators/ScreenRegistryGenerator.kt` | Create | Main generator implementation |
| `quo-vadis-ksp/src/main/kotlin/.../QuoVadisClassNames.kt` | Modify | Add ScreenRegistry, Destination, Navigator class names |
| `quo-vadis-ksp/src/main/kotlin/.../QuoVadisSymbolProcessor.kt` | Modify | Wire in ScreenRegistryGenerator |

---

## Acceptance Criteria

- [ ] `ScreenRegistryGenerator` class created with proper KDoc documentation
- [ ] Generates `GeneratedScreenRegistry.kt` in configured package
- [ ] Generated `Content()` function dispatches to correct @Screen functions
- [ ] Handles simple function signature (navigator only)
- [ ] Handles destination parameter signature
- [ ] Handles shared transition scope signature
- [ ] Generated `hasContent()` function returns correct boolean for all destinations
- [ ] Groups destinations by parent class in generated comments
- [ ] Logs warning when no @Screen annotations found
- [ ] Handles duplicate destination bindings gracefully
- [ ] Generated code compiles without errors
- [ ] Unit tests for all function signatures
- [ ] Integration test with full annotation processing

---

## Testing Notes

### Unit Test Examples

```kotlin
class ScreenRegistryGeneratorTest {
    
    @Test
    fun `generates empty registry warning when no screens`() {
        val generator = ScreenRegistryGenerator(codeGenerator, logger)
        
        generator.generate(emptyList())
        
        verify(logger).warn("No @Screen annotations found, skipping registry generation")
        verify(codeGenerator, never()).createNewFile(any(), any(), any())
    }
    
    @Test
    fun `generates Content with simple function call`() {
        val screenInfo = ScreenInfo(
            functionName = "FeedScreen",
            destinationClass = mockDestClass("HomeDestination", "Feed"),
            hasDestinationParam = false,
            hasSharedTransitionScope = false,
            hasAnimatedVisibilityScope = false,
            packageName = "com.example.screens"
        )
        
        val result = generator.generate(listOf(screenInfo))
        
        assertThat(result).contains("is HomeDestination.Feed -> FeedScreen(navigator)")
    }
    
    @Test
    fun `generates Content with destination parameter`() {
        val screenInfo = ScreenInfo(
            functionName = "DetailScreen",
            destinationClass = mockDestClass("HomeDestination", "Detail"),
            hasDestinationParam = true,
            hasSharedTransitionScope = false,
            hasAnimatedVisibilityScope = false,
            packageName = "com.example.screens"
        )
        
        val result = generator.generate(listOf(screenInfo))
        
        assertThat(result).contains("is HomeDestination.Detail -> DetailScreen(destination, navigator)")
    }
    
    @Test
    fun `generates Content with shared scopes`() {
        val screenInfo = ScreenInfo(
            functionName = "GalleryScreen",
            destinationClass = mockDestClass("HomeDestination", "Gallery"),
            hasDestinationParam = true,
            hasSharedTransitionScope = true,
            hasAnimatedVisibilityScope = true,
            packageName = "com.example.screens"
        )
        
        val result = generator.generate(listOf(screenInfo))
        
        assertThat(result).contains(
            "is HomeDestination.Gallery -> GalleryScreen(destination, navigator, sharedTransitionScope!!, animatedVisibilityScope!!)"
        )
    }
    
    @Test
    fun `generates hasContent for all destinations`() {
        val screens = listOf(
            mockScreenInfo("Feed", "HomeDestination"),
            mockScreenInfo("Detail", "HomeDestination"),
            mockScreenInfo("Overview", "ProfileDestination")
        )
        
        val result = generator.generate(screens)
        
        assertThat(result).contains("is HomeDestination.Feed")
        assertThat(result).contains("is HomeDestination.Detail")
        assertThat(result).contains("is ProfileDestination.Overview")
        assertThat(result).contains("-> true")
        assertThat(result).contains("else -> false")
    }
    
    @Test
    fun `groups destinations by parent class in comments`() {
        val screens = listOf(
            mockScreenInfo("Feed", "HomeDestination"),
            mockScreenInfo("Detail", "HomeDestination"),
            mockScreenInfo("Overview", "ProfileDestination")
        )
        
        val result = generator.generate(screens)
        
        assertThat(result).contains("// HomeDestination screens")
        assertThat(result).contains("// ProfileDestination screens")
    }
}
```

### Integration Test

```kotlin
class ScreenRegistryIntegrationTest {
    
    @Test
    fun `generated registry compiles and dispatches correctly`() {
        val source = """
            @Stack(name = "home", startDestination = "Feed")
            sealed class HomeDestination : Destination {
                @Destination(route = "home/feed")
                data object Feed : HomeDestination()
                
                @Destination(route = "home/detail/{id}")
                data class Detail(val id: String) : HomeDestination()
            }
            
            @Screen(HomeDestination.Feed::class)
            @Composable
            fun FeedScreen(navigator: Navigator) { }
            
            @Screen(HomeDestination.Detail::class)
            @Composable
            fun DetailScreen(destination: HomeDestination.Detail, navigator: Navigator) { }
        """.trimIndent()
        
        val result = compile(source)
        
        assertThat(result.exitCode).isEqualTo(KotlinCompilation.ExitCode.OK)
        assertThat(result.generatedFiles).contains("GeneratedScreenRegistry.kt")
        
        // Verify generated code structure
        val generated = result.generatedSourceOf("GeneratedScreenRegistry")
        assertThat(generated).contains("object GeneratedScreenRegistry : ScreenRegistry")
        assertThat(generated).contains("override fun Content(")
        assertThat(generated).contains("override fun hasContent(")
    }
}
```

---

## References

- [INDEX.md](../INDEX.md) - Phase 4 KSP Overview
- [KSP-001](./KSP-001-graph-type-enum.md) - Annotation Extractors (provides ScreenInfo input)
