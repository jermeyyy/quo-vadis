[
  {
    "id": "Demo/demo",
    "title": "Demo",
    "route": "/Demo/demo",
    "content": "@components/CodeBlock/CodeBlock \n\nconst bottomNavCode = `val bottomNavGraph = navigationGraph( ) {\n        startDestination(HomeDestination.Main)\n        destination(HomeDestination.Main) { _, nav -> HomeScreen(nav) }\n        destination(HomeDestination.Details) { _, nav -> DetailsScreen(nav) }\n    }\n    \n    tab( ) {\n        startDestination(ProfileDestination.Main)\n        destination(ProfileDestination.Main) { _, nav -> ProfileScreen(nav) }\n    }\n    \n    tab( ) {\n        startDestination(SettingsDestination.Main)\n        destination(SettingsDestination.Main) { _, nav -> SettingsScreen(nav) }\n    }\n}`\n\nconst masterDetailCode = `// List screen\nLazyColumn {\n    items(products) { product ->\n        ProductCard(\n            product = product,\n            onClick = { \n                navigator.navigate(ProductDestination.Details(product.id)) \n            },\n            imageModifier = Modifier.sharedElement(\n                sharedConfig = SharedElementConfig(\n                    key =  ,\n                    type = SharedElementType.Bounds\n                ),\n                navigator = navigator\n            )\n        )\n    }\n}`\n\nconst multiStepCode = `sealed class ProcessStep : Destination {\n    object Step1 : ProcessStep() { override val route =   }\n    object Step2 : ProcessStep() { override val route =   }\n    object Step3 : ProcessStep() { override val route =   }\n    object Complete : ProcessStep() { override val route =   }\n}\n\n// Navigate forward through steps\nfun onNext(currentStep: ProcessStep) {\n    when (currentStep) {\n        is ProcessStep.Step1 -> navigator.navigate(ProcessStep.Step2)\n        is ProcessStep.Step2 -> navigator.navigate(ProcessStep.Step3)\n        is ProcessStep.Step3 -> navigator.navigateAndClearTo(\n            destination = ProcessStep.Complete,\n            clearRoute =  ,\n            inclusive = false\n        )\n    }\n}`\n\nconst cloneRunCode = `# Clone the repository\ngit clone https://github.com/jermeyyy/quo-vadis.git\ncd quo-vadis\n\n# Run on Android\n./gradlew :composeApp:installDebug\n\n# Run on iOS (macOS only)\nopen iosApp/iosApp.xcodeproj\n\n# Run on Desktop\n./gradlew :composeApp:run\n\n# Run on Web (JavaScript)\n./gradlew :composeApp:jsBrowserDevelopmentRun\n\n# Run on Web (WebAssembly)\n./gradlew :composeApp:wasmJsBrowserDevelopmentRun`\n\nconst mainAppCode = `@Composable\nfun DemoApp() {\n    val navigator = rememberNavigator(startDestination = MainDestination.Home)\n    \n    Scaffold(\n        bottomBar = {\n            BottomNavigationBar(\n                currentRoute = navigator.currentDestination.value?.route,\n                onTabSelected = { destination ->\n                    navigator.navigate(destination)\n                }\n            )\n        }\n    ) { paddingValues ->\n        NavigationHost(\n            navigator = navigator,\n            screenRegistry = MainDestinationScreenRegistry,\n            modifier = Modifier.padding(paddingValues),\n            defaultTransition = NavigationTransitions.SlideHorizontal,\n            predictiveBackMode = PredictiveBackMode.FULL_CASCADE\n        )\n    }\n}`\n\nconst featureModuleCode = `// Using annotation-based API\n@Graph( )\nsealed class ProductDestination : Destination\n\n@Route( )\ndata object ProductList : ProductDestination()\n\n@Serializable\ndata class ProductDetailsData(val productId: String)\n\n@Route( >Navigation Patterns Demonstrated</h2>\n        \n        <h3 id= >1. Bottom Navigation Pattern</h3>\n        <p>\n          The demo uses bottom navigation for main app sections (Home, Profile, Settings). \n          Each tab is represented as a child of a TabNode in the NavNode tree, maintaining \n          independent navigation stacks within each tab.\n        </p>\n        <CodeBlock code={bottomNavCode} language= >2. Master-Detail Flow</h3>\n        <p>\n          Classic list-to-detail pattern enhanced with shared element transitions. \n          Images and text smoothly animate from the list to the detail screen.\n        </p>\n        <CodeBlock code={masterDetailCode} language= >3. Multi-Step Process</h3>\n        <p>\n          Wizard-style flows are handled elegantly with TreeMutator operations. \n          The demo includes validation, progress tracking, and the ability to jump \n          to specific steps using immutable state transformations.\n        </p>\n        <CodeBlock code={multiStepCode} language= >4. Nested Navigation</h3>\n        <p>\n          The demo shows how to implement tabs within tabs using nested TabNode and \n          StackNode structures in the NavNode tree. Each level of navigation is independent \n          and maintains its own state.\n        </p>\n\n        <h3 id= >5. Transition Showcase</h3>\n        <p>A dedicated screen demonstrates all available transitions:</p>\n        <ul>\n          <li><strong>Slide Horizontal:</strong> Standard left/right slide</li>\n          <li><strong>Slide Vertical:</strong> Bottom-up modal style</li>\n          <li><strong>Fade:</strong> Simple cross-fade</li>\n          <li><strong>Fade Through:</strong> Material Design fade through</li>\n          <li><strong>Scale In:</strong> Zoom-in effect</li>\n          <li><strong>Custom:</strong> User-defined transitions</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Running the Demo</h2>\n        \n        <h3>Prerequisites</h3>\n        <ul>\n          <li>Kotlin 2.2.20+</li>\n          <li>Android Studio or IntelliJ IDEA</li>\n          <li>For iOS: macOS with Xcode installed</li>\n        </ul>\n\n        <h3>Clone and Run</h3>\n        <CodeBlock code={cloneRunCode} language= >Code Examples from Demo</h2>\n        \n        <h3>Main Application Structure</h3>\n        <CodeBlock code={mainAppCode} language=  />\n\n        <h3>Feature Module Example</h3>\n        <CodeBlock code={featureModuleCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Explore More</h2>\n        <ul>\n          <li><a href= >Demo Source Code</a> - Full implementation on GitHub</li>\n          <li><a href= >Getting Started</a> - Build your own navigation</li>\n          <li><a href= >Features</a> - Learn about all capabilities</li>\n          <li><a href="
  },
  {
    "id": "Features/AnnotationAPI/annotationapi",
    "title": "Annotation A P I",
    "route": "/Features/AnnotationAPI/annotationapi",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css )\nsealed class ShopDestination : Destination\n\n// 2. Add destinations with routes\n@Route( )\ndata object ProductList : ShopDestination()\n\n// 3. Add typed destinations with arguments\n@Serializable\ndata class ProductData(val productId: String, val mode: String =  )\n@Argument(ProductData::class)\ndata class ProductDetail(\n    val productId: String,\n    val mode: String =  \n) : ShopDestination(), TypedDestination<ProductData> {\n    override val data = ProductData(productId, mode)\n}\n\n// 4. Define content with @Content annotation\n@Content(ProductList::class)\n@Composable\nfun ProductListContent(navigator: Navigator) {\n    ProductListScreen(\n        onProductClick = { id ->\n            // Type-safe navigation with generated extension\n            navigator.navigateToProductDetail(\n                productId = id,\n                mode =  \n            )\n        }\n    )\n}\n\n@Content(ProductDetail::class)\n@Composable\nfun ProductDetailContent(data: ProductData, navigator: Navigator) {\n    ProductDetailScreen(\n        productId = data.productId,\n        mode = data.mode,\n        onBack = { navigator.navigateBack() }\n    )\n}\n\n// 5. Use generated graph builder\nval shopGraph = buildShopDestinationGraph()\n\n// That >Complete Example</h2>\n        <CodeBlock code={annotationExample} language=  />\n      </section>\n\n      <section>\n        <h2 id= >What Gets Generated</h2>\n        <ul>\n          <li><strong>Route Initializers:</strong> Automatic route registration objects</li>\n          <li><strong>Graph Builders:</strong> <code>build&#123;GraphName&#125;Graph()</code> functions</li>\n          <li><strong>Typed Extensions:</strong> <code>navigateTo&#123;DestinationName&#125;()</code> functions</li>\n          <li><strong>Serialization Code:</strong> Argument encoding/decoding logic</li>\n        </ul>\n\n        <p style={{ marginTop:  >Type-Safe Navigation</a> for the manual approach.\n        </div>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Get started</a> with the quick start guide</li>\n          <li><a href= >Type-Safe Navigation</a> - Learn about the manual DSL approach</li>\n          <li><a href="
  },
  {
    "id": "Features/BackStack/backstack",
    "title": "Back Stack",
    "route": "/Features/BackStack/backstack",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css ))\nnavigator.updateState(newState)\n\n// Pop from the active stack\nval poppedState = TreeMutator.pop(navState)\npoppedState?.let { navigator.updateState(it) }\n\n// Replace current destination\nval replacedState = TreeMutator.replaceCurrent(navState, NewDestination)\nnavigator.updateState(replacedState)\n\n// Clear stack and push new destination\nval clearedState = TreeMutator.clearAndPush(navState, HomeDestination)\nnavigator.updateState(clearedState)\n\n// Switch active tab (for TabNode structures)\nval tabState = TreeMutator.switchActiveTab(navState, newIndex = 1)\nnavigator.updateState(tabState)`\n\nconst navigatorMethodsCode = `// Navigator provides convenient methods that use TreeMutator internally\nnavigator.navigate(DetailsDestination(id =  ))\nnavigator.navigateBack()\nnavigator.navigateAndReplace(NewDestination)\nnavigator.navigateAndClearAll(StartDestination)\n\n// Direct state update for advanced scenarios\nval customState = TreeMutator.clearToRoot(currentState) { it.key ==  >NavNode Tree Structure</h2>\n        <p>\n          The navigation state is represented as an immutable tree of NavNode objects. \n          Different node types support different navigation patterns:\n        </p>\n        <CodeBlock code={navNodeTreeCode} language=  />\n        \n        <h3>Node Types</h3>\n        <ul>\n          <li><strong>ScreenNode:</strong> Represents a single destination/screen</li>\n          <li><strong>StackNode:</strong> A stack of screens for hierarchical navigation</li>\n          <li><strong>TabNode:</strong> Container for tab-based navigation with independent child stacks</li>\n          <li><strong>PaneNode:</strong> For multi-pane layouts (list-detail, etc.)</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >TreeMutator Operations</h2>\n        <p>\n          TreeMutator provides pure functional operations for transforming the NavNode tree. \n          All operations return new immutable trees without modifying the original.\n        </p>\n        <CodeBlock code={treeMutatorCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Navigator Convenience Methods</h2>\n        <p>\n          Navigator provides high-level methods that use TreeMutator internally:\n        </p>\n        <CodeBlock code={navigatorMethodsCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Observing Navigation State</h2>\n        <p>\n          The NavNode tree state is observable via <code>StateFlow&lt;NavNode&gt;</code>:\n        </p>\n        <CodeBlock code={observingStateCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Use Cases</h2>\n        <ul>\n          <li>Multi-step wizards with immutable state transformations</li>\n          <li>Authentication flows that clear navigation stacks</li>\n          <li>Tab-based navigation with independent TabNode children</li>\n          <li>State persistence via NavNode serialization</li>\n          <li>Time-travel debugging by storing NavNode snapshots</li>\n          <li>Testing navigation logic with predictable state assertions</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Benefits of NavNode Tree</h2>\n        <ul>\n          <li><strong>Immutability:</strong> No accidental state mutations, predictable behavior</li>\n          <li><strong>Testability:</strong> Pure functions are easy to unit test</li>\n          <li><strong>Serialization:</strong> Full tree can be serialized for state restoration</li>\n          <li><strong>Observability:</strong> StateFlow provides reactive updates</li>\n          <li><strong>Flexibility:</strong> Support for stacks, tabs, panes, and custom structures</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >See the demo</a> for multi-step process examples</li>\n          <li><a href= >Tabbed Navigation</a> - TabNode patterns</li>\n          <li><a href="
  },
  {
    "id": "Features/DIIntegration/diintegration",
    "title": "D I Integration",
    "route": "/Features/DIIntegration/diintegration",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css ) {\n    destination(HomeDestination) { _, navigator ->\n        val viewModel: HomeViewModel = koinInject()\n        HomeScreen(viewModel, navigator)\n    }\n}`\n\nconst customInjectionCode = `// Create custom destination factory\ninterface DestinationFactory {\n    @Composable\n    fun create(destination: Destination, navigator: Navigator)\n}\n\n// Use in navigation graph\nval graph = navigationGraph( >Koin Example</h2>\n        <CodeBlock code={koinCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Custom Injection</h2>\n        <CodeBlock code={customInjectionCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Modular Architecture</a> - Structure your features</li>\n          <li><a href="
  },
  {
    "id": "Features/DeepLinks/deeplinks",
    "title": "Deep Links",
    "route": "/Features/DeepLinks/deeplinks",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css ) {\n    // Simple path\n    deepLink( ) {\n        HomeDestination\n    }\n    \n    // Path parameters\n    deepLink( ) { args ->\n        UserDestination(userId = args[ ] as String)\n    }\n    \n    // Query parameters\n    deepLink( ) { args ->\n        SearchDestination(query = args[ ] as String)\n    }\n    \n    // Optional parameters\n    deepLink( ) { args ->\n        SettingsDestination(section = args[ >Pattern Matching</h2>\n        <CodeBlock code={deepLinkCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Platform Integration</h2>\n        <ul>\n          <li><strong>Android:</strong> Intent filters and App Links</li>\n          <li><strong>iOS:</strong> Universal Links and custom URL schemes</li>\n          <li><strong>Web:</strong> Direct URL navigation</li>\n          <li><strong>Desktop:</strong> Custom protocol handlers</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Multiplatform Support</a> - Deep links on all platforms</li>\n          <li><a href="
  },
  {
    "id": "Features/features",
    "title": "Features",
    "route": "/Features/features",
    "content": "@components/CodeBlock/CodeBlock ./Features.module.css )\nsealed class ShopDestination : Destination\n\n// 2. Add destinations with routes\n@Route( )\ndata object ProductList : ShopDestination()\n\n// 3. Add typed destinations with arguments\n@Serializable\ndata class ProductData(val productId: String, val mode: String =  )\n@Argument(ProductData::class)\ndata class ProductDetail(\n    val productId: String,\n    val mode: String =  \n) : ShopDestination(), TypedDestination<ProductData> {\n    override val data = ProductData(productId, mode)\n}\n\n// 4. Define content with @Content annotation\n@Content(ProductList::class)\n@Composable\nfun ProductListContent(navigator: Navigator) {\n    ProductListScreen(\n        onProductClick = { id ->\n            // Type-safe navigation with generated extension\n            navigator.navigateToProductDetail(\n                productId = id,\n                mode =  \n            )\n        }\n    )\n}\n\n@Content(ProductDetail::class)\n@Composable\nfun ProductDetailContent(data: ProductData, navigator: Navigator) {\n    ProductDetailScreen(\n        productId = data.productId,\n        mode = data.mode,\n        onBack = { navigator.navigateBack() }\n    )\n}\n\n// 5. Use generated graph builder\nval shopGraph = buildShopDestinationGraph()\n\n// That )\nsealed class FeatureDestination : Destination\n\n@Route( )\ndata object List : FeatureDestination()\n\n@Serializable\ndata class DetailData(val id: String, val mode: ViewMode = ViewMode.READ)\n\n@Route( )\n@Argument(DetailData::class)\ndata class Details(val id: String, val mode: ViewMode = ViewMode.READ) \n    : FeatureDestination(), TypedDestination<DetailData> {\n    override val data = DetailData(id, mode)\n}\n\n// Navigate with generated extension\nnavigator.navigateToDetails(id =  , mode = ViewMode.EDIT)`\n\nconst typeSafeManualCode = `// Define destinations manually\nsealed class FeatureDestination : Destination {\n    object List : FeatureDestination() {\n        override val route =  \n    }\n    \n    data class Details(\n        val id: String,\n        val mode: ViewMode = ViewMode.READ\n    ) : FeatureDestination() {\n        override val route =  \n        override val arguments = mapOf(\n              to mode.name\n        )\n    }\n}\n\n// Navigate with destination instance\nnavigator.navigate(FeatureDestination.Details( , ViewMode.EDIT))`\n\nconst stackManagementCode = `// Access current NavNode tree state\nval navState = navigator.state.value\n\n// Pop from active stack\nnavigator.navigateBack()\n\n// Clear to specific destination using TreeMutator\nval newState = TreeMutator.clearAndPush(navState, HomeDestination)\nnavigator.updateState(newState)\n\n// Navigate and replace current screen\nnavigator.navigateAndReplace(NewDestination)\n\n// Clear everything and start fresh\nnavigator.navigateAndClearAll(StartDestination)\n\n// Switch active tab (for TabNode)\nval tabState = TreeMutator.switchActiveTab(navState, newIndex = 1)\nnavigator.updateState(tabState)`\n\nconst deepLinkCode = `val graph = navigationGraph( ) {\n    // Simple path\n    deepLink( ) {\n        HomeDestination\n    }\n    \n    // Path parameters\n    deepLink( ) { args ->\n        UserDestination(userId = args[ ] as String)\n    }\n    \n    // Query parameters\n    deepLink( ) { args ->\n        SearchDestination(query = args[ ] as String)\n    }\n    \n    // Optional parameters\n    deepLink( ) { args ->\n        SettingsDestination(section = args[ ] as? String)\n    }\n}`\n\nconst predictiveBackCode = `NavigationHost(\n    navigator = navigator,\n    screenRegistry = MainScreenRegistry,\n    predictiveBackMode = PredictiveBackMode.FULL_CASCADE\n)`\n\nconst sharedElementCode = `// Define shared element configuration\nval imageConfig = SharedElementConfig(\n    key =  ,\n    type = SharedElementType.Bounds\n)\n\n// Source screen\nImage(\n    modifier = Modifier.sharedElement(\n        sharedConfig = imageConfig,\n        navigator = navigator\n    )\n)\n\n// Destination screen (same key!)\nImage(\n    modifier = Modifier.sharedElement(\n        sharedConfig = imageConfig,\n        navigator = navigator\n    )\n)`\n\nconst customTransitionCode = `val customTransition = NavigationTransition(\n    enter = slideInVertically { it } + fadeIn(),\n    exit = slideOutVertically { -it / 2 } + fadeOut(),\n    popEnter = slideInVertically { -it / 2 } + fadeIn(),\n    popExit = slideOutVertically { it } + fadeOut()\n)`\n\nconst testingCode = `@Test\nfun \\`navigates to details when item clicked\\`() {\n    // Arrange\n    val navigator = FakeNavigator()\n    val viewModel = ProductListViewModel(navigator)\n    \n    // Act\n    viewModel.onProductClicked( )\n    \n    // Assert\n    assertEquals(\n        ProductDestination.Details( ),\n        navigator.lastDestination\n    )\n}\n\n@Test\nfun \\`clears navigation stack on logout\\`() {\n    // Arrange\n    val navigator = FakeNavigator()\n    val viewModel = SettingsViewModel(navigator)\n    \n    // Act\n    viewModel.onLogout()\n    \n    // Assert\n    assertTrue(navigator.stackCleared)\n    assertEquals(LoginDestination, navigator.lastDestination)\n}`\n\nconst modularCode = `// Feature exposes navigation graph\nobject ProfileFeature {\n    fun navigationGraph(): NavigationGraph = navigationGraph( ) {\n        startDestination(ProfileDestination.List)\n        \n        destination(ProfileDestination.List) { _, nav -> ... }\n        destination(ProfileDestination.Details) { _, nav -> ... }\n    }\n    \n    // Public entry points\n    val entryPoint: Destination = ProfileDestination.List\n}\n\n// Main app integrates feature\nval mainGraph = navigationGraph( ) {\n    includeGraph(ProfileFeature.navigationGraph())\n    \n    // Navigate to feature\n    navigator.navigate(ProfileFeature.entryPoint)\n}`\n\nconst koinCode = `// Define content with DI\n@Content(HomeDestination::class)\n@Composable\nfun HomeContent(navigator: Navigator) {\n    val viewModel: HomeViewModel = koinInject()\n    HomeScreen(viewModel, navigator)\n}\n\n// Use NavigationHost with generated registry\nNavigationHost(\n    navigator = navigator,\n    screenRegistry = AppScreenRegistry\n)`\n\nconst customInjectionCode = `// Create custom destination factory\ninterface DestinationFactory {\n    @Composable\n    fun create(destination: Destination, navigator: Navigator)\n}\n\n// Use in navigation graph\nval graph = navigationGraph( >Getting Started - Alternative Approach</a>.\n        </div>\n      </section>\n\n      <section>\n        <h2 id= >Type-Safe Navigation</h2>\n        <p>\n          Quo Vadis eliminates string-based routing entirely, providing compile-time safety \n          for all navigation operations through two approaches: the annotation-based API (recommended) \n          and the manual DSL (for advanced use cases).\n        </p>\n\n        <h3>Benefits</h3>\n        <ul>\n          <li><strong>Compile-time Safety:</strong> Catch navigation errors at compile time with sealed classes</li>\n          <li><strong>IDE Support:</strong> Full autocompletion and refactoring for both approaches</li>\n          <li><strong>Type-safe Arguments:</strong> Pass complex data types, not just strings</li>\n          <li><strong>Two Approaches:</strong> Use annotations (recommended) or manual DSL (advanced)</li>\n        </ul>\n\n        <h3>Annotation-Based Approach (Recommended)</h3>\n        <CodeBlock code={typeSafeAnnotationCode} language=  />\n\n        <h3>Manual DSL Approach</h3>\n        <CodeBlock code={typeSafeManualCode} language=  />\n\n        <p>\n          Both approaches provide complete type safety and work seamlessly together. \n          The annotation-based approach requires less code and generates helpful extensions,\n          while the manual DSL offers more control for complex scenarios.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Stack Management (NavNode Tree)</h2>\n        <p>\n          Quo Vadis uses an immutable NavNode tree to represent navigation state. \n          All state mutations are performed through TreeMutator operations, providing \n          predictable and testable navigation behavior.\n        </p>\n\n        <h3>Operations</h3>\n        <CodeBlock code={stackManagementCode} language=  />\n\n        <h3>Use Cases</h3>\n        <ul>\n          <li>Multi-step wizards with immutable state transformations</li>\n          <li>Authentication flows that clear navigation stacks</li>\n          <li>Tab-based navigation with independent TabNode children</li>\n          <li>State restoration via NavNode serialization</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Deep Link Support</h2>\n        <p>\n          Comprehensive deep linking system that works across all platforms. Define URL \n          patterns and automatically map them to type-safe destinations.\n        </p>\n\n        <h3>Pattern Matching</h3>\n        <CodeBlock code={deepLinkCode} language=  />\n\n        <h3>Platform Integration</h3>\n        <ul>\n          <li><strong>Android:</strong> Intent filters and App Links</li>\n          <li><strong>iOS:</strong> Universal Links and custom URL schemes</li>\n          <li><strong>Web:</strong> Direct URL navigation</li>\n          <li><strong>Desktop:</strong> Custom protocol handlers</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Predictive Back Navigation</h2>\n        <p>\n          Modern, gesture-driven back navigation with smooth animations. Users can preview \n          the previous screen before committing to navigation. Built into NavigationHost \n          via the <code>predictiveBackMode</code> parameter.\n        </p>\n\n        <h3>Supported Platforms</h3>\n        <ul>\n          <li><strong>Android 13+:</strong> System predictive back API</li>\n          <li><strong>iOS:</strong> Interactive pop gesture</li>\n          <li><strong>Custom Implementations:</strong> Desktop and Web</li>\n        </ul>\n\n        <h3>Features</h3>\n        <ul>\n          <li>Smooth, interruptible animations</li>\n          <li>Cross-fade between screens</li>\n          <li>Scale and position transitions</li>\n          <li>Cancelable gestures</li>\n          <li>Cascade pop support for TabNode structures</li>\n        </ul>\n\n        <CodeBlock code={predictiveBackCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Shared Element Transitions</h2>\n        <p>\n          Material Design 3 shared element transitions with full bidirectional support. \n          Create stunning visual continuity between screens.\n        </p>\n\n        <h3>Key Features</h3>\n        <ul>\n          <li><strong>Bidirectional:</strong> Works for both forward and back navigation</li>\n          <li><strong>Type-Safe:</strong> Compile-time verified shared element keys</li>\n          <li><strong>Flexible:</strong> Bounds, content, or both transitions</li>\n          <li><strong>Platform-Aware:</strong> Native behavior on each platform</li>\n        </ul>\n\n        <h3>Example</h3>\n        <CodeBlock code={sharedElementCode} language=  />\n\n        <h3>Transition Types</h3>\n        <ul>\n          <li><strong>Bounds:</strong> Animate position and size</li>\n          <li><strong>Content:</strong> Cross-fade content</li>\n          <li><strong>Both:</strong> Animate bounds and content together</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >MVI Architecture Support</h2>\n        <p>\n          First-class integration with MVI (Model-View-Intent) architecture pattern through \n          the <strong>quo-vadis-core-flow-mvi</strong> module. Navigation is treated as a \n          side effect of business logic, keeping your UI clean and testable.\n        </p>\n\n        <h3>Key Benefits</h3>\n        <ul>\n          <li><strong>Testable:</strong> Test navigation logic without UI using FakeNavigator</li>\n          <li><strong>Predictable:</strong> Navigation as pure side effect of state changes</li>\n          <li><strong>Centralized:</strong> All navigation logic in one place (Container)</li>\n          <li><strong>Decoupled:</strong> UI doesn >FlowMVI Integration Guide</a> for complete documentation.\n        </div>\n      </section>\n\n      <section>\n        <h2 id=  />\n      </section>\n\n      <section>\n        <h2 id= >Testing Support</h2>\n        <p>\n          Built-in testing utilities make it easy to verify navigation behavior without \n          UI testing. Test navigation logic in fast, reliable unit tests.\n        </p>\n\n        <h3>FakeNavigator</h3>\n        <CodeBlock code={testingCode} language=  />\n\n        <h3>Verification Methods</h3>\n        <ul>\n          <li><code>verifyNavigate(destination)</code> - Verify navigation to destination</li>\n          <li><code>verifyNavigateBack()</code> - Verify back navigation</li>\n          <li><code>clearCalls()</code> - Reset navigation call history</li>\n          <li><code>navigationCalls</code> - Access full navigation history</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Modular Architecture</h2>\n        <p>\n          Gray box pattern support enables true modular architecture. Features can \n          define their own navigation graphs and expose public entry points.\n        </p>\n\n        <h3>Feature Module Example</h3>\n        <CodeBlock code={modularCode} language=  />\n\n        <h3>Benefits</h3>\n        <ul>\n          <li>Independent feature development</li>\n          <li>Clear module boundaries</li>\n          <li>Reusable feature modules</li>\n          <li>Easier testing and maintenance</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >DI Framework Integration</h2>\n        <p>\n          Easy integration with popular DI frameworks like Koin, Kodein, and others. \n          Inject dependencies into destination composables seamlessly.\n        </p>\n\n        <h3>Koin Example</h3>\n        <CodeBlock code={koinCode} language=  />\n\n        <h3>Custom Injection</h3>\n        <CodeBlock code={customInjectionCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Performance</h2>\n        <p>\n          Optimized for performance with minimal overhead. Lazy initialization, \n          efficient state management, and smart recomposition.\n        </p>\n\n        <h3>Optimizations</h3>\n        <ul>\n          <li><strong>Lazy Loading:</strong> Destinations created only when needed</li>\n          <li><strong>Efficient State:</strong> StateFlow with structural sharing</li>\n          <li><strong>Smart Recomposition:</strong> Minimal recomposition on navigation</li>\n          <li><strong>No Reflection:</strong> Zero runtime reflection overhead</li>\n          <li><strong>Small Footprint:</strong> No external dependencies</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >No External Dependencies</h2>\n        <p>\n          Quo Vadis is completely self-contained with zero external navigation dependencies. \n          This means:\n        </p>\n        <ul>\n          <li>Smaller app size</li>\n          <li>No version conflicts</li>\n          <li>No dependency chain issues</li>\n          <li>Full control over updates</li>\n          <li>Better long-term stability</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Get started</a> with the quick start guide</li>\n          <li><a href= >See the demo</a> to explore features in action</li>\n          <li><a href= >Browse API docs</a> for detailed reference</li>\n          <li><a href="
  },
  {
    "id": "Features/FlowMVI/flowmvi",
    "title": "Flow M V I",
    "route": "/Features/FlowMVI/flowmvi",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css \n            parallelIntents = false\n        }\n        \n        init {\n            intent(ProfileIntent.LoadProfile)\n        }\n        \n        reduce { intent ->\n            when (intent) {\n                is ProfileIntent.LoadProfile -> {\n                    updateState { ProfileState.Loading }\n                    val user = repository.getUser()\n                    updateState { ProfileState.Content(user) }\n                }\n                \n                is ProfileIntent.NavigateToSettings -> {\n                    // Navigation as a side-effect\n                    navigator.navigate(SettingsDestination)\n                }\n                \n                is ProfileIntent.SaveChanges -> {\n                    val current = state as ProfileState.Content\n                    repository.saveUser(current.user)\n                    action(ProfileAction.ProfileSaved)\n                    action(ProfileAction.ShowToast( ))\n                }\n                \n                is ProfileIntent.NavigateBack -> {\n                    navigator.navigateBack()\n                }\n            }\n        }\n        \n        recover { exception ->\n            action(ProfileAction.ShowToast( ))\n            null\n        }\n    }\n}`\n\nconst uiCode = `@Composable\nfun ProfileScreen(\n    navigator: Navigator = koinInject(),\n    container: ProfileContainer = koinInject { parametersOf(navigator) }\n) {\n    val snackbarHostState = remember { SnackbarHostState() }\n    \n    StoreScreen(\n        container = container,\n        onAction = { action ->\n            when (action) {\n                is ProfileAction.ShowToast -> {\n                    launch { snackbarHostState.showSnackbar(action.message) }\n                }\n                ProfileAction.ProfileSaved -> {\n                    // Handle success\n                }\n            }\n        }\n    ) { state, intentReceiver ->\n        Scaffold(snackbarHost = { SnackbarHost(snackbarHostState) }) {\n            when (state) {\n                ProfileState.Loading -> CircularProgressIndicator()\n                is ProfileState.Content -> ProfileContent(\n                    user = state.user,\n                    isEditing = state.isEditing,\n                    onIntent = intentReceiver::intent\n                )\n                is ProfileState.Error -> ErrorView(state.message)\n            }\n        }\n    }\n}\n\n@Composable\nprivate fun ProfileContent(\n    user: User,\n    isEditing: Boolean,\n    onIntent: (ProfileIntent) -> Unit\n) {\n    Column {\n        Text( Email: \\${user.email} )\n        }\n        \n        if (isEditing) {\n            Button(onClick = { onIntent(ProfileIntent.SaveChanges) }) {\n                Text( >FlowMVI</a> state management.\n        Treat navigation as a <strong>side-effect of your business logic</strong>, keeping your UI clean and testable.\n      </p>\n\n      <section>\n        <h2 id= >Overview</h2>\n        <p>\n          FlowMVI is a Kotlin Multiplatform MVI (Model-View-Intent) framework built on Kotlin Flow.\n          Quo Vadis integrates seamlessly with FlowMVI to provide a clean architecture where\n          navigation decisions are made in your business logic layer, not in your UI.\n        </p>\n        <h3>Why This Matters</h3>\n        <p>\n          Traditional approach mixes navigation with UI code, making it hard to test and maintain.\n          With FlowMVI integration, your UI components simply dispatch intents and render state —\n          they don t know about destination types</li>\n          <li><strong>Scalable</strong> - Easy to maintain as app grows in complexity</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Installation</h2>\n        <CodeBlock code={`// build.gradle.kts\nkotlin {\n    sourceSets {\n        commonMain {\n            dependencies {\n                implementation( )\n                implementation( )\n                \n                implementation( )\n                implementation( )\n                \n                // For testing\n                testImplementation( )\n            }\n        }\n    }\n}`} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Core Concepts</h2>\n        <p>\n          FlowMVI uses three main components: <strong>State</strong> (what UI displays),\n          <strong>Intent</strong> (what user wants to do), and <strong>Action</strong> (side effects like navigation or toasts).\n        </p>\n        <CodeBlock code={contractCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Creating a Container</h2>\n        <p>\n          The Container is where you inject the <code>Navigator</code> and handle navigation as part\n          of your business logic. When an intent comes in, you can call <code>navigator.navigate()</code>\n          directly in the reduce block.\n        </p>\n        <CodeBlock code={containerCode} language=  />\n        <h3>Key Points</h3>\n        <ul>\n          <li>Navigator is injected via constructor (makes testing easy)</li>\n          <li>Navigation happens in <code>reduce</code> block alongside state updates</li>\n          <li>Use <code>action()</code> for side effects like toasts</li>\n          <li>Use <code>recover</code> plugin for graceful error handling</li>\n          <li>State updates use <code>updateState</code> DSL</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Usage in UI</h2>\n        <p>\n          The <code>quo-vadis-core-flow-mvi</code> module provides the <code>StoreScreen</code> composable\n          that handles state subscription and action dispatching automatically.\n        </p>\n        <CodeBlock code={uiCode} language=  />\n        <h3>StoreScreen Benefits</h3>\n        <ul>\n          <li>Automatic state subscription and lifecycle management</li>\n          <li>Type-safe state and intent handling</li>\n          <li>Centralized action handling (toasts, analytics, etc.)</li>\n          <li>Clean separation of UI and business logic</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Dependency Injection</h2>\n        <p>\n          Use Koin (or your preferred DI framework) to inject the Navigator into your Container.\n          This makes testing easy and keeps your code decoupled.\n        </p>\n        <CodeBlock code={diCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Testing Navigation Logic</h2>\n        <p>\n          One of the biggest advantages of this architecture is testability. You can test navigation\n          logic without any UI code using <code>FakeNavigator</code> and FlowMVI  />\n        <h3>Testing Benefits</h3>\n        <ul>\n          <li>No UI required - tests run in milliseconds</li>\n          <li>Test navigation logic in isolation</li>\n          <li>Verify state changes and side effects</li>\n          <li>Easy to mock dependencies</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Common Patterns</h2>\n        <h3>Navigation with Arguments</h3>\n        <CodeBlock code={`sealed interface ProductIntent : MVIIntent {\n    data class NavigateToDetails(val productId: String) : ProductIntent\n}\n\nreduce { intent ->\n    when (intent) {\n        is ProductIntent.NavigateToDetails -> {\n            navigator.navigate(\n                ProductDetailsDestination(intent.productId)\n            )\n        }\n    }\n}`} language=  />\n\n        <h3>Conditional Navigation</h3>\n        <CodeBlock code={`reduce { intent ->\n    when (intent) {\n        ProfileIntent.SaveAndExit -> {\n            try {\n                repository.save(state.user)\n                action(ProfileAction.ShowToast( ))\n                // Only navigate on success\n                navigator.navigateBack()\n            } catch (e: ValidationException) {\n                action(ProfileAction.ShowError(e.message))\n                // Stay on screen if validation fails\n            }\n        }\n    }\n}`} language=  />\n\n        <h3>Navigation with Multiple Destinations</h3>\n        <CodeBlock code={`reduce { intent ->\n    when (intent) {\n        ProfileIntent.Logout -> {\n            repository.clearSession()\n            // Navigate to different destinations based on state\n            if (hasCompletedOnboarding) {\n                navigator.navigate(LoginDestination)\n            } else {\n                navigator.navigate(OnboardingDestination)\n            }\n        }\n    }\n}`} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Best Practices</h2>\n        <h3>✅ DO:</h3>\n        <ul>\n          <li>Keep all navigation logic in Container, not UI</li>\n          <li>Use meaningful intent names (e.g., <code>OpenSettings</code> not <code>Navigate</code>)</li>\n          <li>Handle errors gracefully with <code>recover</code> plugin</li>\n          <li>Test navigation logic with <code>FakeNavigator</code></li>\n          <li>Inject Navigator via constructor for testability</li>\n          <li>Use actions for all side effects (toasts, analytics, etc.)</li>\n        </ul>\n        <h3>❌ DON t navigate directly from UI - always use intents</li>\n          <li>Don t ignore actions - handle all side effects in UI</li>\n          <li>Don t mix business logic with UI code</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >FlowMVI Documentation</a> - Learn more about FlowMVI</li>\n          <li><a href= >API Reference</a> - Complete API documentation</li>\n          <li><a href= >Testing Support</a> - Test your MVI navigation</li>\n          <li><a href="
  },
  {
    "id": "Features/Modular/modular",
    "title": "Modular",
    "route": "/Features/Modular/modular",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css ) {\n        startDestination(ProfileDestination.List)\n        \n        destination(ProfileDestination.List) { _, nav -> ... }\n        destination(ProfileDestination.Details) { _, nav -> ... }\n    }\n    \n    // Public entry points\n    val entryPoint: Destination = ProfileDestination.List\n}\n\n// Main app integrates feature\nval mainGraph = navigationGraph( >Feature Module Example</h2>\n        <CodeBlock code={modularCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >DI Integration</a> - Inject dependencies</li>\n          <li><a href="
  },
  {
    "id": "Features/Multiplatform/multiplatform",
    "title": "Multiplatform",
    "route": "/Features/Multiplatform/multiplatform",
    "content": "../Features.module.css >Next Steps</h2>\n        <ul>\n          <li><a href= >Predictive Back</a> - Platform-specific back navigation</li>\n          <li><a href= >Deep Links</a> - URL patterns and deep linking</li>\n          <li><a href="
  },
  {
    "id": "Features/Performance/performance",
    "title": "Performance",
    "route": "/Features/Performance/performance",
    "content": "../Features.module.css >Optimizations</h2>\n        <ul>\n          <li><strong>Lazy Loading:</strong> Destinations created only when needed</li>\n          <li><strong>Efficient State:</strong> StateFlow with structural sharing</li>\n          <li><strong>Smart Recomposition:</strong> Minimal recomposition on navigation</li>\n          <li><strong>No Reflection:</strong> Zero runtime reflection overhead</li>\n          <li><strong>Small Footprint:</strong> No external dependencies</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >No External Dependencies</h2>\n        <p>\n          Quo Vadis is completely self-contained with zero external navigation dependencies. \n          This means:\n        </p>\n        <ul>\n          <li>Smaller app size</li>\n          <li>No version conflicts</li>\n          <li>No dependency chain issues</li>\n          <li>Full control over updates</li>\n          <li>Better long-term stability</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Get started</a> with Quo Vadis</li>\n          <li><a href="
  },
  {
    "id": "Features/PredictiveBack/predictiveback",
    "title": "Predictive Back",
    "route": "/Features/PredictiveBack/predictiveback",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css >Supported Platforms</h2>\n        <ul>\n          <li><strong>Android 13+:</strong> System predictive back API integration</li>\n          <li><strong>iOS:</strong> Interactive pop gesture with preview</li>\n          <li><strong>Desktop:</strong> Custom gesture implementations</li>\n          <li><strong>Web:</strong> Browser back button support</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Features</h2>\n        <ul>\n          <li>Smooth, interruptible animations</li>\n          <li>Cross-fade between screens during gesture</li>\n          <li>Scale and position transitions</li>\n          <li>Cancelable gestures - release to cancel</li>\n          <li>Cascade pop support for TabNode structures</li>\n          <li>Works with NavNode tree state</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Setup</h2>\n        <p>\n          Predictive back is enabled through the <code>predictiveBackMode</code> parameter \n          in NavigationHost:\n        </p>\n        <CodeBlock code={predictiveBackCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Predictive Back Modes</h2>\n        <p>\n          Choose the appropriate mode based on your navigation structure:\n        </p>\n        <CodeBlock code={predictiveBackModesCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Cascade Back for Tabs</h2>\n        <p>\n          When using TabNode structures, cascade back provides intelligent handling \n          of back gestures that span tab boundaries:\n        </p>\n        <CodeBlock code={cascadeBackCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Transitions & Animations</a> - All transition types</li>\n          <li><a href= >Stack Management</a> - NavNode tree operations</li>\n          <li><a href="
  },
  {
    "id": "Features/SharedElements/sharedelements",
    "title": "Shared Elements",
    "route": "/Features/SharedElements/sharedelements",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css product_image_\\${product.id} >Example</h2>\n        <CodeBlock code={sharedElementCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Transition Types</h2>\n        <ul>\n          <li><strong>Bounds:</strong> Animate position and size</li>\n          <li><strong>Content:</strong> Cross-fade content</li>\n          <li><strong>Both:</strong> Animate bounds and content together</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Transitions & Animations</a> - All animation options</li>\n          <li><a href="
  },
  {
    "id": "Features/TabbedNavigation/tabbednavigation",
    "title": "Tabbed Navigation",
    "route": "/Features/TabbedNavigation/tabbednavigation",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css \n)\nsealed class MainTabs : TabDefinition {\n\n    @Tab(\n        route =  ,\n        rootGraph = TabDestination::class,\n        rootDestination = TabDestination.Home::class\n    )\n    data object Home : MainTabs() {\n        override val route =  \n        override val rootDestination = TabDestination.Home\n    }\n\n    @Tab(\n        route =  ,\n        rootGraph = TabDestination::class,\n        rootDestination = TabDestination.Profile::class\n    )\n    data object Profile : MainTabs() {\n        override val route =  \n        override val rootDestination = TabDestination.Profile\n    }\n\n    @Tab(\n        route =  ,\n        rootGraph = TabDestination::class,\n        rootDestination = TabDestination.Settings::class\n    )\n    data object Settings : MainTabs() {\n        override val route =  \n        override val rootDestination = TabDestination.Settings\n    }\n}`\n\nconst usageCode = `@Composable\nfun MainTabsScreen(parentNavigator: Navigator) {\n    val tabState = rememberTabNavigator(MainTabsConfig, parentNavigator)\n    val selectedTab by tabState.selectedTab.collectAsState()\n    val tabGraph = remember { buildAppDestinationGraph() }\n\n    TabbedNavHost(\n        tabState = tabState,\n        tabGraphs = MainTabsConfig.allTabs.associateWith { tabGraph },\n        navigator = parentNavigator,\n        tabUI = { content ->\n            Scaffold(\n                bottomBar = {\n                    BottomNavigationBar(\n                        currentTab = selectedTab,\n                        onTabSelected = { tab -> tabState.selectTab(tab) }\n                    )\n                }\n            ) { padding ->\n                Box(modifier = Modifier.padding(padding)) {\n                    content()\n                }\n            }\n        }\n    )\n}`\n\nconst bottomNavCode = `@Composable\nfun BottomNavigationBar(\n    currentTab: TabDefinition?,\n    onTabSelected: (TabDefinition) -> Unit\n) {\n    NavigationBar {\n        MainTabsConfig.allTabs.forEach { tab ->\n            NavigationBarItem(\n                icon = { Icon(getIconForTab(tab), contentDescription = tab.label) },\n                label = { Text(tab.label ?:  ) },\n                selected = currentTab == tab,\n                onClick = { onTabSelected(tab) }\n            )\n        }\n    }\n}`\n\nconst navigationInTabCode = `@Composable\nfun HomeScreen(navigator: Navigator) {\n    Column {\n        Button(onClick = {\n            // Navigate within current tab\n            navigator.navigate(AppDestination.Details( ))\n        }) {\n            Text( )\n        }\n        \n        Button(onClick = {\n            // This opens another screen in the same tab\n            navigator.navigate(AppDestination.Search)\n        }) {\n            Text( >Overview</h2>\n        <p>\n          Quo Vadis provides an annotation-driven system for tabbed navigation that eliminates boilerplate\n          while ensuring type safety. KSP (Kotlin Symbol Processing) generates all the necessary\n          configuration code at compile time.\n        </p>\n        <h3>Key Features</h3>\n        <ul>\n          <li><strong>Zero Boilerplate</strong> - KSP generates configuration code automatically</li>\n          <li><strong>Type-Safe</strong> - Compile-time checked tab definitions</li>\n          <li><strong>Independent Stacks</strong> - Each tab has its own navigation history</li>\n          <li><strong>State Preservation</strong> - Tab content survives tab switches</li>\n          <li><strong>Smart Back Press</strong> - Hierarchical navigation across tabs</li>\n          <li><strong>Flexible UI</strong> - Works with BottomNavigationBar, NavigationRail, or custom UI</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Setup</h2>\n        <p>\n          Define your tab structure using <code>@TabGraph</code> and <code>@Tab</code> annotations.\n          KSP will generate a <code>MainTabsConfig</code> object containing all tab configuration.\n        </p>\n        <CodeBlock code={setupCode} language=  />\n        <h3>Annotation Parameters</h3>\n        <ul>\n          <li><code>name</code> - Base name for generated code (e.g.,   → MainTabsConfig)</li>\n          <li><code>initialTab</code> - Tab to display on first launch</li>\n          <li><code>primaryTab</code> - Primary tab for smart back navigation (defaults to initialTab)</li>\n          <li><code>route</code> - Unique identifier for each tab</li>\n          <li><code>label</code> - Display name for UI</li>\n          <li><code>icon</code> - Icon identifier (Material Icons name or custom)</li>\n          <li><code>rootDestination</code> - Initial destination when tab is selected</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Usage in UI</h2>\n        <p>\n          Use the <code>TabbedNavHost</code> composable to render your tabs with custom UI.\n          This gives you full control over the tab interface (bottom bar, navigation rail, etc.).\n        </p>\n        <CodeBlock code={usageCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Bottom Navigation Bar</h2>\n        <p>\n          Create a custom bottom navigation bar that integrates with the tab state:\n        </p>\n        <CodeBlock code={bottomNavCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Navigation Within Tabs</h2>\n        <p>\n          Each tab has its own <code>Navigator</code> instance. Navigate within a tab just like regular navigation:\n        </p>\n        <CodeBlock code={navigationInTabCode} language=  />\n        <p>\n          The navigation stays within the current tab, building up that tab ll see the exact same state.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Smart Back Press Behavior</h2>\n        <p>Quo Vadis implements intelligent hierarchical navigation:</p>\n        <ol>\n          <li><strong>Not at root:</strong> Pop from current tab >Best Practices</h2>\n        <h3>✅ DO:</h3>\n        <ul>\n          <li>Keep tabs at top level for main app sections</li>\n          <li>Use 3-5 tabs maximum for mobile</li>\n          <li>Set a logical primary tab for back navigation</li>\n          <li>Use clear, recognizable icons</li>\n          <li>Test tab switching and back behavior</li>\n        </ul>\n        <h3>❌ DON t use tabs for linear flows (use regular navigation)</li>\n          <li>Don t change tab structure dynamically</li>\n          <li>Don >Next Steps</h2>\n        <ul>\n          <li><a href= >API Reference</a> - Complete API documentation</li>\n          <li><a href= >Annotation API</a> - Learn more about code generation</li>\n          <li><a href="
  },
  {
    "id": "Features/Testing/testing",
    "title": "Testing",
    "route": "/Features/Testing/testing",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css )\n    \n    // Assert\n    assertEquals(\n        ProductDestination.Details( >FakeNavigator</h2>\n        <CodeBlock code={testingCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Verification Methods</h2>\n        <ul>\n          <li><code>verifyNavigate(destination)</code> - Verify navigation to destination</li>\n          <li><code>verifyNavigateBack()</code> - Verify back navigation</li>\n          <li><code>clearCalls()</code> - Reset navigation call history</li>\n          <li><code>navigationCalls</code> - Access full navigation history</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Testing guide</a> in Getting Started</li>\n          <li><a href="
  },
  {
    "id": "Features/Transitions/transitions",
    "title": "Transitions",
    "route": "/Features/Transitions/transitions",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css >Custom Transitions</h2>\n        <CodeBlock code={customTransitionCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Shared Elements</a> - Advanced animations</li>\n          <li><a href= >Predictive Back</a> - Gesture-driven navigation</li>\n          <li><a href="
  },
  {
    "id": "Features/TypeSafe/typesafe",
    "title": "Type Safe",
    "route": "/Features/TypeSafe/typesafe",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css )\nsealed class FeatureDestination : Destination\n\n@Route( )\ndata object List : FeatureDestination()\n\n@Serializable\ndata class DetailData(val id: String, val mode: ViewMode = ViewMode.READ)\n\n@Route( )\n@Argument(DetailData::class)\ndata class Details(val id: String, val mode: ViewMode = ViewMode.READ) \n    : FeatureDestination(), TypedDestination<DetailData> {\n    override val data = DetailData(id, mode)\n}\n\n// Navigate with generated extension\nnavigator.navigateToDetails(id =  , mode = ViewMode.EDIT)`\n\nconst typeSafeManualCode = `// Define destinations manually\nsealed class FeatureDestination : Destination {\n    object List : FeatureDestination() {\n        override val route =  \n    }\n    \n    data class Details(\n        val id: String,\n        val mode: ViewMode = ViewMode.READ\n    ) : FeatureDestination() {\n        override val route =  \n        override val arguments = mapOf(\n              to mode.name\n        )\n    }\n}\n\n// Navigate with destination instance\nnavigator.navigate(FeatureDestination.Details( >Annotation-Based Approach (Recommended)</h2>\n        <CodeBlock code={typeSafeAnnotationCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Manual DSL Approach</h2>\n        <CodeBlock code={typeSafeManualCode} language=  />\n\n        <p>\n          Both approaches provide complete type safety and work seamlessly together. \n          The annotation-based approach requires less code and generates helpful extensions,\n          while the manual DSL offers more control for complex scenarios.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Annotation-Based API</a> - Learn about code generation</li>\n          <li><a href= >Multiplatform Support</a> - Works on all platforms</li>\n          <li><a href="
  },
  {
    "id": "GettingStarted/gettingstarted",
    "title": "Getting Started",
    "route": "/GettingStarted/gettingstarted",
    "content": "@components/CodeBlock/CodeBlock ./GettingStarted.module.css com.google.devtools.ksp \n}\n\nrepositories {\n    mavenCentral()\n    google()\n}\n\nkotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                // Core navigation library\n                implementation( )\n                \n                // Annotation-based API (recommended)\n                implementation( )\n                \n                // For type-safe arguments\n                implementation( )\n            }\n        }\n    }\n}\n\ndependencies {\n    // KSP code generator\n    add( io.github.jermeyyy:quo-vadis-ksp:0.1.1 \nkotlinxSerialization =  \n\n[libraries]\nquo-vadis-core = { module =   }\nquo-vadis-annotations = { module =   }\nquo-vadis-ksp = { module =   }\nkotlinx-serialization-json = { module =  com.google.devtools.ksp  }\nkotlinSerialization = { id =   }\n\n# In build.gradle.kts\nplugins {\n    alias(libs.plugins.ksp)\n    alias(libs.plugins.kotlinSerialization)\n}\n\nrepositories {\n    mavenCentral()\n    google()\n}\n\ndependencies {\n    implementation(libs.quo.vadis.core)\n    implementation(libs.quo.vadis.annotations)\n    implementation(libs.kotlinx.serialization.json)\n    add( )\nsealed class AppDestination : Destination {\n    @Route( )\n    data object Home : AppDestination()\n    \n    @Route( )\n    @Argument(ProfileData::class)\n    data class UserProfile(val userId: String, val tab: String =  ) \n        : AppDestination(), TypedDestination<ProfileData> {\n        override val data = ProfileData(userId, tab)\n    }\n    \n    @Route( \n    }\n    \n    data class UserProfile(val userId: String) : AppDestination() {\n        override val route =  \n        override val arguments = mapOf(  to userId)\n    }\n}\n\n// Create a ScreenRegistry manually\nval appScreenRegistry = ScreenRegistry {\n    screen(AppDestination.Home) { _, navigator ->\n        HomeScreen(\n            onNavigateToProfile = { userId ->\n                navigator.navigate(AppDestination.UserProfile(userId))\n            }\n        )\n    }\n    \n    screen<AppDestination.UserProfile> { dest, navigator ->\n        ProfileScreen(\n            userId = dest.userId,\n            onBack = { navigator.navigateBack() }\n        )\n    }\n}\n\n// Use with NavigationHost\nNavigationHost(\n    navigator = navigator,\n    screenRegistry = appScreenRegistry\n)`\n\nconst basicNavCode = `// Navigate to a destination\nnavigator.navigate(AppDestination.UserProfile( ))\n\n// Navigate with custom transition\nnavigator.navigate(\n    destination = AppDestination.Settings(),\n    transition = NavigationTransitions.FadeThrough\n)\n\n// Navigate back\nnavigator.navigateBack()\n\n// Navigate up (parent destination)\nnavigator.navigateUp()`\n\nconst advancedNavCode = `// Navigate and replace current screen\nnavigator.navigateAndReplace(AppDestination.Home)\n\n// Navigate and clear entire navigation stack\nnavigator.navigateAndClearAll(AppDestination.Home)\n\n// Navigate and clear to specific destination\nnavigator.navigateAndClearTo(\n    destination = AppDestination.Home,\n    clearRoute =  ,\n    inclusive = true\n)`\n\nconst transitionsCode = `// Available transitions\nNavigationTransitions.SlideHorizontal\nNavigationTransitions.SlideVertical\nNavigationTransitions.Fade\nNavigationTransitions.FadeThrough\nNavigationTransitions.ScaleIn\nNavigationTransitions.None\n\n// Use with navigation\nnavigator.navigate(\n    destination = AppDestination.Details( ),\n    transition = NavigationTransitions.SlideVertical\n)`\n\nconst customTransitionCode = `val customTransition = NavigationTransition(\n    enter = slideInHorizontally(\n        initialOffsetX = { it },\n        animationSpec = tween(300)\n    ) + fadeIn(),\n    exit = slideOutHorizontally(\n        targetOffsetX = { -it / 3 },\n        animationSpec = tween(300)\n    ) + fadeOut()\n)`\n\nconst sharedElementCode = `// Define shared element configuration\nval sharedConfig = SharedElementConfig(\n    key =  ,\n    type = SharedElementType.Bounds\n)\n\n// Source screen\nImage(\n    painter = painterResource(item.image),\n    contentDescription = null,\n    modifier = Modifier\n        .sharedElement(\n            sharedConfig = sharedConfig,\n            navigator = navigator\n        )\n)\n\n// Destination screen - same key!\nImage(\n    painter = painterResource(item.image),\n    contentDescription = null,\n    modifier = Modifier\n        .sharedElement(\n            sharedConfig = sharedConfig,\n            navigator = navigator\n        )\n)`\n\nconst deepLinksCode = `// Register deep link patterns\nval graph = navigationGraph( myapp://profile/{userId} ] as String)\n    }\n    \n    deepLink( ) { args ->\n        AppDestination.Settings(args[ ] as String)\n    }\n}\n\n// Handle deep link\nnavigator.handleDeepLink(\n    DeepLink( )\n)`\n\nconst testingCode = `@Test\nfun \\`test navigation to profile\\`() {\n    val fakeNavigator = FakeNavigator()\n    val viewModel = MyViewModel(fakeNavigator)\n    \n    viewModel.onUserClicked( )\n    \n    assertEquals(\n        AppDestination.UserProfile( >Installation</h2>\n\n        <p>Add the Quo Vadis library to your Kotlin Multiplatform project.</p>\n\n        <h3 id= >Gradle (Kotlin DSL) - Recommended</h3>\n        <CodeBlock code={installationCode} language= >Version Catalog</h3>\n        <CodeBlock code={versionCatalogCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Basic Setup (Annotation-based API)</h2>\n        <p>The <strong>annotation-based API</strong> is the recommended approach. It uses KSP to generate navigation code automatically, reducing boilerplate by 70%.</p>\n        \n        <h3 id= >Step 1: Define Destinations with Annotations</h3>\n        <p>Create type-safe destinations using sealed classes with annotations:</p>\n        <CodeBlock code={destinationsCode} language= >Step 2: Define Content Functions</h3>\n        <p>Use <code>@Content</code> to wire Composables to destinations:</p>\n        <CodeBlock code={contentCode} language= >Step 3: Use Generated ScreenRegistry</h3>\n        <p>KSP automatically generates a ScreenRegistry for NavigationHost:</p>\n        <CodeBlock code={graphCode} language= >Step 4: Setup NavigationHost</h3>\n        <p>Use NavigationHost for hierarchical NavNode tree rendering:</p>\n        <CodeBlock code={navHostCode} language= >Alternative: Manual ScreenRegistry Approach</h2>\n        <p>For dynamic navigation or fine-grained control, create a ScreenRegistry manually:</p>\n        <CodeBlock code={manualDSLCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Navigation Operations</h2>\n        \n        <h3 id= >Basic Navigation</h3>\n        <CodeBlock code={basicNavCode} language= >Advanced Navigation</h3>\n        <CodeBlock code={advancedNavCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Transitions</h2>\n        <p>Quo Vadis includes several built-in transitions:</p>\n        <CodeBlock code={transitionsCode} language= >Custom Transitions</h3>\n        <CodeBlock code={customTransitionCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Shared Element Transitions</h2>\n        <p>Create stunning shared element animations:</p>\n        <CodeBlock code={sharedElementCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Deep Links</h2>\n        <p>Handle deep links across all platforms:</p>\n        <CodeBlock code={deepLinksCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Testing</h2>\n        <p>Use FakeNavigator for easy unit testing:</p>\n        <CodeBlock code={testingCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Platform-Specific Setup</h2>\n        \n        <h3 id= >Android</h3>\n        <CodeBlock code={androidCode} language= >Next Steps</h2>\n        <ul>\n          <li><a href= >Explore all features</a> - Deep dive into advanced capabilities</li>\n          <li><a href= >Check out the demo</a> - See real-world examples</li>\n          <li><a href= >Browse API reference</a> - Complete API documentation</li>\n          <li><a href="
  },
  {
    "id": "Home",
    "title": "Home",
    "route": "/Home",
    "content": "@components/CodeBlock/CodeBlock \n\nconst quickstartCode = `[versions]\nquoVadis =  \n\n[libraries]\nquo-vadis-core = { module =   }\nquo-vadis-annotations = { module =   }\n\n[plugins]\nksp = { id =   }`\n\nconst step1Code = `// Define your graph\n@Graph( )\nsealed class AppDestination : Destination\n\n// Add destinations with routes\n@Route( )\ndata object Home : AppDestination()\n\n@Serializable\ndata class DetailData(val id: String)\n\n@Route( )\n@Argument(DetailData::class)\ndata class Details(val id: String) : AppDestination(), \n    TypedDestination<DetailData> {\n    override val data = DetailData(id)\n}`\n\nconst step2Code = `@Content(Home::class)\n@Composable\nfun HomeContent(navigator: Navigator) {\n    HomeScreen(\n        onNavigateToDetails = { id ->\n            // Use generated extension\n            navigator.navigateToDetails(id = id)\n        }\n    )\n}\n\n@Content(Details::class)\n@Composable\nfun DetailsContent(data: DetailData, navigator: Navigator) {\n    DetailsScreen(\n        itemId = data.id,\n        onBack = { navigator.navigateBack() }\n    )\n}`\n\nconst step3Code = `@Composable\nfun App() {\n    val navigator = rememberNavigator(startDestination = AppDestination.Home)\n    \n    NavigationHost(\n        navigator = navigator,\n        screenRegistry = AppDestinationScreenRegistry,\n        defaultTransition = NavigationTransitions.SlideHorizontal\n    )\n}`\n\nconst manualDSLCode = `// Define destinations manually\nsealed class AppDestination : Destination {\n    object Home : AppDestination() {\n        override val route =  \n    }\n    \n    data class Details(val id: String) : AppDestination() {\n        override val route =  \n        override val arguments = mapOf(  to id)\n    }\n}\n\n// Build graph manually\nval appGraph = navigationGraph( >\n            <img src=  />\n          </a>\n          <a href= >\n            <img src=  />\n          </a>\n          <img src=  />\n          <img src=  />\n          <img src=  />\n          <img src=  />\n          <img src=  />\n          <img src= >View on GitHub</a>\n        </div>\n      </section>\n\n      {/* Overview */}\n      <section>\n        <h2 id= >Overview</h2>\n        <p>\n          <strong>Quo Vadis</strong> (Latin for  ) is a comprehensive, type-safe navigation \n          library for Kotlin Multiplatform and Compose Multiplatform. It provides a clean, intuitive API for \n          managing navigation across Android, iOS, Desktop, and Web platforms with zero string-based routing.\n        </p>\n      </section>\n\n            {/* Why Quo Vadis */}\n      <section>\n        <h2 id= >Show Me The Code!</h2>\n        <p style={{ marginBottom:  >Or Use Manual DSL for Full Control</h2>\n        <p style={{ marginBottom:   }}>\n          Prefer full control? The manual DSL API is still available for advanced use cases:\n        </p>\n        <CodeBlock code={manualDSLCode} language=  />\n      </section>\n\n      {/* Resources */}\n      <section>\n        <h2 id= >Resources</h2>\n        <ul>\n          <li><a href= >Getting Started Guide</a> - Installation and basic setup</li>\n          <li><a href= >Features Documentation</a> - Detailed feature explanations</li>\n          <li><a href= >API Reference</a> - Complete API documentation</li>\n          <li><a href= >Demo Application</a> - See all features in action</li>\n          <li><a href="
  }
]