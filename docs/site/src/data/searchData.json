[
  {
    "id": "Demo/demo",
    "title": "Demo",
    "route": "/Demo/demo",
    "content": "\n\nconst bottomNavCode = `val bottomNavGraph = navigationGraph( ) {\n        startDestination(HomeDestination.Main)\n        destination(HomeDestination.Main) { _, nav -> HomeScreen(nav) }\n        destination(HomeDestination.Details) { _, nav -> DetailsScreen(nav) }\n    }\n    \n    tab( ) {\n        startDestination(ProfileDestination.Main)\n        destination(ProfileDestination.Main) { _, nav -> ProfileScreen(nav) }\n    }\n    \n    tab( ) {\n        startDestination(SettingsDestination.Main)\n        destination(SettingsDestination.Main) { _, nav -> SettingsScreen(nav) }\n    }\n}`\n\nconst masterDetailCode = `// List screen\nLazyColumn {\n    items(products) { product ->\n        ProductCard(\n            product = product,\n            onClick = { \n                navigator.navigate(ProductDestination.Details(product.id)) \n            },\n            imageModifier = Modifier.sharedElement(\n                sharedConfig = SharedElementConfig(\n                    key =  ,\n                    type = SharedElementType.Bounds\n                ),\n                navigator = navigator\n            )\n        )\n    }\n}`\n\nconst multiStepCode = `sealed class ProcessStep : Destination {\n    object Step1 : ProcessStep() { override val route =   }\n    object Step2 : ProcessStep() { override val route =   }\n    object Step3 : ProcessStep() { override val route =   }\n    object Complete : ProcessStep() { override val route =   }\n}\n\n// Navigate forward through steps\nfun onNext(currentStep: ProcessStep) {\n    when (currentStep) {\n        is ProcessStep.Step1 -> navigator.navigate(ProcessStep.Step2)\n        is ProcessStep.Step2 -> navigator.navigate(ProcessStep.Step3)\n        is ProcessStep.Step3 -> navigator.navigateAndClearTo(\n            destination = ProcessStep.Complete,\n            clearRoute =  ,\n            inclusive = false\n        )\n    }\n}`\n\nconst cloneRunCode = `# Clone the repository\ngit clone https://github.com/jermeyyy/quo-vadis.git\ncd quo-vadis\n\n# Run on Android\n./gradlew :composeApp:installDebug\n\n# Run on iOS (macOS only)\nopen iosApp/iosApp.xcodeproj\n\n# Run on Desktop\n./gradlew :composeApp:run\n\n# Run on Web (JavaScript)\n./gradlew :composeApp:jsBrowserDevelopmentRun\n\n# Run on Web (WebAssembly)\n./gradlew :composeApp:wasmJsBrowserDevelopmentRun`\n\nconst mainAppCode = `@Composable\nfun DemoApp() {\n    val navigator = rememberNavigator(startDestination = MainDestination.Home)\n    \n    Scaffold(\n        bottomBar = {\n            BottomNavigationBar(\n                currentRoute = navigator.currentDestination.value?.route,\n                onTabSelected = { destination ->\n                    navigator.navigate(destination)\n                }\n            )\n        }\n    ) { paddingValues ->\n        NavigationHost(\n            navigator = navigator,\n            screenRegistry = MainDestinationScreenRegistry,\n            modifier = Modifier.padding(paddingValues),\n            defaultTransition = NavigationTransitions.SlideHorizontal,\n            predictiveBackMode = PredictiveBackMode.FULL_CASCADE\n        )\n    }\n}`\n\nconst featureModuleCode = `// Using annotation-based API\n@Graph( )\nsealed class ProductDestination : Destination\n\n@Route( )\ndata object ProductList : ProductDestination()\n\n@Serializable\ndata class ProductDetailsData(val productId: String)\n\n@Route( >Navigation Patterns Demonstrated</h2>\n        \n        <h3 id= >1. Bottom Navigation Pattern</h3>\n        <p>\n          The demo uses bottom navigation for main app sections (Home, Profile, Settings). \n          Each tab is represented as a child of a TabNode in the NavNode tree, maintaining \n          independent navigation stacks within each tab.\n        </p>\n        <CodeBlock code={bottomNavCode} language= >2. Master-Detail Flow</h3>\n        <p>\n          Classic list-to-detail pattern enhanced with shared element transitions. \n          Images and text smoothly animate from the list to the detail screen.\n        </p>\n        <CodeBlock code={masterDetailCode} language= >3. Multi-Step Process</h3>\n        <p>\n          Wizard-style flows are handled elegantly with TreeMutator operations. \n          The demo includes validation, progress tracking, and the ability to jump \n          to specific steps using immutable state transformations.\n        </p>\n        <CodeBlock code={multiStepCode} language= >4. Nested Navigation</h3>\n        <p>\n          The demo shows how to implement tabs within tabs using nested TabNode and \n          StackNode structures in the NavNode tree. Each level of navigation is independent \n          and maintains its own state.\n        </p>\n\n        <h3 id= >5. Transition Showcase</h3>\n        <p>A dedicated screen demonstrates all available transitions:</p>\n        <ul>\n          <li><strong>Slide Horizontal:</strong> Standard left/right slide</li>\n          <li><strong>Slide Vertical:</strong> Bottom-up modal style</li>\n          <li><strong>Fade:</strong> Simple cross-fade</li>\n          <li><strong>Fade Through:</strong> Material Design fade through</li>\n          <li><strong>Scale In:</strong> Zoom-in effect</li>\n          <li><strong>Custom:</strong> User-defined transitions</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Running the Demo</h2>\n        \n        <h3>Prerequisites</h3>\n        <ul>\n          <li>Kotlin 2.2.20+</li>\n          <li>Android Studio or IntelliJ IDEA</li>\n          <li>For iOS: macOS with Xcode installed</li>\n        </ul>\n\n        <h3>Clone and Run</h3>\n        <CodeBlock code={cloneRunCode} language= >Code Examples from Demo</h2>\n        \n        <h3>Main Application Structure</h3>\n        <CodeBlock code={mainAppCode} language=  />\n\n        <h3>Feature Module Example</h3>\n        <CodeBlock code={featureModuleCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Explore More</h2>\n        <ul>\n          <li><a href= >Demo Source Code</a> - Full implementation on GitHub</li>\n          <li><Link to= >Getting Started</Link> - Build your own navigation</li>\n          <li><Link to= >Features</Link> - Learn about all capabilities</li>\n          <li><a href="
  },
  {
    "id": "Features/AnnotationAPI/annotationapi",
    "title": "Annotation A P I",
    "route": "/Features/AnnotationAPI/annotationapi",
    "content": "\n\nconst stackExample = `@Stack(name =  , startDestination = HomeDestination.Feed::class)\nsealed class HomeDestination : NavDestination {\n    // Destinations defined here\n}`\n\nconst argumentExample = `@Destination(route =  )\ndata class ProductDetail(\n    @Argument val id: String,                              // Required argument\n    @Argument(optional = true) val referrer: String? = null,  // Optional argument\n    @Argument(key =  ) val showReviews: Boolean = false  // Custom URL key\n) : ProductsDestination()`\n\nconst transitionExample = `@Transition(type = TransitionType.SlideHorizontal)\n@Destination(route =  )\ndata class Details(@Argument val id: String) : HomeDestination()\n\n@Transition(type = TransitionType.SlideVertical)\n@Destination(route =  )\ndata object Modal : HomeDestination()\n\n@Transition(type = TransitionType.Fade)\n@Destination(route =  )\ndata object Help : HomeDestination()\n\n@Transition(type = TransitionType.None)\n@Destination(route =  )\ndata object InstantSwitch : HomeDestination()`\n\nconst completeExample = `// Define a stack with destinations\n@Stack(name =  , startDestination = AppDestination.Main::class)\nsealed class AppDestination : NavDestination {\n\n    @Destination(route =  )\n    data object Main : AppDestination()\n\n    @Transition(type = TransitionType.SlideHorizontal)\n    @Destination(route =  )\n    data class Detail(\n        @Argument val itemId: String,\n        @Argument(optional = true) val highlight: Boolean = false\n    ) : AppDestination()\n\n    @Transition(type = TransitionType.SlideVertical)\n    @Destination(route =  )\n    data object Settings : AppDestination()\n}\n\n// Bind screens to destinations\n@Screen(AppDestination.Main::class)\n@Composable\nfun MainScreen(navigator: Navigator) {\n    Column {\n        Text( )\n        Button(onClick = { navigator.navigate(AppDestination.Detail( )) }) {\n            Text( )\n        }\n        Button(onClick = { navigator.navigate(AppDestination.Settings) }) {\n            Text( )\n        }\n    }\n}\n\n@Screen(AppDestination.Detail::class)\n@Composable\nfun DetailScreen(destination: AppDestination.Detail, navigator: Navigator) {\n    Column {\n        Text( )\n        if (destination.highlight) {\n            Text( )\n        }\n        Button(onClick = { navigator.navigateBack() }) {\n            Text( )\n        }\n    }\n}\n\n@Screen(AppDestination.Settings::class)\n@Composable\nfun SettingsScreen(navigator: Navigator) {\n    Column {\n        Text( )\n        Button(onClick = { navigator.navigateBack() }) {\n            Text( )\n        }\n    }\n}\n\n// Initialize navigation\n@Composable\nfun App() {\n    val navigator = remember {\n        TreeNavigator(\n            config = GeneratedNavigationConfig,\n            initialState = GeneratedNavigationConfig.buildNavNode(\n                AppDestination::class, \n                null\n            )!!\n        )\n    }\n    \n    NavigationHost(navigator = navigator)\n}`\n\nconst errorFormatExample = `{Description} in file   (line {lineNumber}). Fix: {Suggestion}`\n\nconst errorMessageExample = `Missing @Screen binding for  >@Stack Annotation</h2>\n        <p>\n          The <code>@Stack</code> annotation defines a navigation stack — a collection of destinations \n          that supports push and pop operations. Every navigation graph starts with a stack.\n        </p>\n\n        <CodeBlock code={stackExample} language=  />\n\n        <h3>Properties</h3>\n        <ul>\n          <li><code>name: String</code> — Unique identifier for the stack</li>\n          <li><code>startDestination: KClass&lt;*&gt;</code> — The initial destination when the stack is created</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >@Destination Annotation</h2>\n        <p>\n          The <code>@Destination</code> annotation marks a class as a navigation destination. \n          Use <code>data object</code> for destinations without arguments and <code>data class</code> for those with arguments.\n        </p>\n\n        <CodeBlock code={stackDestinationComprehensive} language=  />\n\n        <h3>Route Patterns</h3>\n        <ul>\n          <li><strong>Static route:</strong> <code> </code> — No parameters</li>\n          <li><strong>Path parameter:</strong> <code> </code> — Required parameter in URL path</li>\n          <li><strong>Multiple parameters:</strong> <code> </code> — Multiple path params</li>\n          <li><strong>Empty route:</strong> Omit or use <code> </code> for destinations that aren var(--color-text-secondary) /features/deep-linking >@Argument Annotation</h2>\n        <p>\n          The <code>@Argument</code> annotation marks constructor parameters as navigation arguments. \n          These are automatically serialized for deep linking and state restoration.\n        </p>\n\n        <CodeBlock code={argumentExample} language=  />\n\n        <h3>Properties</h3>\n        <ul>\n          <li><code>key: String</code> — Custom URL parameter key (defaults to property name)</li>\n          <li><code>optional: Boolean</code> — Whether the argument can be omitted in deep links</li>\n        </ul>\n\n        <h3>Supported Types</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>Type</th>\n              <th>Example</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr><td>String</td><td><code>@Argument val id: String</code></td></tr>\n            <tr><td>Int</td><td><code>@Argument val count: Int</code></td></tr>\n            <tr><td>Long</td><td><code>@Argument val timestamp: Long</code></td></tr>\n            <tr><td>Float</td><td><code>@Argument val rating: Float</code></td></tr>\n            <tr><td>Double</td><td><code>@Argument val price: Double</code></td></tr>\n            <tr><td>Boolean</td><td><code>@Argument val enabled: Boolean</code></td></tr>\n            <tr><td>Enum</td><td><code>@Argument val status: OrderStatus</code></td></tr>\n            <tr><td>@Serializable</td><td><code>@Argument val filter: FilterData</code></td></tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >@Screen Annotation</h2>\n        <p>\n          The <code>@Screen</code> annotation binds a composable function to render a specific destination. \n          The function can receive the navigator and the destination instance as parameters.\n        </p>\n\n        <CodeBlock code={screenBindingBasic} language=  />\n\n        <h3>Function Parameters</h3>\n        <ul>\n          <li><code>navigator: Navigator</code> — The navigation controller for performing navigation actions</li>\n          <li><code>destination: T</code> — The destination instance (for data class destinations with arguments)</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >@Tabs and @TabItem Annotations</h2>\n        <p>\n          For tabbed navigation where each tab maintains its own backstack. \n          Use <code>@Tabs</code> on the sealed class and <code>@TabItem</code> on each tab destination.\n        </p>\n\n        <CodeBlock code={tabsAnnotationBasic} language=  />\n\n        <h3>@Tabs Properties</h3>\n        <ul>\n          <li><code>name: String</code> — Unique identifier for the tab container</li>\n          <li><code>initialTab: KClass&lt;*&gt;</code> — The initially selected tab</li>\n          <li><code>items: Array&lt;KClass&lt;*&gt;&gt;</code> — Tab classes in display order</li>\n        </ul>\n\n        <h3>@TabItem Properties</h3>\n        <ul>\n          <li><code>label: String</code> — Display label for the tab</li>\n          <li><code>icon: String</code> — Icon identifier for the tab</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >@TabsContainer Annotation</h2>\n        <p>\n          Define a custom tab bar UI with <code>@TabsContainer</code>. \n          The composable receives a scope with tab metadata and switching functionality.\n        </p>\n\n        <CodeBlock code={tabsContainerWrapper} language=  />\n\n        <h3>TabsContainerScope</h3>\n        <ul>\n          <li><code>tabMetadata: List&lt;TabMetadata&gt;</code> — Label and icon info for each tab</li>\n          <li><code>activeTabIndex: Int</code> — Currently selected tab index</li>\n          <li><code>switchTab(index: Int)</code> — Function to switch to a different tab</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >@Pane and @PaneItem Annotations</h2>\n        <p>\n          For adaptive multi-pane layouts that adjust based on screen size. \n          Use <code>@Pane</code> on the sealed class and <code>@PaneItem</code> on each pane destination.\n        </p>\n\n        <CodeBlock code={paneAnnotationBasic} language=  />\n\n        <h3>@Pane Properties</h3>\n        <ul>\n          <li><code>name: String</code> — Unique identifier for the pane container</li>\n          <li><code>backBehavior: PaneBackBehavior</code> — Back navigation strategy</li>\n        </ul>\n\n        <h3>@PaneItem Properties</h3>\n        <ul>\n          <li><code>role: PaneRole</code> — <code>PRIMARY</code>, <code>SECONDARY</code>, or <code>EXTRA</code></li>\n          <li><code>adaptStrategy: AdaptStrategy</code> — <code>HIDE</code>, <code>COLLAPSE</code>, <code>OVERLAY</code>, or <code>REFLOW</code></li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >@PaneContainer Annotation</h2>\n        <p>\n          Define custom pane layout behavior with <code>@PaneContainer</code>. \n          Control how panes are arranged based on screen size.\n        </p>\n\n        <CodeBlock code={paneContainerWrapper} language=  />\n      </section>\n\n      <section>\n        <h2 id= >@Transition Annotation</h2>\n        <p>\n          Specify transition animations for destinations with <code>@Transition</code>. \n          Different destinations can have different transition styles.\n        </p>\n\n        <CodeBlock code={transitionExample} language=  />\n\n        <h3>TransitionType Options</h3>\n        <TransitionTypesDisplay \n          variant=  \n          transitions={[\n            { name:  Platform-like horizontal slide (default) Bottom-to-top for modals  },\n            { name:   },\n            { name:  User-defined animation var(--color-text-secondary) /features/transitions >What Gets Generated</h2>\n        <p>\n          The KSP processor generates several components from your annotated classes:\n        </p>\n\n        <ul>\n          <li><strong>NavigationConfig:</strong> Central configuration object containing all routes and screen mappings</li>\n          <li><strong>ScreenRegistry:</strong> Maps destinations to their composable screens</li>\n          <li><strong>RouteParser:</strong> Handles deep link parsing and argument extraction</li>\n          <li><strong>NavNode Builders:</strong> Functions to construct the navigation tree</li>\n          <li><strong>Type-safe Extensions:</strong> Generated <code>navigate()</code> extensions for each destination</li>\n        </ul>\n\n        <CodeBlock code={generatedConfigUsage} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Complete Example</h2>\n        <p>\n          Here  />\n      </section>\n\n      <section>\n        <h2 id= >Validation & Error Messages</h2>\n        <p>\n          Quo Vadis validates annotation usage at compile time. When validation fails,\n          the build fails with clear error messages that include:\n        </p>\n        <ul>\n          <li><strong>Location:</strong> File name and line number</li>\n          <li><strong>Problem:</strong> What  />\n\n        <p>Example error message:</p>\n        <CodeBlock code={errorMessageExample} language=  />\n\n        <h3>@Stack Validation</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>Rule</th>\n              <th>Severity</th>\n              <th>Example Message</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Must be sealed class</td>\n              <td>Error</td>\n              <td><code>@Stack   must be a sealed class in file   (line 5). Fix: Change  sealed class HomeStack  (line 5). Fix: Use one of the available destinations: [Feed, Profile, Settings]</code></td>\n            </tr>\n            <tr>\n              <td>Must have destinations</td>\n              <td>Error</td>\n              <td><code>@Stack   has no destinations in file   (line 3). Fix: Add at least one @Destination annotated subclass inside this sealed class</code></td>\n            </tr>\n          </tbody>\n        </table>\n\n        <h3>@Destination Validation</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>Rule</th>\n              <th>Severity</th>\n              <th>Example Message</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Must be data object/class</td>\n              <td>Error</td>\n              <td><code>@Destination   must be a data object or data class in file   (line 10). Fix: Use  data class InvalidDest(...)  in @Destination on UserProfile has no matching constructor parameter in file   (line 8). Fix: Add a constructor parameter named   from the route</code></td>\n            </tr>\n            <tr>\n              <td>@Argument param must be in route</td>\n              <td>Error</td>\n              <td><code>@Argument param   in UserProfile is not in route pattern   to the route pattern or remove @Argument annotation</code></td>\n            </tr>\n            <tr>\n              <td>Duplicate routes</td>\n              <td>Error</td>\n              <td><code>Duplicate route   - also used by: FeedScreen in file   (line 12). Fix: Use a unique route pattern for this destination</code></td>\n            </tr>\n            <tr>\n              <td>Must have @Screen binding</td>\n              <td>Error</td>\n              <td><code>Missing @Screen binding for   (line 12). Fix: Add a @Composable function annotated with @Screen(HomeDestination.Feed::class)</code></td>\n            </tr>\n          </tbody>\n        </table>\n        <p>\n          <strong>Note:</strong> Constructor parameters without <code>@Argument</code> annotation are not \n          required to be in the route. They can be passed programmatically (not via deep links).\n        </p>\n\n        <h3>@Argument Validation</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>Rule</th>\n              <th>Severity</th>\n              <th>Example Message</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Optional requires default</td>\n              <td>Error</td>\n              <td><code>@Argument(optional = true) on   in SearchResults requires a default value in file   (line 15). Fix: Add a default value: page: Int = defaultValue</code></td>\n            </tr>\n            <tr>\n              <td>Path param cannot be optional</td>\n              <td>Error</td>\n              <td><code>Path parameter   in UserProfile cannot be optional in file   (line 8). Fix: Move this parameter to query parameters (after  ) or remove @Argument(optional = true)</code></td>\n            </tr>\n            <tr>\n              <td>Duplicate argument keys</td>\n              <td>Error</td>\n              <td><code>Duplicate argument key   in ArticleDetail in file   (line 20). Fix: Use unique keys for each @Argument parameter</code></td>\n            </tr>\n            <tr>\n              <td>Key not in route</td>\n              <td>Error</td>\n              <td><code>@Argument key   in Profile is not found in route pattern   (line 10). Fix: Add   to the route pattern, or change the argument key to match: [profileId]</code></td>\n            </tr>\n          </tbody>\n        </table>\n\n        <h3>@Screen Validation</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>Rule</th>\n              <th>Severity</th>\n              <th>Example Message</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Invalid destination reference</td>\n              <td>Error</td>\n              <td><code>@Screen(InvalidClass::class) references a class without @Destination in file   (line 25). Fix: Add @Destination annotation to InvalidClass or reference a valid destination</code></td>\n            </tr>\n            <tr>\n              <td>Duplicate screen bindings</td>\n              <td>Error</td>\n              <td><code>Multiple @Screen bindings for HomeDestination.Feed: FeedScreen, FeedScreenDuplicate in file   (line 30). Fix: Keep only one @Screen function for this destination</code></td>\n            </tr>\n          </tbody>\n        </table>\n\n        <h3>@Tabs Validation</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>Rule</th>\n              <th>Severity</th>\n              <th>Example Message</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Must be sealed class</td>\n              <td>Error</td>\n              <td><code>@Tabs   must be a sealed class in file   (line 5). Fix: Change  sealed class MainTabs  (line 5). Fix: Use one of the available tabs: [HomeTab, ProfileTab, SettingsTab]</code></td>\n            </tr>\n            <tr>\n              <td>Empty tabs</td>\n              <td>Error</td>\n              <td><code>@Tabs container   has no @TabItem entries in file   (line 3). Fix: Add at least one @TabItem annotated class to the items array</code></td>\n            </tr>\n          </tbody>\n        </table>\n\n        <h3>@TabItem Validation</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>Rule</th>\n              <th>Severity</th>\n              <th>Example Message</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Must have @Stack or @Destination</td>\n              <td>Error</td>\n              <td><code>@TabItem   has neither @Stack nor @Destination in file   (line 15). Fix: Add @Stack for nested navigation or @Destination for flat screen</code></td>\n            </tr>\n            <tr>\n              <td>Cannot have both @Stack and @Destination</td>\n              <td>Error</td>\n              <td><code>@TabItem   has both @Stack and @Destination in file   (line 20). Fix: Use @Stack for nested navigation OR @Destination for flat screen, not both</code></td>\n            </tr>\n          </tbody>\n        </table>\n\n        <h3>@Pane Validation</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>Rule</th>\n              <th>Severity</th>\n              <th>Example Message</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Must be sealed class</td>\n              <td>Error</td>\n              <td><code>@Pane   must be a sealed class in file   (line 5). Fix: Change  sealed class DetailPane  has no @PaneItem entries in file   (line 3). Fix: Add at least one @PaneItem annotated class to the items array</code></td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><Link to= >Get started</Link> with the quick start guide</li>\n          <li><Link to= >Type-Safe Navigation</Link> — Learn about programmatic destination building</li>\n          <li><Link to= >Deep Linking</Link> — Configure deep link handling</li>\n          <li><Link to= >Transitions</Link> — Customize navigation animations</li>\n          <li><Link to="
  },
  {
    "id": "Features/Architecture/architecture",
    "title": "Architecture",
    "route": "/Features/Architecture/architecture",
    "content": "\n\n// Architecture Diagram Styles\nconst diagramStyles = {\n  container: {\n    display:  ,\n    flexDirection:   as const,\n    alignItems:  ,\n  },\n  layer: {\n    width:  1px solid var(--color-border)  as const,\n    textTransform:   as const,\n    letterSpacing:  ,\n    opacity: 0.7,\n  },\n  box: {\n    background:   as const,\n    border:   as const,\n  },\n  renderingLayer: {\n    background:  rgba(59, 130, 246, 0.3) rgba(34, 197, 94, 0.08) rgba(34, 197, 94, 0.3) rgba(139, 92, 246, 0.08) rgba(139, 92, 246, 0.3) ,\n    justifyContent:   as const,\n  },\n  smallBox: {\n    fontSize:  ,\n  },\n  flowLabel: {\n    fontSize:  var(--color-text-muted)  as const,\n  },\n  treeContent: {\n    display:  ,\n    justifyContent:   as const,\n  },\n  treeNode: {\n    padding:  var(--color-bg-elevated) 1px solid rgba(139, 92, 246, 0.4) var(--color-text-muted) ,\n    flexDirection:  ,\n  }}>\n    <div style={{\n      width:  ,\n    }} />\n    <div style={{\n      width:  ,\n      borderRight:  8px solid var(--color-text-muted, #9ca3af)  }}>\n      Application\n    </div>\n    \n    <Arrow />\n    \n    {/* Rendering Layer */}\n    <div style={{ ...diagramStyles.layer, ...diagramStyles.renderingLayer }}>\n      <div style={diagramStyles.layerTitle}>Rendering Layer</div>\n      \n      <div style={{ display:   }}>\n        <div style={diagramStyles.box}>NavigationHost</div>\n        <Arrow />\n        <div style={diagramStyles.box}>NavNodeRenderer</div>\n        <Arrow />\n        <div style={diagramStyles.renderersRow}>\n          <div style={{ ...diagramStyles.box, ...diagramStyles.smallBox }}>ScreenRenderer</div>\n          <div style={{ ...diagramStyles.box, ...diagramStyles.smallBox }}>StackRenderer</div>\n          <div style={{ ...diagramStyles.box, ...diagramStyles.smallBox }}>TabRenderer</div>\n          <div style={{ ...diagramStyles.box, ...diagramStyles.smallBox }}>PaneRenderer</div>\n        </div>\n      </div>\n    </div>\n    \n    <div style={{ display:   }}>\n      <Arrow />\n      <span style={diagramStyles.flowLabel}>observes StateFlow&lt;NavNode&gt;</span>\n    </div>\n    \n    {/* Logic Layer */}\n    <div style={{ ...diagramStyles.layer, ...diagramStyles.logicLayer }}>\n      <div style={diagramStyles.layerTitle}>Logic Layer</div>\n      \n      <div style={{ display:   }}>\n        <div style={diagramStyles.box}>Navigator <span style={{ opacity: 0.6, fontSize:   }}>(interface)</span></div>\n        <Arrow />\n        <div style={diagramStyles.box}>TreeNavigator <span style={{ opacity: 0.6, fontSize:   }}>(impl)</span></div>\n        <Arrow />\n        <div style={diagramStyles.box}>TreeMutator <span style={{ opacity: 0.6, fontSize:   }}>(pure functions)</span></div>\n      </div>\n    </div>\n    \n    <Arrow />\n    \n    {/* NavNode Tree */}\n    <div style={{ ...diagramStyles.layer, ...diagramStyles.treeLayer }}>\n      <div style={diagramStyles.layerTitle}>NavNode Tree</div>\n      \n      <div style={diagramStyles.treeContent}>\n        <span style={diagramStyles.treeNode}>StackNode</span>\n        <span style={diagramStyles.treeArrow}>→</span>\n        <span style={diagramStyles.treeNode}>TabNode</span>\n        <span style={diagramStyles.treeArrow}>→</span>\n        <span style={diagramStyles.treeNode}>ScreenNode</span>\n      </div>\n    </div>\n  </div>\n)\n\nconst navigatorInterfaceCode = `interface Navigator {\n    // Core state\n    val state: StateFlow<NavNode>\n    val transitionState: StateFlow<TransitionState>\n    val currentDestination: StateFlow<NavDestination?>\n    val canNavigateBack: StateFlow<Boolean>\n    \n    // Navigation operations\n    fun navigate(destination: NavDestination, transition: NavigationTransition? = null)\n    fun navigateBack(): Boolean\n    fun navigateAndClearTo(destination: NavDestination, clearRoute: String?, inclusive: Boolean)\n    fun navigateAndReplace(destination: NavDestination, transition: NavigationTransition?)\n    fun navigateAndClearAll(destination: NavDestination)\n    \n    // Deep linking\n    fun handleDeepLink(deepLink: DeepLink)\n    \n    // State manipulation (advanced)\n    fun updateState(newState: NavNode, transition: NavigationTransition?)\n}`\n\nconst treeNavigatorCode = `class TreeNavigator(\n    private val deepLinkHandler: DeepLinkHandler = DefaultDeepLinkHandler(),\n    private val coroutineScope: CoroutineScope = CoroutineScope(SupervisorJob() + Dispatchers.Main.immediate),\n    initialState: NavNode? = null,\n    private val scopeRegistry: ScopeRegistry = ScopeRegistry.Empty,\n    private val containerRegistry: ContainerRegistry = ContainerRegistry.Empty\n) : Navigator {\n    // Immutable state management\n    private val _state = MutableStateFlow<NavNode>(initialState ?: ScreenNode.empty())\n    override val state: StateFlow<NavNode> = _state.asStateFlow()\n    \n    // Derived state computed synchronously\n    override val currentDestination: StateFlow<NavDestination?>\n    override val canNavigateBack: StateFlow<Boolean>\n}`\n\nconst treeMutatorCode = `object TreeMutator {\n    // Push operations - return new immutable tree\n    fun push(\n        root: NavNode,\n        destination: NavDestination,\n        scopeRegistry: ScopeRegistry = ScopeRegistry.Empty,\n        keyGenerator: () -> String\n    ): NavNode\n    \n    // Pop operations\n    fun pop(root: NavNode, behavior: PopBehavior = PopBehavior.RemoveEmptyStacks): PopResult\n    fun popTo(root: NavNode, predicate: (NavNode) -> Boolean, inclusive: Boolean = false): NavNode\n    \n    // Tab operations\n    fun switchTab(root: NavNode, nodeKey: String, tabIndex: Int): NavNode\n    \n    // Pane operations\n    fun navigateToPane(root: NavNode, nodeKey: String, role: PaneRole, destination: NavDestination): NavNode\n}`\n\n// Data Flow Diagram Styles\nconst dataFlowStyles = {\n  container: {\n    display:  ,\n    flexDirection:   as const,\n    alignItems:  ,\n  },\n  box: {\n    width:  var(--color-bg-elevated)  as const,\n    border:   as const,\n  },\n  boxTitle: {\n    fontWeight:   as const,\n    fontSize:  ,\n  },\n  boxNote: {\n    fontSize:  ,\n    opacity: 0.7,\n    fontStyle:   as const,\n  },\n  userAction: {\n    background:  rgba(234, 179, 8, 0.5) rgba(34, 197, 94, 0.1) rgba(34, 197, 94, 0.4) rgba(139, 92, 246, 0.1) rgba(139, 92, 246, 0.4) rgba(59, 130, 246, 0.1) rgba(59, 130, 246, 0.4) rgba(20, 184, 166, 0.1) rgba(20, 184, 166, 0.4) rgba(236, 72, 153, 0.1) rgba(236, 72, 153, 0.4) ,\n    flexDirection:  ,\n  }}>\n    <div style={{\n      width:  ,\n    }} />\n    <div style={{\n      width:  ,\n      borderRight:  8px solid var(--color-text-muted, #9ca3af) >Overview</h2>\n        <p>\n          The architecture is divided into two main layers that interact through a \n          unidirectional data flow pattern:\n        </p>\n        <ul>\n          <li><strong>Logic Layer</strong> manages navigation state as an immutable tree of <code>NavNode</code> objects</li>\n          <li><strong>Rendering Layer</strong> recursively renders the tree to Compose UI with animations</li>\n        </ul>\n        <p>\n          The Logic Layer exposes navigation state through Kotlin <code>StateFlow</code>, which the \n          Rendering Layer observes and converts to Compose UI. User interactions in the UI trigger \n          navigation operations that flow back up to the Logic Layer.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Architecture Diagram</h2>\n        <p>\n          The following diagram shows how the layers interact and the flow of data through the system:\n        </p>\n        <ArchitectureDiagram />\n      </section>\n\n      <section>\n        <h2 id= >Logic Layer</h2>\n        <p>\n          The logic layer is responsible for managing navigation state as an immutable tree structure.\n          It consists of three key components:\n        </p>\n\n        <h3>Navigator Interface</h3>\n        <p>\n          <code>Navigator</code> is the central navigation controller interface that defines the \n          contract for all navigation operations:\n        </p>\n        <CodeBlock code={navigatorInterfaceCode} language=  />\n        \n        <table>\n          <thead>\n            <tr>\n              <th>Property</th>\n              <th>Type</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>state</code></td>\n              <td><code>StateFlow&lt;NavNode&gt;</code></td>\n              <td>Current navigation state as immutable tree</td>\n            </tr>\n            <tr>\n              <td><code>transitionState</code></td>\n              <td><code>StateFlow&lt;TransitionState&gt;</code></td>\n              <td>Animation/transition state</td>\n            </tr>\n            <tr>\n              <td><code>currentDestination</code></td>\n              <td><code>StateFlow&lt;NavDestination?&gt;</code></td>\n              <td>Active destination (derived)</td>\n            </tr>\n            <tr>\n              <td><code>canNavigateBack</code></td>\n              <td><code>StateFlow&lt;Boolean&gt;</code></td>\n              <td>Whether back navigation is possible</td>\n            </tr>\n          </tbody>\n        </table>\n\n        <h3>TreeNavigator Implementation</h3>\n        <p>\n          <code>TreeNavigator</code> is the concrete implementation of Navigator using a tree-based state model:\n        </p>\n        <CodeBlock code={treeNavigatorCode} language=  />\n        <p>Key features of TreeNavigator:</p>\n        <ul>\n          <li><strong>Immutable State Management:</strong> Uses <code>MutableStateFlow&lt;NavNode&gt;</code> internally, exposes as immutable <code>StateFlow</code></li>\n          <li><strong>Container-Aware Navigation:</strong> Automatically creates Tab/Pane containers when navigating to containerized destinations</li>\n          <li><strong>Scope-Aware Navigation:</strong> Out-of-scope destinations push to parent stack</li>\n          <li><strong>Lifecycle Event Dispatch:</strong> Dispatches <code>onScreenExited</code> and <code>onScreenDestroyed</code> events</li>\n        </ul>\n\n        <h3>TreeMutator</h3>\n        <p>\n          <code>TreeMutator</code> is a singleton object containing pure functions for tree manipulation.\n          All operations take a tree and return a new tree without modifying the original:\n        </p>\n        <CodeBlock code={treeMutatorCode} language=  />\n        <p>\n          Design principles:\n        </p>\n        <ul>\n          <li><strong>Pure Functions:</strong> All operations take a tree and return a new tree</li>\n          <li><strong>Immutability:</strong> Original tree is never modified</li>\n          <li><strong>Structural Sharing:</strong> Unchanged subtrees are reused for efficiency</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Rendering Layer</h2>\n        <p>\n          The rendering layer converts the navigation tree to Compose UI with animations \n          and gesture support.\n        </p>\n\n        <h3>NavigationHost</h3>\n        <p>\n          <code>NavigationHost</code> is the main entry point for rendering navigation content. \n          It sets up the infrastructure for navigation:\n        </p>\n        <ul>\n          <li><strong>State Collection:</strong> Collects <code>navigator.state</code> as Compose state</li>\n          <li><strong>Infrastructure Setup:</strong> Creates <code>SaveableStateHolder</code>, <code>ComposableCache</code>, <code>AnimationCoordinator</code></li>\n          <li><strong>Predictive Back:</strong> Wraps content in <code>NavigateBackHandler</code> for gesture support</li>\n          <li><strong>Shared Elements:</strong> Wraps content in <code>SharedTransitionLayout</code> for shared element transitions</li>\n        </ul>\n\n        <h3>NavNodeRenderer</h3>\n        <p>\n          <code>NavNodeRenderer</code> is the core recursive renderer that dispatches to specialized \n          renderers based on node type:\n        </p>\n        <ul>\n          <li><strong>ScreenRenderer:</strong> Renders leaf <code>ScreenNode</code> content via the screen registry</li>\n          <li><strong>StackRenderer:</strong> Renders <code>StackNode</code> with animated push/pop transitions</li>\n          <li><strong>TabRenderer:</strong> Renders <code>TabNode</code> with tab wrapper and switching animations</li>\n          <li><strong>PaneRenderer:</strong> Renders <code>PaneNode</code> with adaptive multi-pane layouts</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >NavNode Types</h2>\n        <p>\n          The navigation tree consists of four node types forming a sealed hierarchy. \n          Each type supports different navigation patterns:\n        </p>\n        \n        <table>\n          <thead>\n            <tr>\n              <th>Type</th>\n              <th>Purpose</th>\n              <th>Contains</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>ScreenNode</code></td>\n              <td>Leaf destination</td>\n              <td>Destination data</td>\n            </tr>\n            <tr>\n              <td><code>StackNode</code></td>\n              <td>Linear navigation</td>\n              <td>List of children (last = active)</td>\n            </tr>\n            <tr>\n              <td><code>TabNode</code></td>\n              <td>Parallel tabs</td>\n              <td>List of StackNodes</td>\n            </tr>\n            <tr>\n              <td><code>PaneNode</code></td>\n              <td>Adaptive panes</td>\n              <td>Map of PaneRole to configuration</td>\n            </tr>\n          </tbody>\n        </table>\n\n        <h3>Tree Structure Example</h3>\n        <p>\n          Here /features/stack-management /features/tabbed-navigation >Data Flow</h2>\n        <p>\n          Navigation follows a unidirectional data flow pattern:\n        </p>\n        <DataFlowDiagram />\n        \n        <h3>Key Principles</h3>\n        <ul>\n          <li><strong>Unidirectional Data Flow:</strong> State flows down, events flow up</li>\n          <li><strong>Single Source of Truth:</strong> <code>Navigator.state</code> is the only source of navigation state</li>\n          <li><strong>Immutable Updates:</strong> Every navigation operation creates a new tree</li>\n          <li><strong>Separation of Concerns:</strong> Logic layer doesn >Component Summary</h2>\n        <table>\n          <thead>\n            <tr>\n              <th>Component</th>\n              <th>Layer</th>\n              <th>Responsibility</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>Navigator</code></td>\n              <td>Logic</td>\n              <td>Navigation operations interface</td>\n            </tr>\n            <tr>\n              <td><code>TreeNavigator</code></td>\n              <td>Logic</td>\n              <td>Concrete implementation with StateFlow</td>\n            </tr>\n            <tr>\n              <td><code>TreeMutator</code></td>\n              <td>Logic</td>\n              <td>Pure functions for tree manipulation</td>\n            </tr>\n            <tr>\n              <td><code>NavigationHost</code></td>\n              <td>Rendering</td>\n              <td>Entry point, infrastructure setup</td>\n            </tr>\n            <tr>\n              <td><code>NavNodeRenderer</code></td>\n              <td>Rendering</td>\n              <td>Type-based dispatch to specialized renderers</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><Link to= >Stack Management</Link> - Linear navigation stacks and back stack operations</li>\n          <li><Link to= >Tabbed Navigation</Link> - Parallel tab stacks with independent history</li>\n          <li><Link to= >Transitions & Animations</Link> - Customize navigation animations</li>\n          <li><Link to="
  },
  {
    "id": "Features/BackStack/backstack",
    "title": "Back Stack",
    "route": "/Features/BackStack/backstack",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css )\n\n// Get active path from root to leaf\nval path: List<NavNode> = rootNode.activePathToLeaf()\n\n// Get deepest active screen\nval activeScreen: ScreenNode? = rootNode.activeLeaf()\n\n// Get active stack (for push/pop operations)\nval stack: StackNode? = rootNode.activeStack()\n\n// Get all screens in subtree\nval screens: List<ScreenNode> = rootNode.allScreens()\n\n// Check if node can handle back internally\nval canHandleBack: Boolean = rootNode.canHandleBackInternally()`\n\nconst navigatorBackCode = `// Simple back navigation\nnavigator.navigateBack()\n\n// Navigate and clear to specific point\nnavigator.navigateAndClearTo(\n    destination = HomeDestination.Feed,\n    clearRoute =  ,\n    inclusive = true\n)\n\n// Replace current screen\nnavigator.navigateAndReplace(\n    destination = ProfileDestination.Edit,\n    transition = NavigationTransitions.Fade\n)\n\n// Clear entire backstack\nnavigator.navigateAndClearAll(AuthDestination.Login)`\n\nconst treeMutatorCode = `// Push onto active stack\nval newTree = TreeMutator.push(currentTree, destination)\nnavigator.updateState(newTree, transition)\n\n// Pop from active stack\nval newTree = TreeMutator.pop(currentTree, PopBehavior.CASCADE)\n\n// Pop to specific destination type\nval newTree = TreeMutator.popToDestination<HomeDestination>(currentTree, inclusive = false)\n\n// Pop to route string\nval newTree = TreeMutator.popToRoute(currentTree,  , inclusive = false)\n\n// Push multiple destinations\nval newTree = TreeMutator.pushAll(currentTree, listOf(\n    OrderListDestination,\n    OrderDetailDestination( ),\n    TrackingDestination( )\n))\n\n// Clear and push\nval newTree = TreeMutator.clearAndPush(currentTree, HomeDestination.Feed)\n\n// Replace current\nval newTree = TreeMutator.replaceCurrent(currentTree, DashboardDestination)`\n\nconst tabOperationsCode = `// Switch to specific tab\nval newTree = TreeMutator.switchTab(currentTree, tabNodeKey, newIndex)\n\n// Switch active TabNode >NavNode Types</h2>\n        <p>\n          Each node type serves a specific navigation pattern:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Type</th>\n              <th>Purpose</th>\n              <th>Contains</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>ScreenNode</code></td>\n              <td>Leaf destination</td>\n              <td>Destination data</td>\n            </tr>\n            <tr>\n              <td><code>StackNode</code></td>\n              <td>Linear navigation</td>\n              <td>List of children (last = active)</td>\n            </tr>\n            <tr>\n              <td><code>TabNode</code></td>\n              <td>Parallel tabs</td>\n              <td>List of StackNodes</td>\n            </tr>\n            <tr>\n              <td><code>PaneNode</code></td>\n              <td>Adaptive panes</td>\n              <td>Map of PaneRole to PaneConfiguration</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Tree Traversal Extensions</h2>\n        <p>\n          NavNode provides extension functions for traversing and querying the tree:\n        </p>\n        <CodeBlock code={treeTraversalCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Navigator Back Operations</h2>\n        <p>\n          Navigator provides high-level methods for common back navigation scenarios:\n        </p>\n        <CodeBlock code={navigatorBackCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >TreeMutator Operations</h2>\n        <p>\n          For advanced scenarios, use TreeMutator  />\n      </section>\n\n      <section>\n        <h2 id= >PopBehavior Options</h2>\n        <p>\n          Control how empty stacks are handled after a pop operation:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Behavior</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>PRESERVE_EMPTY</code></td>\n              <td>Keep empty stacks in place</td>\n            </tr>\n            <tr>\n              <td><code>CASCADE</code></td>\n              <td>Remove empty stacks, cascading up the tree</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Tab Operations</h2>\n        <p>\n          TreeMutator provides operations for tab-based navigation:\n        </p>\n        <CodeBlock code={tabOperationsCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Pane Operations</h2>\n        <p>\n          For adaptive multi-pane layouts, use pane-specific operations:\n        </p>\n        <CodeBlock code={paneOperationsCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Back Navigation with Tab Awareness</h2>\n        <p>\n          Handle back navigation that properly accounts for tab state:\n        </p>\n        <CodeBlock code={backWithTabsCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >BackResult Types</h2>\n        <p>\n          The <code>popWithTabBehavior</code> function returns a sealed class indicating the result:\n        </p>\n        <CodeBlock code={backResultCode} language=  />\n        <ul>\n          <li><strong>Handled:</strong> Back was processed, apply the new state</li>\n          <li><strong>DelegateToSystem:</strong> Let the platform handle back (e.g., exit app)</li>\n          <li><strong>CannotHandle:</strong> Navigation cannot process this back gesture</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Checking Back Availability</h2>\n        <p>\n          Check whether back navigation is possible before showing UI elements:\n        </p>\n        <CodeBlock code={checkBackCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Best Practices</h2>\n        <ul>\n          <li><strong>Use Navigator for standard operations:</strong> It handles common cases and provides type safety</li>\n          <li><strong>Use TreeMutator for batch operations:</strong> When you need multiple mutations or custom logic</li>\n          <li><strong>The original tree is never modified:</strong> All operations are immutable</li>\n          <li><strong>Unchanged subtrees are reused:</strong> Structural sharing ensures efficiency</li>\n          <li><strong>All TreeMutator operations are thread-safe:</strong> Pure functions can be called from any context</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Tabbed Navigation</a> - Deep dive into TabNode patterns</li>\n          <li><a href= >Multi-Pane Layouts</a> - Adaptive pane navigation</li>\n          <li><a href= >Transitions</a> - Animate navigation changes</li>\n          <li><a href="
  },
  {
    "id": "Features/DIIntegration/diintegration",
    "title": "D I Integration",
    "route": "/Features/DIIntegration/diintegration",
    "content": "\n\n// Styled heading components for Do/Don T</span></h3>\n)\n\n// Dependencies\nconst dependencyCode = `dependencies {\n    implementation( )\n}\n\n// Transitively includes:\n// - FlowMVI (pro.respawn.flowmvi)\n// - Koin (io.insert-koin)\n// - quo-vadis-core`\n\n// MVI Contract\nconst contractCode = `// State - What the UI displays\nsealed interface ProfileState : MVIState {\n    data object Loading : ProfileState\n    data class Content(val user: UserData) : ProfileState\n    data class Error(val message: String) : ProfileState\n}\n\n// Intent - What the user wants to do\nsealed interface ProfileIntent : MVIIntent {\n    data object LoadProfile : ProfileIntent\n    data object NavigateToSettings : ProfileIntent\n    data object NavigateBack : ProfileIntent\n}\n\n// Action - Side effects (toasts, etc.)\nsealed interface ProfileAction : MVIAction {\n    data class ShowToast(val message: String) : ProfileAction\n}`\n\n// Navigator Registration\nconst navigatorRegistrationCode = `val navigationModule = module {\n    single<NavigationConfig> {\n        ComposeAppNavigationConfig +\n            Feature1NavigationConfig +\n            Feature2NavigationConfig\n    }\n    \n    single<Navigator> {\n        val config = get<NavigationConfig>()\n        val initialState = config.buildNavNode(\n            destinationClass = MainTabs::class,\n            parentKey = null\n        ) ?: error( )\n        \n        TreeNavigator(\n            config = config,\n            initialState = initialState\n        )\n    }\n}`\n\n// Screen Container Code\nconst screenContainerCode = `class ProfileContainer(\n    scope: NavigationContainerScope,\n    private val repository: ProfileRepository\n) : NavigationContainer<ProfileState, ProfileIntent, ProfileAction>(scope) {\n\n    override val store = store(initial = ProfileState.Loading) {\n        init { intent(ProfileIntent.LoadProfile) }\n        \n        reduce { intent ->\n            when (intent) {\n                is ProfileIntent.LoadProfile -> handleLoadProfile()\n                is ProfileIntent.NavigateToSettings -> {\n                    navigator.navigate(MainTabs.SettingsTab.Main)\n                }\n                is ProfileIntent.NavigateBack -> navigator.navigateBack()\n            }\n        }\n        \n        recover { exception ->\n            action(ProfileAction.ShowToast(exception.message ?:  ))\n            updateState { ProfileState.Error(exception.message ?:  ) }\n            null\n        }\n    }\n\n    private suspend fun Ctx.handleLoadProfile() {\n        updateState { ProfileState.Loading }\n        val user = repository.getUser()\n        updateState { ProfileState.Content(user = user) }\n    }\n}`\n\n// Koin Module Registration\nconst koinModuleCode = `val profileModule = module {\n    single { ProfileRepository() }\n    \n    // Screen-scoped container\n    navigationContainer<ProfileContainer> { scope ->\n        ProfileContainer(scope, scope.get())\n    }\n}\n\nval tabsDemoModule = module {\n    // Container-scoped shared state\n    sharedNavigationContainer<DemoTabsContainer> { scope ->\n        DemoTabsContainer(scope)\n    }\n}`\n\n// rememberContainer Usage\nconst rememberContainerCode = `@Screen(MainTabs.ProfileTab::class)\n@Composable\nfun ProfileScreen() {\n    val store = rememberContainer<ProfileContainer, ProfileState, ProfileIntent, ProfileAction>()\n    val snackbarHostState = remember { SnackbarHostState() }\n    val scope = rememberCoroutineScope()\n\n    val state by store.subscribe { action ->\n        scope.launch {\n            when (action) {\n                is ProfileAction.ShowToast -> {\n                    snackbarHostState.showSnackbar(action.message)\n                }\n            }\n        }\n    }\n\n    Scaffold(snackbarHost = { SnackbarHost(snackbarHostState) }) {\n        when (state) {\n            is ProfileState.Loading -> LoadingContent()\n            is ProfileState.Content -> ProfileContent(\n                state = state as ProfileState.Content,\n                onIntent = store::intent\n            )\n            is ProfileState.Error -> ErrorContent(\n                message = (state as ProfileState.Error).message,\n                onRetry = { store.intent(ProfileIntent.LoadProfile) }\n            )\n        }\n    }\n}`\n\n// Shared Container Code\nconst sharedContainerCode = `data class DemoTabsState(\n    val totalItemsViewed: Int = 0,\n    val favoriteItems: List<String> = emptyList()\n) : MVIState\n\nsealed interface DemoTabsIntent : MVIIntent {\n    data object IncrementViewed : DemoTabsIntent\n    data class AddFavorite(val itemId: String) : DemoTabsIntent\n}\n\nsealed interface DemoTabsAction : MVIAction\n\nclass DemoTabsContainer(\n    scope: SharedContainerScope\n) : SharedNavigationContainer<DemoTabsState, DemoTabsIntent, DemoTabsAction>(scope) {\n\n    override val store = store(DemoTabsState()) {\n        reduce { intent ->\n            when (intent) {\n                is DemoTabsIntent.IncrementViewed -> updateState {\n                    copy(totalItemsViewed = totalItemsViewed + 1)\n                }\n                is DemoTabsIntent.AddFavorite -> updateState {\n                    copy(favoriteItems = favoriteItems + intent.itemId)\n                }\n            }\n        }\n    }\n}\n\n// Provide shared store via CompositionLocal\nval LocalDemoTabsStore = staticCompositionLocalOf<Store<DemoTabsState, DemoTabsIntent, DemoTabsAction>> {\n    throw IllegalStateException( )\n}`\n\n// rememberSharedContainer Usage\nconst rememberSharedContainerCode = `@TabsContainer(DemoTabs::class)\n@Composable\nfun DemoTabsWrapper(\n    scope: TabsContainerScope,\n    content: @Composable () -> Unit\n) {\n    val sharedStore = rememberSharedContainer<DemoTabsContainer, DemoTabsState, DemoTabsIntent, DemoTabsAction>()\n    val state by sharedStore.subscribe()\n\n    CompositionLocalProvider(LocalDemoTabsStore provides sharedStore) {\n        Scaffold(\n            topBar = {\n                TopAppBar(title = { Text( ) })\n            }\n        ) { padding ->\n            Box(Modifier.padding(padding)) { content() }\n        }\n    }\n}\n\n// Child screens access shared state via CompositionLocal\n@Screen(DemoTabs.Music::class)\n@Composable\nfun MusicScreen() {\n    val sharedStore = LocalDemoTabsStore.current\n    \n    LaunchedEffect(Unit) {\n        sharedStore.intent(DemoTabsIntent.IncrementViewed)\n    }\n    \n    // Screen content...\n}`\n\n// Lifecycle Diagram Styles\nconst lifecycleStyles = {\n  container: {\n    display:  ,\n    flexDirection:   as const,\n    alignItems:  ,\n  },\n  box: {\n    width:  var(--color-bg-elevated)  as const,\n    border:   as const,\n  },\n  boxTitle: {\n    fontWeight:   as const,\n    fontSize:  ,\n  },\n  subItems: {\n    marginTop:  ,\n    opacity: 0.8,\n    display:   as const,\n    justifyContent:  ,\n  },\n  subItem: {\n    background:  ,\n  },\n  creation: {\n    background:  rgba(34, 197, 94, 0.5) rgba(59, 130, 246, 0.08) rgba(59, 130, 246, 0.4) rgba(139, 92, 246, 0.1) rgba(139, 92, 246, 0.5) rgba(239, 68, 68, 0.1) rgba(239, 68, 68, 0.4) ,\n    flexDirection:  ,\n  }}>\n    <div style={{\n      width:  ,\n    }} />\n    <div style={{\n      width:  ,\n      borderRight:  8px solid var(--color-text-muted, #9ca3af) ))\n                navigator.navigateBack()\n            } catch (e: Exception) {\n                action(ProfileAction.ShowToast( ))\n                // Stay on screen\n            }\n        }\n    }\n}`\n\nconst sharingStateBetweenTabsCode = `// In tab wrapper - increment view count\n@TabsContainer(MainTabs::class)\n@Composable\nfun MainTabsWrapper(scope: TabsContainerScope, content: @Composable () -> Unit) {\n    val store = rememberSharedContainer<MainTabsContainer, ...>()\n    CompositionLocalProvider(LocalMainTabsStore provides store) {\n        content()\n    }\n}\n\n// In any child screen - access shared state\n@Screen(MainTabs.Home::class)\n@Composable\nfun HomeScreen() {\n    val sharedStore = LocalMainTabsStore.current\n    val sharedState by sharedStore.subscribe()\n    \n    Text( )\n}`\n\n// Koin Annotations - Container registration\nconst koinAnnotationsContainerCode = `// Screen-scoped container with annotations\n@Scoped\n@Scope(NavigationContainerScope::class)\n@Qualifier(ProfileContainer::class)\nclass ProfileContainer(\n    scope: NavigationContainerScope,\n    private val repository: ProfileRepository\n) : NavigationContainer<ProfileState, ProfileIntent, ProfileAction>(scope) {\n    override val store = store(initial = ProfileState.Loading) {\n        // Store implementation...\n    }\n}\n\n// Shared container with annotations\n@Scoped\n@Scope(SharedContainerScope::class)\n@Qualifier(DemoTabsContainer::class)\nclass DemoTabsContainer(\n    scope: SharedContainerScope\n) : SharedNavigationContainer<DemoTabsState, DemoTabsIntent, DemoTabsAction>(scope) {\n    override val store = store(DemoTabsState()) {\n        // Store implementation...\n    }\n}`\n\nconst koinAnnotationsModuleCode = `// Dependencies with annotations\n@Factory\nclass ProfileRepository {\n    suspend fun getUser(): UserData = /* ... */\n}\n\n// Module with auto-discovery\n@Module\n@ComponentScan( )\nclass ProfileModule\n\n@Module\n@ComponentScan( https://github.com/respawn-app/FlowMVI }\n        state management with navigation lifecycle, providing automatic container lifecycle management and Koin integration.\n      </p>\n\n      {/* Section 1: Overview */}\n      <section>\n        <h2 id= >Overview</h2>\n        <p>\n          This module provides a seamless integration between FlowMVI >Dependencies</h2>\n        <p>\n          Add the FlowMVI integration module to your project. This module transitively includes FlowMVI, Koin, and quo-vadis-core.\n        </p>\n        <CodeBlock code={dependencyCode} language=  />\n      </section>\n\n      {/* Section 3: MVI Contract */}\n      <section>\n        <h2 id= >MVI Contract</h2>\n        <p>\n          FlowMVI uses three main components: <strong>State</strong> (what UI displays),\n          <strong>Intent</strong> (user actions), and <strong>Action</strong> (side effects like toasts).\n        </p>\n        <CodeBlock code={contractCode} language=  />\n      </section>\n\n      {/* Section 4: Koin Setup */}\n      <section>\n        <h2 id= >Koin Module Setup</h2>\n        <p>\n          Register the <code>Navigator</code> as a singleton and your containers with Koin using the provided DSL functions.\n          Combine multiple <code>NavigationConfig</code> instances from different feature modules using the <code>+</code> operator:\n        </p>\n        <CodeBlock code={navigatorRegistrationCode} language=  />\n        <p>\n          Register your containers with the <code>navigationContainer</code> and <code>sharedNavigationContainer</code> functions:\n        </p>\n        <CodeBlock code={koinModuleCode} language=  />\n        <h3>Registration Functions</h3>\n        <ul>\n          <li><code>navigationContainer&lt;T&gt;</code> - Register a screen-scoped container</li>\n          <li><code>sharedNavigationContainer&lt;T&gt;</code> - Register a container-scoped shared container</li>\n          <li><code>navigationModule</code> - Required base module with Navigator binding</li>\n        </ul>\n      </section>\n\n      {/* Section: Koin Annotations Alternative */}\n      <section>\n        <h2 id= >Koin Annotations Approach</h2>\n        <p>\n          As an alternative to manual DSL registration, you can use <strong>Koin Annotations</strong> (4.1+)\n          for compile-time dependency resolution with less boilerplate.\n        </p>\n\n        <h3>Annotating Containers</h3>\n        <p>\n          Use <code>@Scoped</code> with the appropriate scope class to register containers:\n        </p>\n        <CodeBlock code={koinAnnotationsContainerCode} language=  />\n\n        <h3>Module with ComponentScan</h3>\n        <p>\n          Create modules that auto-discover annotated components in a package:\n        </p>\n        <CodeBlock code={koinAnnotationsModuleCode} language=  />\n\n        <h3>Choosing an Approach</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>DSL Approach</th>\n              <th>Annotations Approach</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Runtime flexibility</td>\n              <td>Compile-time safety</td>\n            </tr>\n            <tr>\n              <td>Complex factory logic</td>\n              <td>Standard patterns</td>\n            </tr>\n            <tr>\n              <td>Advanced Koin features</td>\n              <td>Minimal boilerplate</td>\n            </tr>\n          </tbody>\n        </table>\n        <p>\n          Both approaches work with <code>rememberContainer</code> and <code>rememberSharedContainer</code> – choose based on your project needs.\n        </p>\n      </section>\n\n      {/* Section 5: Screen-Scoped Containers */}\n      <section>\n        <h2 id= >Screen-Scoped Containers</h2>\n        <p>\n          <code>NavigationContainer</code> extends FlowMVI  />\n        <h3>NavigationContainerScope Properties</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>Property</th>\n              <th>Type</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>navigator</code></td>\n              <td><code>Navigator</code></td>\n              <td>For navigation operations</td>\n            </tr>\n            <tr>\n              <td><code>screenKey</code></td>\n              <td><code>String</code></td>\n              <td>Unique screen identifier</td>\n            </tr>\n            <tr>\n              <td><code>coroutineScope</code></td>\n              <td><code>CoroutineScope</code></td>\n              <td>Tied to screen lifecycle</td>\n            </tr>\n            <tr>\n              <td><code>screenNode</code></td>\n              <td><code>ScreenNode</code></td>\n              <td>Navigation node for the screen</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      {/* Section 6: Using rememberContainer */}\n      <section>\n        <h2 id= >Using rememberContainer</h2>\n        <p>\n          The <code>rememberContainer</code> composable creates or retrieves a screen-scoped container.\n          It automatically manages the container  />\n        <h3>Key Points</h3>\n        <ul>\n          <li>Container is created when the screen enters composition</li>\n          <li>Store is automatically started and subscribes to state</li>\n          <li>Actions are handled via the subscribe callback</li>\n          <li>Container is cleaned up when screen is removed from navigation</li>\n        </ul>\n      </section>\n\n      {/* Section 7: Shared Containers */}\n      <section>\n        <h2 id= >Shared Navigation Containers</h2>\n        <p>\n          <code>SharedNavigationContainer</code> provides state that persists across all screens within a Tab or Pane container.\n          This is useful for sharing data between screens without prop drilling or global state.\n        </p>\n        <CodeBlock code={sharedContainerCode} language=  />\n        <h3>SharedContainerScope Properties</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>Property</th>\n              <th>Type</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>navigator</code></td>\n              <td><code>Navigator</code></td>\n              <td>For navigation operations</td>\n            </tr>\n            <tr>\n              <td><code>containerKey</code></td>\n              <td><code>String</code></td>\n              <td>Unique container identifier</td>\n            </tr>\n            <tr>\n              <td><code>coroutineScope</code></td>\n              <td><code>CoroutineScope</code></td>\n              <td>Tied to container lifecycle</td>\n            </tr>\n            <tr>\n              <td><code>containerNode</code></td>\n              <td><code>LifecycleAwareNode</code></td>\n              <td>TabNode or PaneNode</td>\n            </tr>\n          </tbody>\n        </table>\n        <p>\n          Shared containers are perfect for:\n        </p>\n        <ul>\n          <li>Tab-wide notification badges</li>\n          <li>Master-detail selection state</li>\n          <li>Cross-screen communication</li>\n          <li>Shared preferences within a container</li>\n        </ul>\n      </section>\n\n      {/* Section 8: Using rememberSharedContainer */}\n      <section>\n        <h2 id= >Using rememberSharedContainer</h2>\n        <p>\n          The <code>rememberSharedContainer</code> composable creates or retrieves a container-scoped shared store.\n          Use it in <code>@TabsContainer</code> or <code>@PaneContainer</code> annotated composables to share state across child screens.\n        </p>\n        <CodeBlock code={rememberSharedContainerCode} language=  />\n        <h3>Key Points</h3>\n        <ul>\n          <li>Shared container lives as long as the Tab/Pane container</li>\n          <li>Use <code>CompositionLocalProvider</code> to share the store with child screens</li>\n          <li>Child screens access shared state via <code>CompositionLocal</code></li>\n          <li>State persists across tab switches within the container</li>\n        </ul>\n      </section>\n\n      {/* Section 9: Lifecycle Management */}\n      <section>\n        <h2 id= >Lifecycle Management</h2>\n        <p>\n          The FlowMVI integration automatically manages container lifecycle based on navigation state.\n          Here >Multi-Module Organization</h2>\n        <p>\n          Organize container registrations by feature module for clean separation of concerns:\n        </p>\n        <CodeBlock code={multiModuleCode} language=  />\n        <p>\n          Each feature module exports its own Koin module containing containers and \n          dependencies. The app module combines all feature modules during Koin initialization.\n        </p>\n      </section>\n\n      {/* Section 11: Common Patterns */}\n      <section>\n        <h2 id= >Common Patterns</h2>\n        <h3>Navigation from Container</h3>\n        <CodeBlock code={navigationFromContainerCode} language=  />\n\n        <h3>Conditional Navigation</h3>\n        <CodeBlock code={conditionalNavigationCode} language=  />\n\n        <h3>Sharing State Between Tabs</h3>\n        <CodeBlock code={sharingStateBetweenTabsCode} language=  />\n      </section>\n\n      {/* Section 12: Complete App Setup */}\n      <section>\n        <h2 id= >Complete App Setup</h2>\n        <p>\n          Here  />\n      </section>\n\n      {/* Section 13: Best Practices */}\n      <section>\n        <h2 id= >Best Practices</h2>\n        <DoHeading />\n        <ul>\n          <li>Keep navigation logic in containers, not UI</li>\n          <li>Use <code>NavigationContainer</code> for screen-specific state</li>\n          <li>Use <code>SharedNavigationContainer</code> for cross-screen state</li>\n          <li>Handle all errors with <code>recover</code> plugin</li>\n          <li>Use meaningful intent names describing user actions</li>\n          <li>Provide shared stores via <code>CompositionLocal</code></li>\n          <li>Register Navigator as singleton - One Navigator instance per app</li>\n          <li>Use <code>scope.get()</code> - Inject dependencies from Koin scope, not directly</li>\n          <li>Keep container factories simple - Defer complex logic to the container itself</li>\n          <li>Organize modules by feature - One Koin module per feature for maintainability</li>\n        </ul>\n        <DontHeading />\n        <ul>\n          <li>Don t create container instances manually (use <code>rememberContainer</code>)</li>\n          <li>Don s navigator)</li>\n          <li>Don t inject containers directly - Use <code>rememberContainer</code> instead</li>\n          <li>Avoid circular dependencies - Navigator should not depend on containers</li>\n        </ul>\n      </section>\n\n      {/* Section 14: Next Steps */}\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >FlowMVI Documentation</a> - Learn more about FlowMVI</li>\n          <li><Link to= >Tabbed Navigation</Link> - Use shared containers with tabs</li>\n          <li><Link to= >Modular Architecture</Link> - Structure your features</li>\n          <li><Link to= >Deep Links</Link> - Handle deep links with MVI</li>\n          <li><Link to="
  },
  {
    "id": "Features/DSLConfig/dslconfig",
    "title": "D S L Config",
    "route": "/Features/DSLConfig/dslconfig",
    "content": "\n\n// Status badge components\nconst StatusFull = ({ children =  ) {\n        screen<HomeScreen>()\n        screen<DetailScreen>()\n    }\n    \n    // Register transitions\n    transition<DetailScreen>(NavTransition.SlideHorizontal)\n    \n    // Register container wrappers\n    tabsContainer( ) { content ->\n        MyCustomTabBar(content)\n    }\n}`\n\nconst combiningConfigs = `// Feature modules provide their own configs\nval featureAConfig = navigationConfig { /* ... */ }\nval featureBConfig = navigationConfig { /* ... */ }\n\n// App module combines all configs\nval appConfig = featureAConfig + featureBConfig\n\n// Use with navigator\nval navigator = rememberQuoVadisNavigator(MainTabs::class, appConfig)\nNavigationHost(navigator)`\n\nconst screenRegistryExample = `navigationConfig {\n    // Basic screen registration\n    screen<HomeScreen> { destination, _, _ ->\n        { HomeScreenContent() }\n    }\n    \n    // With destination parameters\n    screen<ProfileScreen> { destination, _, _ ->\n        { ProfileContent(userId = destination.userId) }\n    }\n    \n    // With shared element transitions\n    screen<DetailScreen> { destination, sharedScope, animScope ->\n        {\n            DetailContent(\n                item = destination.item,\n                sharedTransitionScope = sharedScope,\n                animatedVisibilityScope = animScope\n            )\n        }\n    }\n}`\n\nconst stackExample = `navigationConfig {\n    stack<MainStack>( ) {\n        screen<HomeScreen>()\n        screen<DetailScreen>()\n        screen<SettingsScreen>()\n    }\n}`\n\nconst tabsContainerWrapper = `navigationConfig {\n    tabsContainer( ) { content ->\n        Scaffold(\n            bottomBar = {\n                NavigationBar {\n                    tabMetadata.forEachIndexed { index, meta ->\n                        NavigationBarItem(\n                            selected = activeTabIndex == index,\n                            onClick = { switchTab(index) },\n                            icon = { Icon(meta.icon, meta.label) },\n                            label = { Text(meta.label) }\n                        )\n                    }\n                }\n            }\n        ) { padding ->\n            Box(Modifier.padding(padding)) {\n                content()  // Library renders active tab content\n            }\n        }\n    }\n}`\n\nconst paneContainerWrapper = `navigationConfig {\n    paneContainer( ) { content ->\n        if (isExpanded) {\n            Row(Modifier.fillMaxSize()) {\n                paneContents.filter { it.isVisible }.forEach { pane ->\n                    val weight = when (pane.role) {\n                        PaneRole.Primary -> 0.4f\n                        PaneRole.Supporting -> 0.6f\n                        PaneRole.Extra -> 0.25f\n                    }\n                    Box(Modifier.weight(weight).fillMaxHeight()) {\n                        pane.content()\n                    }\n                }\n            }\n        } else {\n            content()  // Single pane mode\n        }\n    }\n}`\n\nconst transitionsExample = `navigationConfig {\n    transition<DetailScreen>(NavTransition.SlideHorizontal)\n    transition<ModalScreen>(NavTransition.SlideVertical)\n    transition<SettingsScreen>(NavTransition.Fade)\n    transition<QuickViewScreen>(NavTransition.ScaleIn)\n}`\n\nconst customTransition = `val myTransition = NavTransition(\n    enter = fadeIn() + expandHorizontally(),\n    exit = fadeOut() + shrinkHorizontally(),\n    popEnter = fadeIn() + expandHorizontally(expandFrom = Alignment.End),\n    popExit = fadeOut() + shrinkHorizontally(shrinkTowards = Alignment.End)\n)\n\nnavigationConfig {\n    transition<MyScreen>(myTransition)\n}`\n\nconst scopeExample = `navigationConfig {\n    // Explicit scope definition\n    scope( ) {\n        +HomeScreen::class\n        +SearchScreen::class\n        +ProfileScreen::class\n        +SettingsScreen::class\n    }\n    \n    // Alternative using include\n    scope( ) {\n        include(ProfileScreen::class)\n        include(EditProfileScreen::class)\n        include(ProfileSettingsScreen::class)\n    }\n}`\n\nconst autoScopeExample = `navigationConfig {\n    // This automatically registers   scope with all listed screens\n    stack<MainStack>( ) {\n        screen<HomeScreen>()\n        screen<DetailScreen>()\n    }\n    \n    // This automatically registers   scope with all tab destinations\n    tabs<MainTabs>( ) {\n        tab(HomeTab, title =  )\n        tab(ProfileTab, title =  )\n    }\n}`\n\nconst completeExample = `val appNavigationConfig = navigationConfig {\n    \n    // ═══════════════════════════════════════════════════════\n    // SCREEN REGISTRATIONS\n    // ═══════════════════════════════════════════════════════\n    \n    screen<HomeScreen> { destination, _, _ ->\n        { HomeContent() }\n    }\n    \n    screen<ProfileScreen> { destination, _, _ ->\n        { ProfileContent(userId = destination.userId) }\n    }\n    \n    screen<DetailScreen> { destination, sharedScope, animScope ->\n        {\n            DetailContent(\n                itemId = destination.itemId,\n                sharedTransitionScope = sharedScope,\n                animatedVisibilityScope = animScope\n            )\n        }\n    }\n    \n    // ═══════════════════════════════════════════════════════\n    // TAB CONTAINER\n    // ═══════════════════════════════════════════════════════\n    \n    tabs<MainTabs>( ) {\n        initialTab = 0\n        \n        tab(HomeTab, title =  , icon = Icons.Default.Home) {\n            screen<HomeScreen>()\n            screen<DetailScreen>()\n        }\n        \n        tab(SearchTab, title =  , icon = Icons.Default.Search)\n        \n        tab(ProfileTab, title =  , icon = Icons.Default.Person) {\n            screen<ProfileScreen>()\n            screen<EditProfileScreen>()\n        }\n    }\n    \n    // ═══════════════════════════════════════════════════════\n    // PANE CONTAINER (Master-Detail)\n    // ═══════════════════════════════════════════════════════\n    \n    panes<MessagesPanes>( ) {\n        initialPane = PaneRole.Primary\n        backBehavior = PaneBackBehavior.PopUntilScaffoldValueChange\n        \n        primary(weight = 0.35f, minWidth = 280.dp) {\n            root(ConversationListScreen)\n            alwaysVisible()\n        }\n        \n        secondary(weight = 0.65f, minWidth = 400.dp) {\n            root(ConversationDetailPlaceholder)\n        }\n    }\n    \n    // ═══════════════════════════════════════════════════════\n    // TRANSITIONS\n    // ═══════════════════════════════════════════════════════\n    \n    transition<DetailScreen>(NavTransition.SlideHorizontal)\n    transition<ModalScreen>(NavTransition.SlideVertical)\n    transition<SettingsScreen>(NavTransition.Fade)\n    \n    // ═══════════════════════════════════════════════════════\n    // CONTAINER WRAPPERS\n    // ═══════════════════════════════════════════════════════\n    \n    tabsContainer( ) { content ->\n        Column {\n            Box(Modifier.weight(1f).fillMaxWidth()) {\n                content()\n            }\n            NavigationBar {\n                tabMetadata.forEachIndexed { index, meta ->\n                    NavigationBarItem(\n                        selected = activeTabIndex == index,\n                        onClick = { switchTab(index) },\n                        icon = { \n                            Icon(\n                                imageVector = meta.icon ?: Icons.Default.Circle,\n                                contentDescription = meta.label\n                            )\n                        },\n                        label = { Text(meta.label) },\n                        enabled = !isTransitioning\n                    )\n                }\n            }\n        }\n    }\n    \n    paneContainer( ) { content ->\n        if (isExpanded) {\n            Row(Modifier.fillMaxSize()) {\n                paneContents.filter { it.isVisible }.forEach { pane ->\n                    val weight = when (pane.role) {\n                        PaneRole.Primary -> 0.35f\n                        PaneRole.Supporting -> 0.65f\n                        PaneRole.Extra -> 0.25f\n                    }\n                    Box(Modifier.weight(weight).fillMaxHeight()) {\n                        pane.content()\n                    }\n                }\n            }\n        } else {\n            content()\n        }\n    }\n    \n    // ═══════════════════════════════════════════════════════\n    // ADDITIONAL SCOPES\n    // ═══════════════════════════════════════════════════════\n    \n    scope( >Overview</h2>\n        <p>\n          Quo Vadis supports two configuration approaches. Choose the one that best fits your project needs:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Approach</th>\n              <th>Best For</th>\n              <th>Characteristics</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><strong>Annotations</strong></td>\n              <td>Most projects</td>\n              <td>Declarative, compile-time safety, KSP generates config</td>\n            </tr>\n            <tr>\n              <td><strong>DSL</strong></td>\n              <td>Dynamic setups</td>\n              <td>Runtime flexibility, manual control, no code generation</td>\n            </tr>\n          </tbody>\n        </table>\n\n        <h3>When to Choose DSL Configuration</h3>\n        <p>Use the DSL approach when you need:</p>\n        <ul>\n          <li><strong>Dynamic navigation graphs</strong> that change based on user state or feature flags</li>\n          <li><strong>Multi-module composition</strong> where modules provide their own navigation config</li>\n          <li><strong>Testing flexibility</strong> with customizable navigation setups</li>\n          <li><strong>Full control</strong> over registration without annotation processing</li>\n          <li><strong>Hybrid setups</strong> combining generated and manual configurations</li>\n        </ul>\n\n        <h3>Key Components</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>Component</th>\n              <th>Purpose</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>NavigationConfig</code></td>\n              <td>Unified configuration object containing all registries</td>\n            </tr>\n            <tr>\n              <td><code>ScreenRegistry</code></td>\n              <td>Maps destinations to composable content</td>\n            </tr>\n            <tr>\n              <td><code>ContainerRegistry</code></td>\n              <td>Provides container structures and wrapper composables</td>\n            </tr>\n            <tr>\n              <td><code>TransitionRegistry</code></td>\n              <td>Maps destinations to custom transitions</td>\n            </tr>\n            <tr>\n              <td><code>ScopeRegistry</code></td>\n              <td>Defines navigation scope membership</td>\n            </tr>\n            <tr>\n              <td><code>RouteRegistry</code></td>\n              <td>Maps routes to destination classes</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >NavigationConfig</h2>\n        <p>\n          <code>NavigationConfig</code> is the central configuration interface that aggregates all navigation\n          registries. It provides a unified contract for the navigation system.\n        </p>\n\n        <h3>Interface Structure</h3>\n        <CodeBlock code={navigationConfigInterface} language=  />\n\n        <h3>Creating Configuration with DSL</h3>\n        <p>\n          Use the <code>navigationConfig</code> builder function to create a complete configuration:\n        </p>\n        <CodeBlock code={basicConfigExample} language=  />\n\n        <h3>Combining Configurations</h3>\n        <p>\n          Configurations can be combined using the <code>+</code> operator for multi-module setups:\n        </p>\n        <CodeBlock code={combiningConfigs} language= >Screen Registry</h2>\n        <p>\n          The <code>ScreenRegistry</code> maps navigation destinations to their composable content.\n          Use the <code>screen&lt;D&gt;</code> function in the configuration builder:\n        </p>\n        <CodeBlock code={screenRegistryExample} language=  />\n\n        <h3>Content Lambda Parameters</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>Parameter</th>\n              <th>Type</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>destination</code></td>\n              <td><code>D</code></td>\n              <td>The destination instance with navigation arguments</td>\n            </tr>\n            <tr>\n              <td><code>sharedTransitionScope</code></td>\n              <td><code>SharedTransitionScope?</code></td>\n              <td>Scope for shared element transitions</td>\n            </tr>\n            <tr>\n              <td><code>animatedVisibilityScope</code></td>\n              <td><code>AnimatedVisibilityScope?</code></td>\n              <td>Scope for coordinated animations</td>\n            </tr>\n          </tbody>\n        </table>\n        <p>\n          The lambda returns a <code>@Composable () -&gt; Unit</code> that renders the screen content.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Container Registry</h2>\n        <p>\n          The <code>ContainerRegistry</code> handles two responsibilities: building container structures\n          and rendering custom wrapper UIs around navigation content.\n        </p>\n\n        <h3>Stack Registration</h3>\n        <p>Register linear navigation stacks:</p>\n        <CodeBlock code={stackExample} language=  />\n\n        <h3>Tab Registration</h3>\n        <p>Register tab-based navigation with the <code>tabs&lt;D&gt;</code> builder:</p>\n        <CodeBlock code={tabsAnnotationDSL} language=  />\n\n        <h3>Pane Registration</h3>\n        <p>Register adaptive multi-pane layouts:</p>\n        <CodeBlock code={panesAnnotationDSL} language=  />\n\n        <h3>Container Wrappers</h3>\n        <p>\n          Register custom UI wrappers for tab containers. The wrapper receives the active tab content\n          and can customize the surrounding UI:\n        </p>\n        <CodeBlock code={tabsContainerWrapper} language=  />\n\n        <ScopePropertiesTable scopeType= >Tabbed Navigation</Link> for complete\n            tab configuration patterns and advanced examples.\n          </p>\n        </div>\n\n        <p>Register custom pane layout wrappers:</p>\n        <CodeBlock code={paneContainerWrapper} language=  />\n\n        <ScopePropertiesTable scopeType= >Pane Layouts</Link> for comprehensive\n            adaptive layout patterns.\n          </p>\n        </div>\n      </section>\n\n      <section>\n        <h2 id= >Transition Registry</h2>\n        <p>\n          The <code>TransitionRegistry</code> maps destinations to custom transition animations:\n        </p>\n        <CodeBlock code={transitionsExample} language=  />\n\n        <h3>Preset Transitions</h3>\n        <TransitionTypesDisplay variant= }\n            <Link to= >Transitions & Animations</Link>.\n          </p>\n        </div>\n\n        <h3>Custom Transitions</h3>\n        <p>Create custom transitions by combining Compose animation primitives:</p>\n        <CodeBlock code={customTransition} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Scope Registry</h2>\n        <p>\n          The <code>ScopeRegistry</code> determines navigation scope membership, controlling whether\n          destinations stay within containers or navigate outside.\n        </p>\n        <p>\n          When navigating from within a tab or pane container:\n        </p>\n        <ul>\n          <li><strong>In scope:</strong> Destination belongs to this container → navigate within</li>\n          <li><strong>Out of scope:</strong> Destination is external → navigate to parent stack</li>\n        </ul>\n\n        <h3>Defining Scopes</h3>\n        <CodeBlock code={scopeExample} language=  />\n\n        <h3>Automatic Scope Registration</h3>\n        <p>\n          When using <code>stack</code>, <code>tabs</code>, or <code>panes</code> builders, scopes are automatically registered:\n        </p>\n        <CodeBlock code={autoScopeExample} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Complete Example</h2>\n        <p>\n          Here  />\n\n        <h3>Using the Configuration</h3>\n        <CodeBlock code={usingConfig} language=  />\n      </section>\n\n      <section>\n        <h2 id= >DSL vs Annotations</h2>\n        <table>\n          <thead>\n            <tr>\n              <th>Feature</th>\n              <th>DSL</th>\n              <th>Annotations</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Runtime flexibility</td>\n              <td><StatusFull>Full control</StatusFull></td>\n              <td><StatusNo>Compile-time only</StatusNo></td>\n            </tr>\n            <tr>\n              <td>Code generation</td>\n              <td><StatusNo>None needed</StatusNo></td>\n              <td><StatusFull>KSP generates</StatusFull></td>\n            </tr>\n            <tr>\n              <td>Type safety</td>\n              <td><StatusFull>Compile-time</StatusFull></td>\n              <td><StatusFull>Compile-time</StatusFull></td>\n            </tr>\n            <tr>\n              <td>Boilerplate</td>\n              <td>Medium</td>\n              <td>Low</td>\n            </tr>\n            <tr>\n              <td>Dynamic graphs</td>\n              <td><StatusFull>Supported</StatusFull></td>\n              <td><StatusNo>Not supported</StatusNo></td>\n            </tr>\n            <tr>\n              <td>Multi-module</td>\n              <td><StatusFull>Manual</StatusFull></td>\n              <td><StatusFull>Auto-merged</StatusFull></td>\n            </tr>\n            <tr>\n              <td>Learning curve</td>\n              <td>Medium</td>\n              <td>Low</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Hybrid Approach</h2>\n        <p>\n          You can combine generated config with manual DSL additions for dynamic features\n          like feature flags:\n        </p>\n        <CodeBlock code={hybridExample} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Best Practices</h2>\n        <ul>\n          <li><strong>Use descriptive scope keys</strong> – Name scopes after their containers (e.g., <code> </code>)</li>\n          <li><strong>Register all screens</strong> – Every destination that can be navigated to needs a screen registration</li>\n          <li><strong>Match container and wrapper keys</strong> – Use the same key for container and wrapper registration</li>\n          <li><strong>Leverage automatic scope registration</strong> – Let <code>stack</code>/<code>tabs</code>/<code>panes</code> builders handle scope membership</li>\n          <li><strong>Test with <code>NavigationConfig.Empty</code></strong> – Use as baseline in tests to isolate behavior</li>\n          <li><strong>Compose configs in app module</strong> – Feature modules export configs, app module combines them</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><Link to= >Annotation-Based API</Link> – Declarative approach with code generation</li>\n          <li><Link to= >Transitions & Animations</Link> – Animation configuration in depth</li>\n          <li><Link to= >Tabbed Navigation</Link> – Tab-based navigation patterns</li>\n          <li><Link to="
  },
  {
    "id": "Features/DeepLinks/deeplinks",
    "title": "Deep Links",
    "route": "/Features/DeepLinks/deeplinks",
    "content": "\n\nconst definingRoutesCode = `@Stack(name =  , startDestination = Feed::class)\nsealed class HomeDestination : NavDestination {\n\n    @Destination(route =  )\n    data object Feed : HomeDestination()\n\n    // Path parameters\n    @Destination(route =  )\n    data class Article(\n        @Argument val articleId: String\n    ) : HomeDestination()\n\n    // Multiple path parameters\n    @Destination(route =  )\n    data class UserPost(\n        @Argument val userId: String,\n        @Argument val postId: String\n    ) : HomeDestination()\n\n    // Query parameters\n    @Destination(route =  )\n    data class Search(\n        @Argument val query: String,\n        @Argument(optional = true) val page: Int = 1,\n        @Argument(optional = true) val sortAsc: Boolean = true\n    ) : HomeDestination()\n}`\n\nconst argumentAnnotationCode = `@Destination(route =  )\ndata class Detail(\n    @Argument val id: String,                    // Required, maps to {id}\n    @Argument(key =  ) val referrer: String? = null,  // Custom key\n    @Argument(optional = true) val showReviews: Boolean = false  // Optional\n) : ProductsDestination()\n\n// Deep link: app://products/detail/123?ref=home&showReviews=true`\n\nconst handlingDeepLinksCode = `// Handle incoming URI string\nval handled = navigator.handleDeepLink( )\n\nif (!handled) {\n    showError( )\n}\n\n// Using DeepLink object\nval deepLink = DeepLink.parse( )\nnavigator.handleDeepLink(deepLink)`\n\nconst runtimeRegistrationCode = `@Composable\nfun MyScreen() {\n    LaunchedEffect(Unit) {\n        navigator.getDeepLinkRegistry().register( ) { params ->\n            PromoDestination(code = params[ ]!!)\n        }\n    }\n}\n\n// Now   navigates to PromoDestination( )`\n\nconst androidManifestCode = `<!-- AndroidManifest.xml -->\n<activity ...>\n    <intent-filter android:autoVerify= >\n        <action android:name=  />\n        <category android:name=  />\n        <category android:name=  />\n        <data android:scheme=  />\n        <data android:scheme= >Defining Deep Link Routes</h2>\n        <p>\n          Define deep link routes using the <code>route</code> parameter in your{ }\n          <code>@Destination</code> annotations. Path parameters are enclosed in curly \n          braces and automatically extracted during navigation.\n        </p>\n        <CodeBlock code={definingRoutesCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Route Pattern Syntax</h2>\n        <p>\n          Quo Vadis supports flexible route patterns for matching incoming deep links:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Pattern</th>\n              <th>Example</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Static</td>\n              <td><code> </code></td>\n              <td>Exact match</td>\n            </tr>\n            <tr>\n              <td>Path parameter</td>\n              <td><code> </code></td>\n              <td>Extracts value from path</td>\n            </tr>\n            <tr>\n              <td>Multiple params</td>\n              <td><code> </code></td>\n              <td>Multiple path segments</td>\n            </tr>\n            <tr>\n              <td>Query params</td>\n              <td><code> </code></td>\n              <td>Query string parameters</td>\n            </tr>\n            <tr>\n              <td>Optional</td>\n              <td>(with <code>@Argument(optional = true)</code>)</td>\n              <td>Can be omitted</td>\n            </tr>\n            <tr>\n              <td>Not deep-linkable</td>\n              <td>(empty route)</td>\n              <td>Internal destination only</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >@Argument for Deep Links</h2>\n        <p>\n          The <code>@Argument</code> annotation configures how parameters are extracted \n          from deep links and serialized for navigation state.\n        </p>\n        <CodeBlock code={argumentAnnotationCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Supported Argument Types</h2>\n        <p>\n          Quo Vadis automatically handles serialization and deserialization for common types:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Type</th>\n              <th>Serialization</th>\n              <th>Notes</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>String</code></td>\n              <td>Direct</td>\n              <td>No conversion</td>\n            </tr>\n            <tr>\n              <td><code>Int</code>, <code>Long</code>, <code>Float</code>, <code>Double</code></td>\n              <td><code>.toString()</code> / <code>.toXxx()</code></td>\n              <td>Numeric conversion</td>\n            </tr>\n            <tr>\n              <td><code>Boolean</code></td>\n              <td><code> </code></td>\n              <td>Case-insensitive</td>\n            </tr>\n            <tr>\n              <td><code>Enum&lt;T&gt;</code></td>\n              <td><code>.name</code> / <code>enumValueOf()</code></td>\n              <td>Enum name</td>\n            </tr>\n            <tr>\n              <td><code>@Serializable</code></td>\n              <td>JSON</td>\n              <td>kotlinx.serialization</td>\n            </tr>\n            <tr>\n              <td><code>List&lt;T&gt;</code>, <code>Set&lt;T&gt;</code></td>\n              <td>JSON</td>\n              <td>Where T is serializable</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Handling Deep Links</h2>\n        <p>\n          Process incoming deep links using the navigator  />\n      </section>\n\n      <section>\n        <h2 id= >Runtime Pattern Registration</h2>\n        <p>\n          Register additional deep link patterns at runtime for dynamic routing scenarios \n          like promotional campaigns or A/B testing.\n        </p>\n        <CodeBlock code={runtimeRegistrationCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Android Deep Link Setup</h2>\n        <p>\n          Configure intent filters in your Android manifest to handle incoming deep links:\n        </p>\n        <CodeBlock code={androidManifestCode} language=  />\n        <p>Handle the incoming intent in your Activity:</p>\n        <CodeBlock code={androidActivityCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >iOS Universal Links</h2>\n        <p>\n          Handle universal links in your iOS app  />\n      </section>\n\n      <section>\n        <h2 id= >Web Browser History</h2>\n        <p>\n          On web targets, enable browser URL synchronization to keep the address bar \n          in sync with navigation state:\n        </p>\n        <CodeBlock code={webBrowserHistoryCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >DeepLinkRegistry Interface</h2>\n        <p>\n          The <code>DeepLinkRegistry</code> provides programmatic control over deep link \n          pattern registration:\n        </p>\n        <CodeBlock code={deepLinkRegistryCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Best Practices</h2>\n        <ul>\n          <li><strong>Consistent route naming:</strong> Use <code>feature/action/{ }</code> pattern</li>\n          <li><strong>Required vs optional:</strong> Make navigation-critical params required, UI-only params optional</li>\n          <li><strong>Test thoroughly:</strong> Test deep links with various parameter combinations</li>\n          <li><strong>Handle gracefully:</strong> Always handle invalid or unknown deep links with appropriate fallbacks</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><Link to= >Multiplatform Support</Link> - Deep links on all platforms</li>\n          <li><Link to= >Type Safety</Link> - Type-safe argument handling</li>\n          <li><Link to="
  },
  {
    "id": "Features/features",
    "title": "Features",
    "route": "/Features/features",
    "content": "\n\nconst annotationExample = `// 1. Define your graph with annotations\n@Graph( )\nsealed class ShopDestination : Destination\n\n// 2. Add destinations with routes\n@Route( )\ndata object ProductList : ShopDestination()\n\n// 3. Add typed destinations with arguments\n@Serializable\ndata class ProductData(val productId: String, val mode: String =  )\n@Argument(ProductData::class)\ndata class ProductDetail(\n    val productId: String,\n    val mode: String =  \n) : ShopDestination(), TypedDestination<ProductData> {\n    override val data = ProductData(productId, mode)\n}\n\n// 4. Define content with @Content annotation\n@Content(ProductList::class)\n@Composable\nfun ProductListContent(navigator: Navigator) {\n    ProductListScreen(\n        onProductClick = { id ->\n            // Type-safe navigation with generated extension\n            navigator.navigateToProductDetail(\n                productId = id,\n                mode =  \n            )\n        }\n    )\n}\n\n@Content(ProductDetail::class)\n@Composable\nfun ProductDetailContent(data: ProductData, navigator: Navigator) {\n    ProductDetailScreen(\n        productId = data.productId,\n        mode = data.mode,\n        onBack = { navigator.navigateBack() }\n    )\n}\n\n// 5. Use generated graph builder\nval shopGraph = buildShopDestinationGraph()\n\n// That )\nsealed class FeatureDestination : Destination\n\n@Route( )\ndata object List : FeatureDestination()\n\n@Serializable\ndata class DetailData(val id: String, val mode: ViewMode = ViewMode.READ)\n\n@Route( )\n@Argument(DetailData::class)\ndata class Details(val id: String, val mode: ViewMode = ViewMode.READ) \n    : FeatureDestination(), TypedDestination<DetailData> {\n    override val data = DetailData(id, mode)\n}\n\n// Navigate with generated extension\nnavigator.navigateToDetails(id =  , mode = ViewMode.EDIT)`\n\nconst typeSafeManualCode = `// Define destinations manually\nsealed class FeatureDestination : Destination {\n    object List : FeatureDestination() {\n        override val route =  \n    }\n    \n    data class Details(\n        val id: String,\n        val mode: ViewMode = ViewMode.READ\n    ) : FeatureDestination() {\n        override val route =  \n        override val arguments = mapOf(\n              to mode.name\n        )\n    }\n}\n\n// Navigate with destination instance\nnavigator.navigate(FeatureDestination.Details( , ViewMode.EDIT))`\n\nconst stackManagementCode = `// Access current NavNode tree state\nval navState = navigator.state.value\n\n// Pop from active stack\nnavigator.navigateBack()\n\n// Clear to specific destination using TreeMutator\nval newState = TreeMutator.clearAndPush(navState, HomeDestination)\nnavigator.updateState(newState)\n\n// Navigate and replace current screen\nnavigator.navigateAndReplace(NewDestination)\n\n// Clear everything and start fresh\nnavigator.navigateAndClearAll(StartDestination)\n\n// Switch active tab (for TabNode)\nval tabState = TreeMutator.switchActiveTab(navState, newIndex = 1)\nnavigator.updateState(tabState)`\n\nconst deepLinkCode = `val graph = navigationGraph( ) {\n    // Simple path\n    deepLink( ) {\n        HomeDestination\n    }\n    \n    // Path parameters\n    deepLink( ) { args ->\n        UserDestination(userId = args[ ] as String)\n    }\n    \n    // Query parameters\n    deepLink( ) { args ->\n        SearchDestination(query = args[ ] as String)\n    }\n    \n    // Optional parameters\n    deepLink( ) { args ->\n        SettingsDestination(section = args[ ] as? String)\n    }\n}`\n\nconst predictiveBackCode = `NavigationHost(\n    navigator = navigator,\n    screenRegistry = MainScreenRegistry,\n    predictiveBackMode = PredictiveBackMode.FULL_CASCADE\n)`\n\nconst sharedElementCode = `// Define shared element configuration\nval imageConfig = SharedElementConfig(\n    key =  ,\n    type = SharedElementType.Bounds\n)\n\n// Source screen\nImage(\n    modifier = Modifier.sharedElement(\n        sharedConfig = imageConfig,\n        navigator = navigator\n    )\n)\n\n// Destination screen (same key!)\nImage(\n    modifier = Modifier.sharedElement(\n        sharedConfig = imageConfig,\n        navigator = navigator\n    )\n)`\n\nconst customTransitionCode = `val customTransition = NavigationTransition(\n    enter = slideInVertically { it } + fadeIn(),\n    exit = slideOutVertically { -it / 2 } + fadeOut(),\n    popEnter = slideInVertically { -it / 2 } + fadeIn(),\n    popExit = slideOutVertically { it } + fadeOut()\n)`\n\nconst testingCode = `@Test\nfun \\`navigates to details when item clicked\\`() {\n    // Arrange\n    val navigator = FakeNavigator()\n    val viewModel = ProductListViewModel(navigator)\n    \n    // Act\n    viewModel.onProductClicked( )\n    \n    // Assert\n    assertEquals(\n        ProductDestination.Details( ),\n        navigator.lastDestination\n    )\n}\n\n@Test\nfun \\`clears navigation stack on logout\\`() {\n    // Arrange\n    val navigator = FakeNavigator()\n    val viewModel = SettingsViewModel(navigator)\n    \n    // Act\n    viewModel.onLogout()\n    \n    // Assert\n    assertTrue(navigator.stackCleared)\n    assertEquals(LoginDestination, navigator.lastDestination)\n}`\n\nconst modularCode = `// Feature exposes navigation graph\nobject ProfileFeature {\n    fun navigationGraph(): NavigationGraph = navigationGraph( ) {\n        startDestination(ProfileDestination.List)\n        \n        destination(ProfileDestination.List) { _, nav -> ... }\n        destination(ProfileDestination.Details) { _, nav -> ... }\n    }\n    \n    // Public entry points\n    val entryPoint: Destination = ProfileDestination.List\n}\n\n// Main app integrates feature\nval mainGraph = navigationGraph( ) {\n    includeGraph(ProfileFeature.navigationGraph())\n    \n    // Navigate to feature\n    navigator.navigate(ProfileFeature.entryPoint)\n}`\n\nconst koinCode = `// Define content with DI\n@Content(HomeDestination::class)\n@Composable\nfun HomeContent(navigator: Navigator) {\n    val viewModel: HomeViewModel = koinInject()\n    HomeScreen(viewModel, navigator)\n}\n\n// Use NavigationHost with generated registry\nNavigationHost(\n    navigator = navigator,\n    screenRegistry = AppScreenRegistry\n)`\n\nconst customInjectionCode = `// Create custom destination factory\ninterface DestinationFactory {\n    @Composable\n    fun create(destination: Destination, navigator: Navigator)\n}\n\n// Use in navigation graph\nval graph = navigationGraph( >Getting Started - Alternative Approach</Link>.\n        </div>\n      </section>\n\n      <section>\n        <h2 id= >Type-Safe Navigation</h2>\n        <p>\n          Quo Vadis eliminates string-based routing entirely, providing compile-time safety \n          for all navigation operations through two approaches: the annotation-based API (recommended) \n          and the manual DSL (for advanced use cases).\n        </p>\n\n        <h3>Benefits</h3>\n        <ul>\n          <li><strong>Compile-time Safety:</strong> Catch navigation errors at compile time with sealed classes</li>\n          <li><strong>IDE Support:</strong> Full autocompletion and refactoring for both approaches</li>\n          <li><strong>Type-safe Arguments:</strong> Pass complex data types, not just strings</li>\n          <li><strong>Two Approaches:</strong> Use annotations (recommended) or manual DSL (advanced)</li>\n        </ul>\n\n        <h3>Annotation-Based Approach (Recommended)</h3>\n        <CodeBlock code={typeSafeAnnotationCode} language=  />\n\n        <h3>Manual DSL Approach</h3>\n        <CodeBlock code={typeSafeManualCode} language=  />\n\n        <p>\n          Both approaches provide complete type safety and work seamlessly together. \n          The annotation-based approach requires less code and generates helpful extensions,\n          while the manual DSL offers more control for complex scenarios.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Multiplatform Support</h2>\n        <p>\n          Truly multiplatform navigation that works identically across all supported platforms.\n          Write your navigation logic once and deploy everywhere.\n        </p>\n\n        <PlatformSupportGrid variant= }\n          <Link to= >Multiplatform page</Link> for \n          platform-specific setup, requirements, and feature matrix.\n        </div>\n      </section>\n\n      <section>\n        <h2 id= >Stack Management (NavNode Tree)</h2>\n        <p>\n          Quo Vadis uses an immutable NavNode tree to represent navigation state. \n          All state mutations are performed through TreeMutator operations, providing \n          predictable and testable navigation behavior.\n        </p>\n\n        <h3>Operations</h3>\n        <CodeBlock code={stackManagementCode} language=  />\n\n        <h3>Use Cases</h3>\n        <ul>\n          <li>Multi-step wizards with immutable state transformations</li>\n          <li>Authentication flows that clear navigation stacks</li>\n          <li>Tab-based navigation with independent TabNode children</li>\n          <li>State restoration via NavNode serialization</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Deep Link Support</h2>\n        <p>\n          Comprehensive deep linking system that works across all platforms. Define URL \n          patterns and automatically map them to type-safe destinations.\n        </p>\n\n        <h3>Pattern Matching</h3>\n        <CodeBlock code={deepLinkCode} language=  />\n\n        <h3>Platform Integration</h3>\n        <ul>\n          <li><strong>Android:</strong> Intent filters and App Links</li>\n          <li><strong>iOS:</strong> Universal Links and custom URL schemes</li>\n          <li><strong>Web:</strong> Direct URL navigation</li>\n          <li><strong>Desktop:</strong> Custom protocol handlers</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Predictive Back Navigation</h2>\n        <p>\n          Modern, gesture-driven back navigation with smooth animations. Users can preview \n          the previous screen before committing to navigation. Built into NavigationHost \n          via the <code>predictiveBackMode</code> parameter.\n        </p>\n\n        <h3>Supported Platforms</h3>\n        <ul>\n          <li><strong>Android 13+:</strong> System predictive back API</li>\n          <li><strong>iOS:</strong> Interactive pop gesture</li>\n          <li><strong>Custom Implementations:</strong> Desktop and Web</li>\n        </ul>\n\n        <h3>Features</h3>\n        <ul>\n          <li>Smooth, interruptible animations</li>\n          <li>Cross-fade between screens</li>\n          <li>Scale and position transitions</li>\n          <li>Cancelable gestures</li>\n          <li>Cascade pop support for TabNode structures</li>\n        </ul>\n\n        <CodeBlock code={predictiveBackCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Shared Element Transitions</h2>\n        <p>\n          Material Design 3 shared element transitions with full bidirectional support. \n          Create stunning visual continuity between screens.\n        </p>\n\n        <h3>Key Features</h3>\n        <ul>\n          <li><strong>Bidirectional:</strong> Works for both forward and back navigation</li>\n          <li><strong>Type-Safe:</strong> Compile-time verified shared element keys</li>\n          <li><strong>Flexible:</strong> Bounds, content, or both transitions</li>\n          <li><strong>Platform-Aware:</strong> Native behavior on each platform</li>\n        </ul>\n\n        <h3>Example</h3>\n        <CodeBlock code={sharedElementCode} language=  />\n\n        <h3>Transition Types</h3>\n        <ul>\n          <li><strong>Bounds:</strong> Animate position and size</li>\n          <li><strong>Content:</strong> Cross-fade content</li>\n          <li><strong>Both:</strong> Animate bounds and content together</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >MVI Architecture Support</h2>\n        <p>\n          First-class integration with MVI (Model-View-Intent) architecture pattern through \n          the <strong>quo-vadis-core-flow-mvi</strong> module. Navigation is treated as a \n          side effect of business logic, keeping your UI clean and testable.\n        </p>\n\n        <h3>Key Benefits</h3>\n        <ul>\n          <li><strong>Testable:</strong> Test navigation logic without UI using FakeNavigator</li>\n          <li><strong>Predictable:</strong> Navigation as pure side effect of state changes</li>\n          <li><strong>Centralized:</strong> All navigation logic in one place (Container)</li>\n          <li><strong>Decoupled:</strong> UI doesn /features/di-integration >Transitions & Animations</h2>\n        <p>\n          Rich set of built-in transitions and support for custom animations. \n          Create polished, professional navigation experiences.\n        </p>\n\n        <h3>Built-in Transitions</h3>\n        <TransitionTypesDisplay variant= }\n          <Link to= >Transitions page</Link> for custom \n          transitions, per-destination configuration, and animation details.\n        </div>\n\n        <h3>Custom Transitions</h3>\n        <CodeBlock code={customTransitionCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Testing Support</h2>\n        <p>\n          Built-in testing utilities make it easy to verify navigation behavior without \n          UI testing. Test navigation logic in fast, reliable unit tests.\n        </p>\n\n        <h3>FakeNavigator</h3>\n        <CodeBlock code={testingCode} language= }\n          <Link to= >Testing page</Link> for comprehensive \n          FakeNavigator usage, integration testing, and state verification.\n        </div>\n      </section>\n\n      <section>\n        <h2 id= >Modular Architecture</h2>\n        <p>\n          Gray box pattern support enables true modular architecture. Features can \n          define their own navigation graphs and expose public entry points.\n        </p>\n\n        <h3>Feature Module Example</h3>\n        <CodeBlock code={modularCode} language=  />\n\n        <h3>Benefits</h3>\n        <ul>\n          <li>Independent feature development</li>\n          <li>Clear module boundaries</li>\n          <li>Reusable feature modules</li>\n          <li>Easier testing and maintenance</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >DI Framework Integration</h2>\n        <p>\n          Easy integration with popular DI frameworks like Koin, Kodein, and others. \n          Inject dependencies into destination composables seamlessly.\n        </p>\n\n        <h3>Koin Example</h3>\n        <CodeBlock code={koinCode} language=  />\n\n        <h3>Custom Injection</h3>\n        <CodeBlock code={customInjectionCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Performance</h2>\n        <p>\n          Optimized for performance with minimal overhead. Lazy initialization, \n          efficient state management, and smart recomposition.\n        </p>\n\n        <h3>Optimizations</h3>\n        <ul>\n          <li><strong>Lazy Loading:</strong> Destinations created only when needed</li>\n          <li><strong>Efficient State:</strong> StateFlow with structural sharing</li>\n          <li><strong>Smart Recomposition:</strong> Minimal recomposition on navigation</li>\n          <li><strong>No Reflection:</strong> Zero runtime reflection overhead</li>\n          <li><strong>Small Footprint:</strong> No external dependencies</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >No External Dependencies</h2>\n        <p>\n          Quo Vadis is completely self-contained with zero external navigation dependencies. \n          This means:\n        </p>\n        <ul>\n          <li>Smaller app size</li>\n          <li>No version conflicts</li>\n          <li>No dependency chain issues</li>\n          <li>Full control over updates</li>\n          <li>Better long-term stability</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><Link to= >Get started</Link> with the quick start guide</li>\n          <li><Link to= >See the demo</Link> to explore features in action</li>\n          <li><a href= >Browse API docs</a> for detailed reference</li>\n          <li><a href="
  },
  {
    "id": "Features/Modular/modular",
    "title": "Modular",
    "route": "/Features/Modular/modular",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css   // Generates Feature1NavigationConfig\n}\n\n// feature2/build.gradle.kts\nquoVadis {\n    modulePrefix =    // Generates Feature2NavigationConfig\n}`\n\nconst combiningConfigsCode = `// app/src/commonMain/kotlin/DI.kt\nval navigationModule = module {\n    single<NavigationConfig> {\n        AppNavigationConfig +      // App module screens\n            Feature1NavigationConfig +  // Feature 1 module\n            Feature2NavigationConfig    // Feature 2 module\n    }\n    \n    single<Navigator> {\n        val config = get<NavigationConfig>()\n        val initialState = config.buildNavNode(MainTabs::class, null)!!\n        TreeNavigator(config = config, initialState = initialState)\n    }\n}`\n\nconst navigationConfigInterface = `interface NavigationConfig {\n    val screenRegistry: ScreenRegistry\n    val scopeRegistry: ScopeRegistry\n    val transitionRegistry: TransitionRegistry\n    val containerRegistry: ContainerRegistry\n    val deepLinkRegistry: DeepLinkRegistry\n    val paneRoleRegistry: PaneRoleRegistry\n    \n    fun buildNavNode(destinationClass: KClass<*>, parentKey: String?): NavNode?\n    \n    operator fun plus(other: NavigationConfig): NavigationConfig\n}`\n\nconst featureModuleCode = `// feature1/src/commonMain/kotlin/Feature1Destinations.kt\n@Stack(name =  , startDestination = Feature1List::class)\nsealed class Feature1Destination : NavDestination {\n    @Destination(route =  )\n    data object Feature1List : Feature1Destination()\n    \n    @Destination(route =  )\n    data class Feature1Detail(@Argument val id: String) : Feature1Destination()\n}\n\n// feature1/src/commonMain/kotlin/Feature1Screens.kt\n@Screen(Feature1Destination.Feature1List::class)\n@Composable\nfun Feature1ListScreen(navigator: Navigator) { /* ... */ }\n\n@Screen(Feature1Destination.Feature1Detail::class)\n@Composable\nfun Feature1DetailScreen(\n    destination: Feature1Destination.Feature1Detail, \n    navigator: Navigator\n) { /* ... */ }\n\n// After KSP generates Feature1NavigationConfig`\n\nconst crossModuleCode = `// In feature1, navigate to feature2 destination\nnavigator.navigate(Feature2Destination.SomeScreen)\n\n// Works because configs are combined in app module`\n\nconst featureDependenciesCode = `// feature1/build.gradle.kts\nplugins {\n    kotlin( com.google.devtools.ksp io.github.jermeyyy.quo-vadis ))\n            implementation(project( ))\n        }\n    }\n}\n\nquoVadis {\n    modulePrefix =  >Module Structure Pattern</h2>\n        <p>\n          A typical multi-module project organizes navigation across feature modules, \n          with each module containing its destinations, screens, and a generated \n          NavigationConfig:\n        </p>\n        <CodeBlock code={moduleStructure} language=  />\n      </section>\n\n      <section>\n        <h2 id= >KSP Module Prefix Configuration</h2>\n        <p>\n          Each module needs a unique prefix to generate distinct NavigationConfig classes. \n          Configure this in each feature module  />\n      </section>\n\n      <section>\n        <h2 id= >Combining Configurations</h2>\n        <p>\n          Use the <code>+</code> operator to combine NavigationConfig instances from \n          multiple modules. This is typically done in your app module  />\n        <p>\n          <strong>Priority rule:</strong> The right-hand config takes priority for \n          duplicate registrations. This allows feature modules to override app-level \n          defaults when needed.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >NavigationConfig Interface</h2>\n        <p>\n          The NavigationConfig interface combines all navigation-related registries \n          and provides the <code>plus</code> operator for composition:\n        </p>\n        <CodeBlock code={navigationConfigInterface} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Feature Module Example</h2>\n        <p>\n          Each feature module defines its own destinations and screens. KSP generates \n          the NavigationConfig automatically:\n        </p>\n        <CodeBlock code={featureModuleCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Cross-Module Navigation</h2>\n        <p>\n          Navigate between modules using type-safe destination references. This works \n          because all configs are combined in the app module:\n        </p>\n        <CodeBlock code={crossModuleCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Feature Module Dependencies</h2>\n        <p>\n          Each feature module requires the Quo Vadis plugin and core dependencies:\n        </p>\n        <CodeBlock code={featureDependenciesCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Hybrid Configuration</h2>\n        <p>\n          Combine generated configs with manual additions for dynamic features \n          like feature flags:\n        </p>\n        <CodeBlock code={hybridConfigCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Generated Files Per Module</h2>\n        <table>\n          <thead>\n            <tr>\n              <th>Module</th>\n              <th>Generated Config</th>\n              <th>Contains</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>app</code></td>\n              <td><code>AppNavigationConfig</code></td>\n              <td>Tab containers, main screens</td>\n            </tr>\n            <tr>\n              <td><code>feature1</code></td>\n              <td><code>Feature1NavigationConfig</code></td>\n              <td>Feature 1 screens</td>\n            </tr>\n            <tr>\n              <td><code>feature2</code></td>\n              <td><code>Feature2NavigationConfig</code></td>\n              <td>Feature 2 screens</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Best Practices</h2>\n        <ul>\n          <li><strong>Consistent naming:</strong> Use <code>{ }NavigationConfig</code> pattern</li>\n          <li><strong>Co-location:</strong> Define destinations close to their screens</li>\n          <li><strong>Independence:</strong> Keep feature modules independent of each other</li>\n          <li><strong>Central composition:</strong> Combine configs only in app module</li>\n          <li><strong>Cross-boundary testing:</strong> Test navigation across module boundaries</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >DI Integration</a> - Set up dependency injection with navigation</li>\n          <li><a href= >Deep Linking</a> - Add URL-based navigation</li>\n          <li><a href="
  },
  {
    "id": "Features/Multiplatform/multiplatform",
    "title": "Multiplatform",
    "route": "/Features/Multiplatform/multiplatform",
    "content": "\n\n// Status badge components\nconst StatusFull = ({ children =  ,\n    flexDirection:   as const,\n    alignItems:  ,\n  },\n  arrow: {\n    display:  ,\n    flexDirection:   as const,\n    alignItems:  ,\n  },\n  arrowLine: {\n    width:  var(--color-text-muted, #9ca3af) 6px solid transparent 6px solid transparent 8px solid var(--color-text-muted, #9ca3af) rgba(139, 92, 246, 0.08) 1px solid rgba(139, 92, 246, 0.3)  as const,\n    textTransform:   as const,\n    letterSpacing:  ,\n    flexDirection:  var(--color-text-secondary)  as const,\n    justifyContent:  ,\n  },\n  platformBox: {\n    background:  1px solid var(--color-border)  as const,\n  },\n  platformTitle: {\n    fontWeight:   as const,\n    fontSize:  var(--color-text-primary) var(--color-text-muted) ,\n    flexDirection:  ,\n  },\n  codeSharing: {\n    textAlign:   as const,\n    padding:  rgba(34, 197, 94, 0.1)  as const,\n    fontSize:  ,\n  },\n}\n\nconst Arrow = () => (\n  <div style={diagramStyles.arrow}>\n    <div style={diagramStyles.arrowLine} />\n    <div style={diagramStyles.arrowHead} />\n  </div>\n)\n\nconst PlatformArchitectureDiagram = () => (\n  <div style={diagramStyles.container}>\n    {/* commonMain box */}\n    <div style={diagramStyles.mainBox}>\n      <div style={diagramStyles.mainBoxTitle}>commonMain</div>\n      <div style={diagramStyles.mainBoxContent}>\n        <span>• Destinations (@Stack, @Destination)</span>\n        <span>• Screens (@Screen)</span>\n        <span>• Containers (NavigationContainer)</span>\n        <span>• Business logic</span>\n      </div>\n    </div>\n    \n    <Arrow />\n    \n    {/* Platform-specific boxes */}\n    <div style={diagramStyles.platformBoxes}>\n      <div style={diagramStyles.platformBox}>\n        <div style={diagramStyles.platformTitle}>androidMain</div>\n        <div style={diagramStyles.platformItems}>\n          <span>MainActivity</span>\n          <span>Deep links</span>\n          <span>Back handler</span>\n        </div>\n      </div>\n      \n      <div style={diagramStyles.platformBox}>\n        <div style={diagramStyles.platformTitle}>iosMain</div>\n        <div style={diagramStyles.platformItems}>\n          <span>AppDelegate</span>\n          <span>Universal links</span>\n          <span>Swipe gestures</span>\n        </div>\n      </div>\n      \n      <div style={diagramStyles.platformBox}>\n        <div style={diagramStyles.platformTitle}>desktopMain</div>\n        <div style={diagramStyles.platformItems}>\n          <span>Main window</span>\n          <span>System tray</span>\n          <span>Keyboard nav</span>\n        </div>\n      </div>\n      \n      <div style={diagramStyles.platformBox}>\n        <div style={diagramStyles.platformTitle}>webMain</div>\n        <div style={diagramStyles.platformItems}>\n          <span>Browser entry</span>\n          <span>URL routing</span>\n          <span>History API</span>\n        </div>\n      </div>\n    </div>\n    \n    {/* Code sharing indicator */}\n    <div style={{ marginTop:  >Platform Support</h2>\n        <p>\n          Quo Vadis supports all major Kotlin Multiplatform targets with full feature parity:\n        </p>\n        \n        <table>\n          <thead>\n            <tr>\n              <th>Platform</th>\n              <th>Targets</th>\n              <th style={{ textAlign:   }}><StatusFull /></td>\n              <td>WASM-compatible browsers</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Single Codebase Benefits</h2>\n        <p>\n          Write your navigation logic once in <code>commonMain</code> and it runs identically \n          on all platforms:\n        </p>\n        \n        <CodeBlock language=  code={`// commonMain - shared across ALL platforms\n@Stack(name =  , startDestination = Feed::class)\nsealed class HomeDestination : NavDestination {\n    @Destination(route =  )\n    data object Feed : HomeDestination()\n}\n\n@Screen(HomeDestination.Feed::class)\n@Composable\nfun FeedScreen(navigator: Navigator) {\n    // Same code runs on Android, iOS, Desktop, Web\n}`} />\n      </section>\n\n      <section>\n        <h2 id=  }}>Android</th>\n              <th style={{ textAlign:   }}>iOS</th>\n              <th style={{ textAlign:   }}>Desktop</th>\n              <th style={{ textAlign:  >Gradle Setup for All Platforms</h2>\n        <p>\n          Configure your <code>build.gradle.kts</code> to target all platforms:\n        </p>\n        \n        <CodeBlock language=  code={`// build.gradle.kts\nkotlin {\n    androidTarget()\n    \n    listOf(\n        iosX64(),\n        iosArm64(),\n        iosSimulatorArm64()\n    ).forEach { iosTarget ->\n        iosTarget.binaries.framework {\n            baseName =  \n            isStatic = true\n        }\n    }\n    \n    jvm( )\n    \n    js(IR) {\n        browser()\n    }\n    \n    @OptIn(ExperimentalWasmDsl::class)\n    wasmJs {\n        browser()\n    }\n    \n    sourceSets {\n        commonMain.dependencies {\n            implementation( )\n            implementation( )\n        }\n    }\n}`} />\n      </section>\n\n      <section>\n        <h2 id= >Running on Different Platforms</h2>\n        <p>\n          Use these Gradle commands to run your app on each platform:\n        </p>\n        \n        <CodeBlock language=  code={`# Android\n./gradlew :composeApp:installDebug\n\n# Desktop (JVM)\n./gradlew :composeApp:run\n\n# iOS (requires Xcode)\n./gradlew :composeApp:iosSimulatorArm64Test\n\n# JavaScript Browser\n./gradlew :composeApp:jsBrowserDevelopmentRun\n\n# WebAssembly Browser\n./gradlew :composeApp:wasmJsBrowserDevelopmentRun`} />\n      </section>\n\n      <section>\n        <h2 id= >Web-Specific Features</h2>\n        <p>\n          On web platforms, Quo Vadis integrates with browser history and URL routing:\n        </p>\n        \n        <CodeBlock language=  code={`// Enable browser history integration\nNavigationHost(\n    navigator = navigator,\n    enableBrowserHistory = true  // Syncs with browser URL\n)\n\n// Deep links work as URLs\n// https://yourapp.com/home/article/123`} />\n      </section>\n\n      <section>\n        <h2 id= >iOS-Specific Features</h2>\n        <p>\n          On iOS, predictive back works with native swipe gestures:\n        </p>\n        \n        <CodeBlock language=  code={`// Predictive back via edge swipe\nNavigationHost(\n    navigator = navigator,\n    enablePredictiveBack = true  // Works with iOS swipe gesture\n)`} />\n      </section>\n\n      <section>\n        <h2 id= >Desktop-Specific Features</h2>\n        <p>\n          Desktop platforms support keyboard navigation and adaptive window layouts:\n        </p>\n        \n        <CodeBlock language=  code={`// Keyboard navigation\nNavigationHost(\n    navigator = navigator,\n    enableKeyboardBack = true  // Escape key for back\n)\n\n// Window size class for adaptive layouts\nval windowSizeClass = calculateWindowSizeClass()\nNavigationHost(\n    navigator = navigator,\n    windowSizeClass = windowSizeClass  // Triggers pane layout changes\n)`} />\n      </section>\n\n      <section>\n        <h2 id= >Platform-Agnostic Architecture</h2>\n        <p>\n          The architecture keeps platform-specific code minimal while maximizing code sharing:\n        </p>\n        \n        <PlatformArchitectureDiagram />\n        \n        <p>\n          This means 90%+ of your navigation code lives in <code>commonMain</code> and is shared \n          across all platforms, while platform-specific integrations are handled automatically.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><Link to= >Predictive Back</Link> - Platform-specific back navigation</li>\n          <li><Link to= >Deep Links</Link> - URL patterns and deep linking</li>\n          <li><Link to="
  },
  {
    "id": "Features/PaneLayouts/panelayouts",
    "title": "Pane Layouts",
    "route": "/Features/PaneLayouts/panelayouts",
    "content": "\n\nconst paneNodeStructureCode = `@Serializable\n@SerialName( )\ndata class PaneNode(\n    override val key: String,\n    override val parentKey: String?,\n    val paneConfigurations: Map<PaneRole, PaneConfiguration>,\n    val activePaneRole: PaneRole = PaneRole.Primary,\n    val backBehavior: PaneBackBehavior = PaneBackBehavior.PopUntilScaffoldValueChange,\n    val scopeKey: String? = null\n) : NavNode {\n    val activePaneContent: NavNode?   // Content of focused pane\n    val paneCount: Int                // Number of configured panes\n    val configuredRoles: Set<PaneRole> // All configured roles\n}`\n\nconst annotationExampleCode = `@Pane(name =  , backBehavior = PaneBackBehavior.PopUntilContentChange)\nsealed class MessagesPane : NavDestination {\n\n    @PaneItem(role = PaneRole.PRIMARY)\n    @Destination(route =  )\n    data object ConversationList : MessagesPane()\n\n    @PaneItem(role = PaneRole.SECONDARY)\n    @Destination(route =  )\n    data class ConversationDetail(\n        @Argument val conversationId: String\n    ) : MessagesPane()\n}`\n\nconst dslExampleCode = `navigationConfig {\n    panes<ListDetailPanes>( ) {\n        initialPane = PaneRole.Primary\n        backBehavior = PaneBackBehavior.PopUntilScaffoldValueChange\n        \n        primary(weight = 0.4f, minWidth = 300.dp) {\n            root(ListScreen)\n            alwaysVisible()\n        }\n        \n        secondary(weight = 0.6f, minWidth = 400.dp) {\n            root(DetailPlaceholder)\n        }\n    }\n}`\n\nconst containerExampleCode = `@PaneContainer(MessagesPane::class)\n@Composable\nfun MessagesPaneContainer(\n    scope: PaneContainerScope,\n    content: @Composable () -> Unit\n) {\n    if (scope.isExpanded) {\n        // Expanded: Two-column layout\n        Row(modifier = Modifier.fillMaxSize()) {\n            scope.paneContents.filter { it.isVisible }.forEach { pane ->\n                val weight = when (pane.role) {\n                    PaneRole.Primary -> 0.4f\n                    PaneRole.Supporting -> 0.6f\n                    else -> 0.25f\n                }\n                Box(modifier = Modifier.weight(weight).fillMaxHeight()) {\n                    if (pane.hasContent) pane.content()\n                    else EmptyPlaceholder()\n                }\n            }\n        }\n    } else {\n        // Compact: Single pane\n        content()\n    }\n}`\n\nconst navigationExampleCode = `// Navigate to detail pane\nnavigator.navigate(MessagesPane.ConversationDetail( ))\n\n// The library automatically:\n// - On expanded screens: Shows detail in Supporting pane\n// - On compact screens: Pushes detail, hiding Primary pane\n\n// Check pane state via PaneContainerScope\nif (scope.isExpanded) {\n    // Multi-pane mode - both panes visible\n} else {\n    // Compact mode - only active pane visible\n}`\n\nconst treeStructureCode = `// PaneNode tree structure\nStackNode (root)\n└── PaneNode (MessagesPane)\n    ├── Primary: StackNode\n    │   └── ScreenNode (ConversationList)\n    └── Supporting: StackNode\n        └── ScreenNode (ConversationDetail)`\n\nconst masterDetailExampleCode = `@Pane(name =  , backBehavior = PaneBackBehavior.PopUntilContentChange)\nsealed class EmailPane : NavDestination {\n\n    @PaneItem(role = PaneRole.PRIMARY)\n    @Destination(route =  )\n    data object Inbox : EmailPane()\n\n    @PaneItem(role = PaneRole.SECONDARY)\n    @Destination(route =  )\n    data class MessageView(\n        @Argument val messageId: String\n    ) : EmailPane()\n\n    @PaneItem(role = PaneRole.EXTRA)\n    @Destination(route =  )\n    data object Compose : EmailPane()\n}`\n\nconst dslWrapperExampleCode = `navigationConfig {\n    paneContainer( >Overview</h2>\n        <p>\n          <code>PaneNode</code> represents adaptive layouts where multiple panes can be displayed \n          simultaneously on large screens (tablets, desktops, foldables) or collapsed \n          to single-pane navigation on compact screens (phones).\n        </p>\n        <h3>When to Use Panes</h3>\n        <ul>\n          <li><strong>Master-detail patterns</strong> - Lists with detail views side-by-side</li>\n          <li><strong>Supporting panels</strong> - Main content with contextual information</li>\n          <li><strong>Foldable/tablet layouts</strong> - Take advantage of larger screens</li>\n          <li><strong>Email/messaging apps</strong> - Conversation list + message view</li>\n          <li><strong>Three-column layouts</strong> - Navigation + content + detail (Extra role)</li>\n        </ul>\n        <h3>Key Features</h3>\n        <ul>\n          <li><strong>Automatic Adaptation</strong> - Responds to screen size changes</li>\n          <li><strong>Independent Stacks</strong> - Each pane has its own navigation history</li>\n          <li><strong>Configurable Back Behavior</strong> - Control how back navigation works</li>\n          <li><strong>Custom Layouts</strong> - Full control over pane arrangement</li>\n          <li><strong>Shared State</strong> - State can be shared across panes</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >PaneNode Structure</h2>\n        <p>\n          At runtime, pane navigation is represented by a <code>PaneNode</code> in the navigation tree. \n          This node holds all pane configurations and tracks which pane is currently active.\n        </p>\n        <CodeBlock code={paneNodeStructureCode} language=  />\n        <h3>Key Properties</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>Property</th>\n              <th>Type</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>paneConfigurations</code></td>\n              <td><code>Map&lt;PaneRole, PaneConfiguration&gt;</code></td>\n              <td>Pane role to configuration mapping</td>\n            </tr>\n            <tr>\n              <td><code>activePaneRole</code></td>\n              <td><code>PaneRole</code></td>\n              <td>Pane with navigation focus</td>\n            </tr>\n            <tr>\n              <td><code>backBehavior</code></td>\n              <td><code>PaneBackBehavior</code></td>\n              <td>Back navigation strategy</td>\n            </tr>\n            <tr>\n              <td><code>scopeKey</code></td>\n              <td><code>String?</code></td>\n              <td>Identifier for scope-aware navigation</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Pane Roles</h2>\n        <p>\n          Each pane is assigned a role that determines its purpose and behavior within the layout.\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Role</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>PaneRole.Primary</code></td>\n              <td>Main content pane (required). Always present in the layout.</td>\n            </tr>\n            <tr>\n              <td><code>PaneRole.Supporting</code></td>\n              <td>Detail/secondary content. Shows alongside Primary on large screens.</td>\n            </tr>\n            <tr>\n              <td><code>PaneRole.Extra</code></td>\n              <td>Additional content (rare). For three-column layouts on very large screens.</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Adaptation Strategies</h2>\n        <p>\n          Each pane can have an <code>AdaptStrategy</code> that defines how it behaves when screen space is limited.\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Strategy</th>\n              <th>Behavior</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>AdaptStrategy.Hide</code></td>\n              <td>Hide the pane completely when space is limited</td>\n            </tr>\n            <tr>\n              <td><code>AdaptStrategy.Levitate</code></td>\n              <td>Show as overlay (modal-like) over other panes</td>\n            </tr>\n            <tr>\n              <td><code>AdaptStrategy.Reflow</code></td>\n              <td>Stack vertically under another pane</td>\n            </tr>\n          </tbody>\n        </table>\n\n        <h3>Screen Size Behavior</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>Screen Size</th>\n              <th>Behavior</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><strong>Compact</strong> (phones)</td>\n              <td>Only <code>activePaneRole</code> is visible</td>\n            </tr>\n            <tr>\n              <td><strong>Medium</strong> (small tablets)</td>\n              <td>Primary visible, others can levitate as overlays</td>\n            </tr>\n            <tr>\n              <td><strong>Expanded</strong> (tablets, desktop)</td>\n              <td>Multiple panes displayed side-by-side</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Back Navigation Behavior</h2>\n        <p>\n          <code>PaneBackBehavior</code> controls how the back button/gesture behaves within pane layouts.\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Behavior</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>PopUntilScaffoldValueChange</code></td>\n              <td>Pop until the visible pane layout changes (e.g., going from two-pane to one-pane view)</td>\n            </tr>\n            <tr>\n              <td><code>PopUntilContentChange</code></td>\n              <td>Pop until any visible pane annotation-definition  />\n        <h3>@Pane Properties</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>Property</th>\n              <th>Type</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>name</code></td>\n              <td><code>String</code></td>\n              <td>Unique identifier for the pane container</td>\n            </tr>\n            <tr>\n              <td><code>backBehavior</code></td>\n              <td><code>PaneBackBehavior</code></td>\n              <td>Back navigation strategy</td>\n            </tr>\n          </tbody>\n        </table>\n        <h3>@PaneItem Properties</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>Property</th>\n              <th>Type</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>role</code></td>\n              <td><code>PaneRole</code></td>\n              <td>Which pane this destination belongs to (PRIMARY, SECONDARY, EXTRA)</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >DSL-Based Definition</h2>\n        <p>\n          For dynamic configurations, use the <code>panes&lt;D&gt;</code> builder in the DSL:\n        </p>\n        <CodeBlock code={dslExampleCode} language=  />\n        <p>\n          The DSL approach offers fine-grained control over pane dimensions, weights, \n          and visibility rules that may not be available through annotations.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >PaneContainer Implementation</h2>\n        <p>\n          Use <code>@PaneContainer</code> to create custom pane layout UI with full control \n          over how panes are arranged and displayed.\n        </p>\n        <CodeBlock code={containerExampleCode} language=  />\n        \n        <h3>PaneContainerScope Properties</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>Property</th>\n              <th>Type</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>navigator</code></td>\n              <td><code>Navigator</code></td>\n              <td>Navigator instance for programmatic navigation</td>\n            </tr>\n            <tr>\n              <td><code>activePaneRole</code></td>\n              <td><code>PaneRole</code></td>\n              <td>Currently active/focused pane</td>\n            </tr>\n            <tr>\n              <td><code>paneCount</code></td>\n              <td><code>Int</code></td>\n              <td>Total configured panes</td>\n            </tr>\n            <tr>\n              <td><code>visiblePaneCount</code></td>\n              <td><code>Int</code></td>\n              <td>Currently visible panes</td>\n            </tr>\n            <tr>\n              <td><code>isExpanded</code></td>\n              <td><code>Boolean</code></td>\n              <td>Whether multi-pane mode is active</td>\n            </tr>\n            <tr>\n              <td><code>isTransitioning</code></td>\n              <td><code>Boolean</code></td>\n              <td>Whether pane transition is in progress</td>\n            </tr>\n            <tr>\n              <td><code>paneContents</code></td>\n              <td><code>List&lt;PaneContent&gt;</code></td>\n              <td>Content slots for custom layout rendering</td>\n            </tr>\n          </tbody>\n        </table>\n\n        <h3>DSL-Based Container Wrapper</h3>\n        <p>\n          You can also register pane containers via DSL:\n        </p>\n        <CodeBlock code={dslWrapperExampleCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Navigating Between Panes</h2>\n        <p>\n          Navigate to pane destinations just like any other destination. The library automatically \n          handles showing content in the appropriate pane based on screen size.\n        </p>\n        <CodeBlock code={navigationExampleCode} language=  />\n        <p>\n          The navigation system automatically determines where to show content based on:\n        </p>\n        <ul>\n          <li>The destination >Tree Structure</h2>\n        <p>\n          In the navigation tree, a <code>PaneNode</code> contains separate <code>StackNode</code>s \n          for each pane role:\n        </p>\n        <CodeBlock code={treeStructureCode} language=  />\n        <p>\n          Each pane >Common Patterns</h2>\n        \n        <h3>Master-Detail (List + Detail)</h3>\n        <p>\n          The most common pane pattern. Show a list in the Primary pane and details \n          in the Supporting pane.\n        </p>\n        <CodeBlock code={masterDetailExampleCode} language=  />\n        \n        <h3>Supporting Panel</h3>\n        <p>\n          Main content with a contextual sidebar. The Supporting pane shows additional \n          information related to the Primary content without replacing it.\n        </p>\n        \n        <h3>Three-Column Layout</h3>\n        <p>\n          For very large screens (desktop), use the <code>Extra</code> role to add a \n          third column. Common in email clients: folders | messages | message detail.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Best Practices</h2>\n        <ul>\n          <li>\n            <strong>Always provide empty state placeholders</strong> - When the Supporting pane \n            has no content, show a helpful placeholder instead of blank space.\n          </li>\n          <li>\n            <strong>Choose appropriate back behavior</strong> - Use <code>PopUntilContentChange</code> \n            for fine-grained back navigation, <code>PopUntilScaffoldValueChange</code> for \n            layout-changing navigation.\n          </li>\n          <li>\n            <strong>Test on multiple screen sizes</strong> - Ensure your pane layout works well \n            on phones (single pane), tablets (dual pane), and desktop (potentially three panes).\n          </li>\n          <li>\n            <strong>Consider foldables</strong> - Foldable devices may switch between expanded and \n            compact modes during use. Test fold/unfold scenarios.\n          </li>\n          <li>\n            <strong>Keep Primary pane always visible when expanded</strong> - The Primary pane \n            serves as an anchor. Use <code>alwaysVisible()</code> in DSL configuration.\n          </li>\n          <li>\n            <strong>Handle orientation changes gracefully</strong> - The navigation state persists \n            across configuration changes; only the visual layout adapts.\n          </li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><Link to= >Architecture</Link> - Overall navigation architecture</li>\n          <li><Link to= >Tabbed Navigation</Link> - Tab-based navigation patterns</li>\n          <li><Link to= >DSL Configuration</Link> - Manual configuration options</li>\n          <li><Link to= >Multiplatform</Link> - Platform-specific considerations</li>\n          <li><Link to="
  },
  {
    "id": "Features/PredictiveBack/predictiveback",
    "title": "Predictive Back",
    "route": "/Features/PredictiveBack/predictiveback",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css >Platform Support</h2>\n        <table>\n          <thead>\n            <tr>\n              <th>Platform</th>\n              <th>Support</th>\n              <th>Features</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Android 13+</td>\n              <td><StatusFull /></td>\n              <td>Predictive back gestures with visual preview</td>\n            </tr>\n            <tr>\n              <td>iOS</td>\n              <td><StatusFull /></td>\n              <td>Edge swipe-back gesture</td>\n            </tr>\n            <tr>\n              <td>Desktop</td>\n              <td><StatusPartial /></td>\n              <td>Keyboard back (Escape key)</td>\n            </tr>\n            <tr>\n              <td>Web</td>\n              <td><StatusPartial /></td>\n              <td>Browser back button integration</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Enabling Predictive Back</h2>\n        <p>\n          Predictive back is enabled by default in <code>NavigationHost</code>:\n        </p>\n        <CodeBlock code={enablePredictiveBackCode} language=  />\n        <p>\n          Disable for specific scenarios where gesture preview isn  />\n      </section>\n\n      <section>\n        <h2 id= >How It Works</h2>\n        <p>\n          The predictive back gesture follows a defined lifecycle:\n        </p>\n        <ol>\n          <li><strong>Gesture Start:</strong> <code>PredictiveBackController</code> activates when the user begins the back gesture</li>\n          <li><strong>Progress Updates:</strong> Visual transforms are applied based on gesture progress (0.0 to 1.0)</li>\n          <li><strong>Completion:</strong> When gesture is committed, animated transition to final state occurs</li>\n          <li><strong>Cancellation:</strong> If gesture is released early, animated return to original state</li>\n        </ol>\n      </section>\n\n      <section>\n        <h2 id= >Visual Behavior</h2>\n        <p>\n          During the gesture, visual transforms create a preview effect:\n        </p>\n        <CodeBlock code={visualBehaviorCode} language=  />\n        <p>\n          The current screen slides right and scales down slightly, while the previous screen \n          has a parallax effect sliding in from the left.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >PredictiveBackController State</h2>\n        <p>\n          The <code>PredictiveBackController</code> manages gesture state:\n        </p>\n        <CodeBlock code={controllerStateCode} language=  />\n        <h3>Progress Ranges</h3>\n        <ul>\n          <li><strong>During gesture:</strong> <code>0.0</code> to <code>0.17</code> (clamped to prevent excessive movement)</li>\n          <li><strong>During completion:</strong> <code>0.0</code> to <code>1.0</code></li>\n          <li><strong>During cancellation:</strong> Animates back to <code>0.0</code></li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Navigator Back Operations</h2>\n        <p>\n          <code>TreeNavigator</code> provides methods for programmatic control:\n        </p>\n        <CodeBlock code={navigatorBackOpsCode} language=  />\n        <p>\n          These methods are typically called by the platform-specific gesture handlers, \n          but can be invoked directly for custom implementations.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >TransitionState Types</h2>\n        <p>\n          The <code>TransitionState</code> sealed interface represents the current state:\n        </p>\n        <CodeBlock code={transitionStateCode} language=  />\n        <p>\n          The <code>touchX</code> and <code>touchY</code> values are normalized to 0.0-1.0, \n          representing the position on screen where the gesture originated.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Observing State in Compose</h2>\n        <p>\n          You can observe the transition state to react to gesture progress:\n        </p>\n        <CodeBlock code={observingStateCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Context-Specific Behavior</h2>\n        <p>\n          Predictive back behavior varies by navigation context:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Context</th>\n              <th>Predictive Back</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Stack navigation</td>\n              <td><StatusFull>Enabled</StatusFull></td>\n            </tr>\n            <tr>\n              <td>Tab switching</td>\n              <td><StatusNo>Disabled</StatusNo></td>\n            </tr>\n            <tr>\n              <td>Pane transitions</td>\n              <td>Depends on compact/expanded mode</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Android Manifest Setup</h2>\n        <p>\n          To enable predictive back on Android, add this to your <code>AndroidManifest.xml</code>:\n        </p>\n        <CodeBlock code={androidManifestCode} language=  />\n        <p>\n          This is required for Android 13+ to opt-in to the new back gesture API.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >iOS Integration</h2>\n        <p>\n          On iOS, predictive back integrates with the system edge swipe gesture through \n          a <code>NavigateBackHandler</code> in the SwiftUI integration layer. The edge \n          swipe gesture is automatically handled when using the standard iOS navigation setup.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Transitions & Animations</a> - Transition types and customization</li>\n          <li><a href= >Stack Management</a> - NavNode tree operations</li>\n          <li><a href="
  },
  {
    "id": "Features/TabbedNavigation/tabbednavigation",
    "title": "Tabbed Navigation",
    "route": "/Features/TabbedNavigation/tabbednavigation",
    "content": "@components/CodeBlock/CodeBlock @components/ScopePropertiesTable/ScopePropertiesTable )\ndata class TabNode(\n    override val key: String,\n    override val parentKey: String?,\n    val stacks: List<StackNode>,\n    val activeStackIndex: Int = 0,\n    val wrapperKey: String? = null,\n    val tabMetadata: List<GeneratedTabMetadata> = emptyList(),\n    val scopeKey: String? = null\n) : NavNode {\n    val activeStack: StackNode   // Currently selected tab ,\n    initialTab = AppTabs.HomeTab::class,\n    items = [AppTabs.HomeTab::class, AppTabs.SearchTab::class]\n)\nsealed class AppTabs : NavDestination {\n\n    // Tab with its own nested navigation stack\n    @TabItem(label =  , startDestination = HomeTab.Feed::class)\n    sealed class HomeTab : AppTabs() {\n        @Destination(route =  )\n        data object Feed : HomeTab()\n        \n        @Destination(route =  )\n        data class Article(@Argument val id: String) : HomeTab()\n        \n        @Destination(route =  )\n        data class Comments(@Argument val articleId: String) : HomeTab()\n    }\n\n    // Another tab with its own stack\n    @TabItem(label =  , startDestination = SearchTab.Main::class)\n    sealed class SearchTab : AppTabs() {\n        @Destination(route =  )\n        data object Main : SearchTab()\n        \n        @Destination(route =  >Overview</h2>\n        <p>\n          Quo Vadis provides a powerful annotation-driven system for tabbed navigation that eliminates \n          boilerplate while ensuring type safety. Each tab operates as an independent navigation stack, \n          preserving scroll positions, form data, and navigation history when switching between tabs.\n        </p>\n        <h3>Key Features</h3>\n        <ul>\n          <li><strong>Independent Backstacks</strong> - Each tab maintains its own navigation history</li>\n          <li><strong>State Preservation</strong> - Tab content survives tab switches</li>\n          <li><strong>Nested Stacks</strong> - Tabs can contain their own deep navigation</li>\n          <li><strong>Custom UI</strong> - Full control over tab bar appearance</li>\n          <li><strong>Shared State</strong> - Share data across tabs with MVI containers</li>\n          <li><strong>Platform Icons</strong> - Native icon support per platform</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >@Tabs + @TabItem Annotations</h2>\n        <p>\n          Define your tab structure using <code>@Tabs</code> on a sealed class and <code>@TabItem</code> \n          on each tab destination. The KSP processor generates all configuration code automatically.\n        </p>\n        <CodeBlock code={tabsAnnotationWithNestedStack} language=  />\n        <p>\n          Notice how <code>SettingsTab</code> is both a tab item and contains its own nested stack \n          with multiple destinations. This enables deep navigation within individual tabs.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >@Tabs Properties</h2>\n        <table>\n          <thead>\n            <tr>\n              <th>Property</th>\n              <th>Type</th>\n              <th>Default</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>name</code></td>\n              <td><code>String</code></td>\n              <td><IconNa /></td>\n              <td>Unique identifier for the tab container</td>\n            </tr>\n            <tr>\n              <td><code>initialTab</code></td>\n              <td><code>KClass&lt;*&gt;</code></td>\n              <td><code>Unit::class</code></td>\n              <td>Initially selected tab (Unit = first tab)</td>\n            </tr>\n            <tr>\n              <td><code>items</code></td>\n              <td><code>Array&lt;KClass&lt;*&gt;&gt;</code></td>\n              <td><code>[]</code></td>\n              <td>Tab classes in display order</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >@TabItem Properties</h2>\n        <table>\n          <thead>\n            <tr>\n              <th>Property</th>\n              <th>Type</th>\n              <th>Default</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>label</code></td>\n              <td><code>String</code></td>\n              <td><IconNa /></td>\n              <td>Display label for the tab</td>\n            </tr>\n            <tr>\n              <td><code>icon</code></td>\n              <td><code>String</code></td>\n              <td><code> </code></td>\n              <td>Icon identifier (platform-specific)</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >TabNode Structure</h2>\n        <p>\n          At runtime, tab navigation is represented by a <code>TabNode</code> in the navigation tree. \n          This node holds all tab stacks and tracks which tab is currently active.\n        </p>\n        <CodeBlock code={tabNodeStructureCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >TabNode Behavior</h2>\n        <p>\n          Understanding how TabNode responds to navigation operations helps you design intuitive flows:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Operation</th>\n              <th>Effect</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><strong>Switch Tab</strong></td>\n              <td>Updates <code>activeStackIndex</code></td>\n            </tr>\n            <tr>\n              <td><strong>Push</strong></td>\n              <td>Affects only the active stack</td>\n            </tr>\n            <tr>\n              <td><strong>Pop</strong></td>\n              <td>Removes from active stack; may switch tabs</td>\n            </tr>\n          </tbody>\n        </table>\n        <p>\n          When popping from an empty non-primary tab, Quo Vadis can automatically switch to the \n          primary tab, providing a familiar back-navigation experience.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >@TabsContainer - Custom Tab UI</h2>\n        <p>\n          Use <code>@TabsContainer</code> to create custom tab bar UI with full control over \n          appearance and behavior. The container receives a <code>TabsContainerScope</code> with \n          all necessary state and actions.\n        </p>\n        <CodeBlock code={tabsContainerCode} language=  />\n        <p>\n          This pattern works with any tab UI: bottom navigation bars, navigation rails, \n          top tabs, or completely custom designs.\n        </p>\n      </section>\n\n      <section id= >\n        <ScopePropertiesTable scopeType=  />\n      </section>\n\n      <section>\n        <h2 id= >Tabs with Nested Stacks</h2>\n        <p>\n          Tabs can contain their own navigation stacks for deep navigation within each tab. \n          This is perfect for sections like a home feed where users drill into articles, \n          then comments, while preserving the ability to switch tabs.\n        </p>\n        <CodeBlock code={nestedStacksCode} language=  />\n        <p>\n          Each tab t \n          affect the Search tab >Icon Platform Support</h2>\n        <p>\n          The <code>icon</code> property in <code>@TabItem</code> is interpreted differently per platform:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Platform</th>\n              <th>Interpretation</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Android</td>\n              <td>Material icon name or drawable resource</td>\n            </tr>\n            <tr>\n              <td>iOS</td>\n              <td>SF Symbol name</td>\n            </tr>\n            <tr>\n              <td>Desktop/Web</td>\n              <td>Icon library identifier</td>\n            </tr>\n          </tbody>\n        </table>\n        <p>\n          Your <code>@TabsContainer</code> implementation is responsible for mapping these \n          identifiers to actual icons using platform-appropriate APIs.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Shared State with SharedNavigationContainer</h2>\n        <p>\n          When tabs need to share state (like a shopping cart count or user preferences), \n          use <code>SharedNavigationContainer</code> with the FlowMVI integration. The container \n          is scoped to the tab node  />\n        <p>\n          Screens within any tab can access the shared store via the CompositionLocal, \n          enabling coordinated state across the entire tab structure.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Adaptive Panes</a> - Multi-pane layouts for larger screens</li>\n          <li><a href= >MVI Integration</a> - State management with FlowMVI</li>\n          <li><a href= >Transitions</a> - Animate between tabs and screens</li>\n          <li><a href="
  },
  {
    "id": "Features/Testing/testing",
    "title": "Testing",
    "route": "/Features/Testing/testing",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css ))\nassertEquals(HomeDestination.Article( ), navigator.currentDestination.value)\n\n// Test back navigation\nassertTrue(navigator.navigateBack())\nassertEquals(HomeDestination.Feed, navigator.currentDestination.value)`\n\nconst fakeNavigatorCode = `class FakeNavigator : Navigator {\n    var lastDestination: NavDestination? = null\n    var backPressed = false\n    \n    override fun navigate(destination: NavDestination, transition: NavigationTransition?) {\n        lastDestination = destination\n    }\n    \n    override fun navigateBack(): Boolean {\n        backPressed = true\n        return true\n    }\n    \n    override val currentDestination = MutableStateFlow<NavDestination?>(null)\n    override val canNavigateBack = MutableStateFlow(false)\n    // ... other properties\n}`\n\nconst mviContainerTestCode = `class ProfileContainerTest {\n    \n    private lateinit var repository: FakeProfileRepository\n    private lateinit var navigator: FakeNavigator\n    private lateinit var container: ProfileContainer\n    \n    @BeforeTest\n    fun setup() {\n        repository = FakeProfileRepository()\n        navigator = FakeNavigator()\n        \n        val testScope = TestNavigationContainerScope(\n            navigator = navigator,\n            screenKey =  \n        )\n        \n        container = ProfileContainer(\n            scope = testScope,\n            repository = repository\n        )\n    }\n    \n    @Test\n    fun \\`loading profile emits loading then content state\\`() = runTest {\n        val testUser = UserData(id =  ), awaitAction())\n}`\n\nconst navigationResultsTestCode = `@Test\nfun \\`navigateForResult returns selected item\\`() = runTest {\n    val navigator = TreeNavigator(config, initialState)\n    \n    launch {\n        // Simulate picker returning result\n        delay(100)\n        navigator.navigateBackWithResult(SelectedItem( ))\n    }\n    \n    val result = navigator.navigateForResult(ItemPicker)\n    \n    assertEquals(SelectedItem( ), result)\n}\n\n@Test\nfun \\`navigateForResult returns null on back\\`() = runTest {\n    val navigator = TreeNavigator(config, initialState)\n    \n    launch {\n        delay(100)\n        navigator.navigateBack()  // No result\n    }\n    \n    val result = navigator.navigateForResult(ItemPicker)\n    \n    assertNull(result)\n}`\n\nconst deepLinkTestCode = `@Test\nfun \\`deep link navigates to article\\`() {\n    val navigator = TreeNavigator(config, initialState)\n    \n    val handled = navigator.handleDeepLink( )\n    \n    assertTrue(handled)\n    assertEquals(\n        HomeDestination.Article( ),\n        navigator.currentDestination.value\n    )\n}\n\n@Test\nfun \\`unknown deep link returns false\\`() {\n    val navigator = TreeNavigator(config, initialState)\n    \n    val handled = navigator.handleDeepLink( )\n    \n    assertFalse(handled)\n}`\n\nconst composeUiTestCode = `class ProfileScreenTest {\n    \n    @get:Rule\n    val composeTestRule = createComposeRule()\n    \n    @Test\n    fun \\`profile screen shows loading then content\\`() {\n        val fakeStore = FakeStore<ProfileState, ProfileIntent, ProfileAction>(\n            initialState = ProfileState.Loading\n        )\n        \n        composeTestRule.setContent {\n            ProfileScreen(container = fakeStore)\n        }\n        \n        composeTestRule.onNodeWithText( ).assertIsDisplayed()\n        \n        fakeStore.emitState(ProfileState.Content(testUser))\n        \n        composeTestRule.onNodeWithText( ).assertIsDisplayed()\n    }\n}`\n\nconst stateAssertionsCode = `// Assert current destination type\nassertTrue(navigator.currentDestination.value is HomeDestination.Article)\n\n// Assert destination arguments\nval article = navigator.currentDestination.value as HomeDestination.Article\nassertEquals( >TreeNavigator for Unit Tests</h2>\n        <p>\n          Use <code>TreeNavigator</code> directly in tests to verify navigation logic\n          with the real navigation implementation:\n        </p>\n        <CodeBlock code={treeNavigatorCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >FakeNavigator Pattern</h2>\n        <p>\n          Create a fake navigator for lightweight unit tests that don  />\n      </section>\n\n      <section>\n        <h2 id= >Testing MVI Containers</h2>\n        <p>\n          Test FlowMVI containers with fake dependencies to verify state transitions\n          and navigation side effects:\n        </p>\n        <CodeBlock code={mviContainerTestCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >TestNavigationContainerScope</h2>\n        <p>\n          Create a test scope to provide dependencies for container testing:\n        </p>\n        <CodeBlock code={testScopeCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >FlowMVI Store Testing</h2>\n        <p>\n          Use the FlowMVI test DSL to verify state transitions and actions:\n        </p>\n        <CodeBlock code={flowMviTestCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Testing Navigation with Results</h2>\n        <p>\n          Test the <code>navigateForResult</code> pattern with coroutines:\n        </p>\n        <CodeBlock code={navigationResultsTestCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Testing Deep Links</h2>\n        <p>\n          Verify that deep links are handled correctly and navigate to the expected destinations:\n        </p>\n        <CodeBlock code={deepLinkTestCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Compose UI Testing</h2>\n        <p>\n          Test Compose screens with fake stores to verify UI behavior:\n        </p>\n        <CodeBlock code={composeUiTestCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Navigation State Assertions</h2>\n        <p>\n          Common assertion patterns for verifying navigation state:\n        </p>\n        <CodeBlock code={stateAssertionsCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Best Practices</h2>\n        <ul>\n          <li>Test navigation logic separately from UI</li>\n          <li>Use <code>FakeNavigator</code> for container tests</li>\n          <li>Use <code>TreeNavigator</code> for integration tests</li>\n          <li>Test state transitions, not implementation details</li>\n          <li>Mock repositories and dependencies</li>\n          <li>Test deep link handling with various patterns</li>\n          <li>Verify navigation effects on state</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >FlowMVI & Koin Integration</a> - Learn about MVI container patterns</li>\n          <li><a href= >Navigation Results</a> - Understand navigating for results</li>\n          <li><a href= >Deep Links</a> - Configure deep link handling</li>\n          <li><a href="
  },
  {
    "id": "Features/Transitions/transitions",
    "title": "Transitions",
    "route": "/Features/Transitions/transitions",
    "content": "\n\nconst transitionAnnotationCode = `@Stack(name =  , startDestination = HomeDestination.List::class)\nsealed class HomeDestination : NavDestination {\n\n    @Destination(route =  )\n    data object List : HomeDestination()\n\n    @Transition(type = TransitionType.SlideHorizontal)\n    @Destination(route =  )\n    data class Details(@Argument val id: String) : HomeDestination()\n\n    @Transition(type = TransitionType.SlideVertical)\n    @Destination(route =  )\n    data object Filter : HomeDestination()\n\n    @Transition(type = TransitionType.Fade)\n    @Destination(route =  )\n    data object Help : HomeDestination()\n}`\n\nconst customTransitionBuilderCode = `// Using TransitionBuilder DSL\nval myTransition = customTransition {\n    enter = fadeIn() + expandHorizontally()\n    exit = fadeOut() + shrinkHorizontally()\n    popEnter = fadeIn() + expandHorizontally(expandFrom = Alignment.End)\n    popExit = fadeOut() + shrinkHorizontally(shrinkTowards = Alignment.End)\n}\n\n// Using NavTransition directly\nval scaleAndFade = NavTransition(\n    enter = scaleIn(initialScale = 0.8f) + fadeIn(),\n    exit = scaleOut(targetScale = 1.2f) + fadeOut(),\n    popEnter = scaleIn(initialScale = 1.2f) + fadeIn(),\n    popExit = scaleOut(targetScale = 0.8f) + fadeOut()\n)`\n\nconst dslRegistrationCode = `val config = navigationConfig {\n    transition<DetailScreen>(NavTransition.SlideHorizontal)\n    transition<ModalScreen>(NavTransition.SlideVertical)\n    transition<SettingsScreen>(NavTransition.Fade)\n}`\n\nconst transitionScopeAccessCode = `@Composable\nfun MyScreen() {\n    val transitionScope = LocalTransitionScope.current\n    \n    transitionScope?.let { scope ->\n        // scope.sharedTransitionScope - for sharedElement/sharedBounds\n        // scope.animatedVisibilityScope - for animateEnterExit\n    }\n}`\n\nconst navigationHostCode = `@Composable\nfun NavigationHost(...) {\n    SharedTransitionLayout(modifier = modifier) {\n        // NavRenderScope gets sharedTransitionScope = this\n        NavNodeRenderer(...)\n    }\n}`\n\nconst transitionScopeInterfaceCode = `interface TransitionScope {\n    val sharedTransitionScope: SharedTransitionScope\n    val animatedVisibilityScope: AnimatedVisibilityScope\n}`\n\nconst sharedElementListCode = `@OptIn(ExperimentalSharedTransitionApi::class)\n@Composable\nfun ItemCard(item: Item, onClick: () -> Unit) {\n    val transitionScope = LocalTransitionScope.current\n\n    Card(onClick = onClick) {\n        Row {\n            Icon(\n                imageVector = Icons.Default.AccountCircle,\n                modifier = if (transitionScope != null) {\n                    with(transitionScope.sharedTransitionScope) {\n                        Modifier.sharedElement(\n                            sharedContentState = rememberSharedContentState(\n                                key =  \n                            ),\n                            animatedVisibilityScope = transitionScope.animatedVisibilityScope\n                        )\n                    }\n                } else Modifier\n            )\n            Text(item.title)\n        }\n    }\n}`\n\nconst sharedElementDetailCode = `@Screen(MasterDetailDestination.Detail::class)\n@OptIn(ExperimentalSharedTransitionApi::class)\n@Composable\nfun DetailScreen(destination: MasterDetailDestination.Detail) {\n    val transitionScope = LocalTransitionScope.current\n    val itemId = destination.itemId\n\n    Column {\n        Icon(\n            imageVector = Icons.Default.AccountCircle,\n            modifier = if (transitionScope != null) {\n                with(transitionScope.sharedTransitionScope) {\n                    Modifier.sharedElement(\n                        sharedContentState = rememberSharedContentState(\n                            key =  \n                        ),\n                        animatedVisibilityScope = transitionScope.animatedVisibilityScope\n                    )\n                }\n            } else Modifier\n        )\n        Text( )\n    }\n}`\n\nconst sharedBoundsCode = `// List item card\nCard(\n    modifier = if (transitionScope != null) {\n        with(transitionScope.sharedTransitionScope) {\n            Modifier.sharedBounds(\n                sharedContentState = rememberSharedContentState(\n                    key =  \n                ),\n                animatedVisibilityScope = transitionScope.animatedVisibilityScope\n            )\n        }\n    } else Modifier\n) {\n    // List item content\n}\n\n// Detail card (same key, bounds morph)\nCard(\n    modifier = if (transitionScope != null) {\n        with(transitionScope.sharedTransitionScope) {\n            Modifier.sharedBounds(\n                sharedContentState = rememberSharedContentState(\n                    key =  \n                ),\n                animatedVisibilityScope = transitionScope.animatedVisibilityScope\n            )\n        }\n    } else Modifier\n) {\n    // Expanded detail content\n}`\n\nconst animateEnterExitCode = `@Composable\nfun DetailScreen() {\n    val transitionScope = LocalTransitionScope.current\n\n    Column {\n        // Shared element (morphs)\n        Icon(modifier = sharedElementModifier)\n        \n        // Non-shared content with enter/exit animation\n        Text(\n             ,\n            modifier = Modifier.animateEnterExit(\n                transitionScope,\n                enter = fadeIn(tween(300, delayMillis = 100)),\n                exit = fadeOut(tween(200))\n            )\n        )\n    }\n}\n\n// Helper extension\nprivate fun Modifier.animateEnterExit(\n    transitionScope: TransitionScope?,\n    enter: EnterTransition,\n    exit: ExitTransition\n): Modifier = if (transitionScope != null) {\n    with(transitionScope.animatedVisibilityScope) {\n        this@animateEnterExit.animateEnterExit(enter = enter, exit = exit)\n    }\n} else this`\n\nconst transitionTypeNoneCode = `@Transition(type = TransitionType.None)\n@Destination(route =  >How Transitions Work</h2>\n        <p>\n          Transitions in Quo Vadis are deeply integrated with the tree-based navigation \n          architecture. The system provides smooth, coordinated animations across all \n          navigation contexts.\n        </p>\n        <ul>\n          <li><strong>NavigationHost</strong> wraps content in <code>SharedTransitionLayout</code> for shared element support</li>\n          <li><strong>NavNodeRenderer</strong> dispatches to specialized renderers for each node type</li>\n          <li>Each renderer uses <strong>AnimatedNavContent</strong> for coordinated transitions</li>\n        </ul>\n        <p>\n          This architecture ensures transitions work consistently whether you >@Transition Annotation</h2>\n        <p>\n          Apply transitions per-destination using the <code>@Transition</code> annotation. \n          This allows fine-grained control over how each screen enters and exits.\n        </p>\n        <CodeBlock code={transitionAnnotationCode} language=  />\n        <p>\n          Each destination can specify its own transition type, overriding the default \n          for its navigation context.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Transition Phases</h2>\n        <p>\n          Every transition defines four animation phases to handle both forward \n          navigation (push) and backward navigation (pop):\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Phase</th>\n              <th>Direction</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>enter</code></td>\n              <td>Forward</td>\n              <td>New screen appearing (push)</td>\n            </tr>\n            <tr>\n              <td><code>exit</code></td>\n              <td>Forward</td>\n              <td>Current screen disappearing (push)</td>\n            </tr>\n            <tr>\n              <td><code>popEnter</code></td>\n              <td>Back</td>\n              <td>Previous screen re-appearing (pop)</td>\n            </tr>\n            <tr>\n              <td><code>popExit</code></td>\n              <td>Back</td>\n              <td>Current screen disappearing (pop)</td>\n            </tr>\n          </tbody>\n        </table>\n        <p>\n          This four-phase model ensures animations look correct in both directions, \n          providing a polished user experience.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Custom Transitions</h2>\n        <p>\n          Create custom transitions using either the DSL builder or by constructing \n          <code>NavTransition</code> directly. Compose  />\n        <p>\n          Custom transitions give you complete control over timing, easing, and \n          animation composition for unique navigation effects.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >DSL-based Registration</h2>\n        <p>\n          Register transitions programmatically using the navigation config DSL. \n          This approach works well when transitions are determined at runtime or \n          managed centrally.\n        </p>\n        <CodeBlock code={dslRegistrationCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Context-Specific Behavior</h2>\n        <p>\n          Different navigation contexts use different default transitions optimized \n          for their use case:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Context</th>\n              <th>Default Transition</th>\n              <th>Notes</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Stack navigation</td>\n              <td><code>SlideHorizontal</code></td>\n              <td>Hierarchical push/pop</td>\n            </tr>\n            <tr>\n              <td>Tab switching</td>\n              <td><code>Fade</code></td>\n              <td>Parallel content switching</td>\n            </tr>\n            <tr>\n              <td>Pane transitions</td>\n              <td><code>Fade</code></td>\n              <td>Based on adaptive mode</td>\n            </tr>\n          </tbody>\n        </table>\n        <p>\n          These defaults can be overridden per-destination using the <code>@Transition</code> \n          annotation or programmatically via the DSL.\n        </p>\n      </section>\n\n      {/* =========================================== */}\n      {/* SHARED ELEMENTS SECTION - EXPANDED FROM MERGE */}\n      {/* =========================================== */}\n\n      <section>\n        <h2 id= >Shared Element Transitions</h2>\n        <p>\n          Quo Vadis integrates with Compose >How It Works</h3>\n        <p>\n          <code>NavigationHost</code> automatically wraps content in <code>SharedTransitionLayout</code>, \n          providing the transition scope to all child screens:\n        </p>\n        <CodeBlock code={navigationHostCode} language= >Accessing TransitionScope</h3>\n        <p>\n          Access the transition scope in any screen using <code>LocalTransitionScope</code>:\n        </p>\n        <CodeBlock code={transitionScopeAccessCode} language=  />\n        <p>The <code>TransitionScope</code> interface provides:</p>\n        <CodeBlock code={transitionScopeInterfaceCode} language= >sharedElement vs sharedBounds</h3>\n        <p>Choose the right modifier based on your use case:</p>\n        <table>\n          <thead>\n            <tr>\n              <th>Modifier</th>\n              <th>Use Case</th>\n              <th>Content Behavior</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>sharedElement</code></td>\n              <td>Exact visual matches (same icon, same image)</td>\n              <td>Content stays identical during transition</td>\n            </tr>\n            <tr>\n              <td><code>sharedBounds</code></td>\n              <td>Container morphing (card expanding to full screen)</td>\n              <td>Content can change while bounds morph</td>\n            </tr>\n          </tbody>\n        </table>\n\n        <h3 id= >sharedElement Example</h3>\n        <p>\n          Use <code>sharedElement</code> for icons, images, and other elements that remain \n          visually identical between screens.\n        </p>\n        <h4>List Screen</h4>\n        <CodeBlock code={sharedElementListCode} language=  />\n        <h4>Detail Screen</h4>\n        <CodeBlock code={sharedElementDetailCode} language= >sharedBounds Example</h3>\n        <p>\n          Use <code>sharedBounds</code> for cards and containers where the content changes \n          but the bounds should morph smoothly:\n        </p>\n        <CodeBlock code={sharedBoundsCode} language= >Combining with animateEnterExit</h3>\n        <p>\n          For non-shared content, use <code>animateEnterExit</code> alongside shared elements \n          to create coordinated animations:\n        </p>\n        <CodeBlock code={animateEnterExitCode} language= >Using TransitionType.None</h3>\n        <p>\n          When shared elements are your primary transition effect, disable the default \n          screen transition with <code>TransitionType.None</code>:\n        </p>\n        <CodeBlock code={transitionTypeNoneCode} language=  />\n        <p>\n          This gives you full control of animations using shared elements and <code>animateEnterExit</code>.\n        </p>\n\n        <h3 id= >Key Rules for Shared Elements</h3>\n        <ol>\n          <li><strong>Keys must match exactly</strong> between source and destination screens</li>\n          <li>Use unique, stable identifiers: <code> card-$&#123;itemId&#125; element-type-unique-id </code>)</li>\n          <li>Always handle <code>null</code> gracefully for <code>transitionScope</code></li>\n        </ol>\n      </section>\n\n      <section>\n        <h2 id= >Best Practices</h2>\n        <h3>Screen Transitions</h3>\n        <ul>\n          <li>Use <code>SlideHorizontal</code> for hierarchical navigation</li>\n          <li>Use <code>SlideVertical</code> for modal presentations</li>\n          <li>Use <code>Fade</code> for tab switches and overlays</li>\n          <li>Define all four phases (enter, exit, popEnter, popExit) for custom transitions</li>\n        </ul>\n        <h3>Shared Elements</h3>\n        <ul>\n          <li><strong>Keep keys consistent and predictable</strong> - Use a clear naming convention</li>\n          <li><strong>Use TransitionType.None</strong> when shared elements are the primary transition</li>\n          <li><strong>Test both directions</strong> - Verify forward and backward navigation</li>\n          <li><strong>Don >Next Steps</h2>\n        <ul>\n          <li><Link to= >Predictive Back</Link> - Gesture-driven navigation with preview</li>\n          <li><Link to= >Deep Links</Link> - URL-based navigation</li>\n          <li><Link to="
  },
  {
    "id": "Features/TypeSafe/typesafe",
    "title": "Type Safe",
    "route": "/Features/TypeSafe/typesafe",
    "content": "\n\nconst navigatorInterfaceCode = `@Stable\ninterface Navigator : BackPressHandler {\n    val state: StateFlow<NavNode>\n    val currentDestination: StateFlow<NavDestination?>\n    val previousDestination: StateFlow<NavDestination?>\n    val canNavigateBack: StateFlow<Boolean>\n    val config: NavigationConfig\n\n    fun navigate(destination: NavDestination, transition: NavigationTransition? = null)\n    fun navigateBack(): Boolean\n    fun navigateAndClearTo(destination: NavDestination, clearRoute: String?, inclusive: Boolean)\n    fun navigateAndReplace(destination: NavDestination, transition: NavigationTransition?)\n    fun navigateAndClearAll(destination: NavDestination)\n    fun handleDeepLink(uri: String): Boolean\n}`\n\nconst forwardNavigationCode = `// Simple navigation\nnavigator.navigate(HomeDestination.Article(articleId =  ))\n\n// With explicit transition\nnavigator.navigate(\n    destination = HomeDestination.Article(articleId =  ),\n    transition = NavigationTransitions.SlideHorizontal\n)`\n\nconst backNavigationCode = `val didNavigate = navigator.navigateBack()`\n\nconst clearReplaceCode = `// Navigate and clear back to specific route\nnavigator.navigateAndClearTo(\n    destination = SettingsDestination.Main,\n    clearRoute =  ,\n    inclusive = false\n)\n\n// Replace current screen\nnavigator.navigateAndReplace(\n    destination = ProfileDestination.EditProfile,\n    transition = NavigationTransitions.Fade\n)\n\n// Clear entire backstack\nnavigator.navigateAndClearAll(AuthDestination.Login)`\n\nconst navigationResultsCode = `// Define result-returning destination\ndata class SelectedItem(val id: String, val name: String)\n\n@Destination(route =  )\ndata object ItemPicker : PickerDestination(), ReturnsResult<SelectedItem>\n\n// Navigate for result (suspends until result)\nval result: SelectedItem? = navigator.navigateForResult(ItemPicker)\n\n// Return result and navigate back\nnavigator.navigateBackWithResult(SelectedItem(id =  ))`\n\nconst paneNavigationCode = `// Cast to PaneNavigator for pane operations\nval paneNavigator = navigator.asPaneNavigator()\n\n// Navigate within a specific pane\npaneNavigator?.navigateToPane(\n    MessagesPane.ConversationDetail(conversationId),\n    role = PaneRole.Supporting\n)\n\n// Check pane availability\nif (paneNavigator?.isPaneAvailable(PaneRole.Extra) == true) {\n    // Show extra content\n}`\n\nconst stateObservationCode = `@Composable\nfun NavigationAwareContent(navigator: Navigator) {\n    val currentDest by navigator.currentDestination.collectAsState()\n    val canBack by navigator.canNavigateBack.collectAsState()\n    \n    // UI based on navigation state\n    IconButton(\n        onClick = { navigator.navigateBack() },\n        enabled = canBack\n    ) {\n        Icon(Icons.Default.ArrowBack,  >Navigator Interface</h2>\n        <p>\n          The <code>Navigator</code> interface is the central API for all navigation operations. It exposes \n          reactive state properties and type-safe navigation methods:\n        </p>\n        <CodeBlock code={navigatorInterfaceCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >State Properties</h2>\n        <p>\n          The Navigator exposes several observable properties that allow your UI to react to navigation changes:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Property</th>\n              <th>Type</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>state</code></td>\n              <td><code>StateFlow&lt;NavNode&gt;</code></td>\n              <td>Complete navigation tree (single source of truth)</td>\n            </tr>\n            <tr>\n              <td><code>currentDestination</code></td>\n              <td><code>StateFlow&lt;NavDestination?&gt;</code></td>\n              <td>Active leaf destination</td>\n            </tr>\n            <tr>\n              <td><code>previousDestination</code></td>\n              <td><code>StateFlow&lt;NavDestination?&gt;</code></td>\n              <td>Destination before current</td>\n            </tr>\n            <tr>\n              <td><code>canNavigateBack</code></td>\n              <td><code>StateFlow&lt;Boolean&gt;</code></td>\n              <td>Whether back navigation is possible</td>\n            </tr>\n            <tr>\n              <td><code>config</code></td>\n              <td><code>NavigationConfig</code></td>\n              <td>Navigation configuration</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Navigation Operations</h2>\n        \n        <h3>Forward Navigation</h3>\n        <p>\n          Navigate to a destination using the type-safe <code>navigate()</code> method. \n          Optionally specify a transition animation:\n        </p>\n        <CodeBlock code={forwardNavigationCode} language=  />\n\n        <h3>Back Navigation</h3>\n        <p>\n          Navigate back to the previous screen. Returns <code>true</code> if navigation occurred:\n        </p>\n        <CodeBlock code={backNavigationCode} language=  />\n\n        <h3>Clear and Replace</h3>\n        <p>\n          Advanced navigation operations for managing the back stack:\n        </p>\n        <CodeBlock code={clearReplaceCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Navigation with Results</h2>\n        <p>\n          Quo Vadis supports type-safe result passing between screens using the <code>ReturnsResult</code> interface. \n          The calling screen suspends until a result is returned:\n        </p>\n        <CodeBlock code={navigationResultsCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Pane Navigation</h2>\n        <p>\n          For adaptive layouts on tablets and large screens, cast the Navigator to <code>PaneNavigator</code> \n          to access pane-specific operations:\n        </p>\n        <CodeBlock code={paneNavigationCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >State Observation in Compose</h2>\n        <p>\n          Use <code>collectAsState()</code> to observe navigation state changes and update your UI reactively:\n        </p>\n        <CodeBlock code={stateObservationCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >TreeNavigator Setup</h2>\n        <p>\n          <code>TreeNavigator</code> is the concrete implementation of the Navigator interface. \n          Create it with a configuration and initial state:\n        </p>\n        <CodeBlock code={treeNavigatorSetupCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Multi-Module Configuration</h2>\n        <p>\n          In multi-module projects, combine navigation configs from different features using the <code>+</code> operator:\n        </p>\n        <CodeBlock code={multiModuleConfigCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Koin Integration</h2>\n        <p>\n          Set up the Navigator as a singleton in your Koin module for dependency injection:\n        </p>\n        <CodeBlock code={koinIntegrationCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><Link to= >Annotation-Based API</Link> - Learn about <code>@Destination</code>, <code>@Stack</code>, and code generation</li>\n          <li><Link to= >Tree Architecture</Link> - Understand the navigation tree structure</li>\n          <li><Link to= >Adaptive Navigation</Link> - Build responsive layouts with panes</li>\n          <li><Link to="
  },
  {
    "id": "GettingStarted/gettingstarted",
    "title": "Getting Started",
    "route": "/GettingStarted/gettingstarted",
    "content": "\n\nconst validationExampleError = `Missing @Screen binding for  >Installation</h2>\n\n        <p>\n          Choose one of the following installation methods. The Gradle plugin approach is recommended\n          as it handles KSP configuration automatically.\n        </p>\n\n        <h3 id= >Option 1: Using Gradle Plugin (Recommended)</h3>\n        <p>\n          The Gradle plugin automatically configures KSP and registers generated sources, making setup\n          simpler and more reliable.\n        </p>\n        <CodeBlock code={gradlePluginInstallation} language= >Option 2: Manual Configuration</h3>\n        <p>\n          If you need more control over the build configuration, you can set up KSP manually.\n        </p>\n        <CodeBlock code={manualKspConfiguration} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Define Your Navigation Stack</h2>\n        <p>\n          Create a sealed class extending <code>NavDestination</code> and annotate it with <code>@Stack</code>.\n          Each destination is defined as a nested class with the <code>@Destination</code> annotation.\n        </p>\n        <CodeBlock code={stackDestinationWithSettings} language= >Bind Screens with @Screen</h2>\n        <p>\n          Use the <code>@Screen</code> annotation to connect your composables to destinations.\n          The navigator is automatically injected, and destination data classes receive the destination instance.\n        </p>\n        <CodeBlock code={screenBindingWithImports} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Setup NavigationHost</h2>\n        <p>\n          Finally, set up the <code>NavigationHost</code> in your app  />\n      </section>\n\n      <section>\n        <h2 id= >What Gets Generated</h2>\n        <p>\n          KSP generates several classes based on your annotations. The prefix is configurable\n          via <code>modulePrefix</code> in your Gradle configuration.\n        </p>\n\n        <table>\n          <thead>\n            <tr>\n              <th>Generated Class</th>\n              <th>Purpose</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>{ }NavigationConfig</code></td>\n              <td>Main configuration with all registries</td>\n            </tr>\n            <tr>\n              <td><code>{ }ScreenRegistry</code></td>\n              <td>Maps destinations to composables</td>\n            </tr>\n            <tr>\n              <td><code>{ }DeepLinkHandler</code></td>\n              <td>Handles URI-based navigation</td>\n            </tr>\n            <tr>\n              <td><code>{ }ScopeRegistry</code></td>\n              <td>Scope membership for containers</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Compile-Time Safety</h2>\n        <p>\n          Quo Vadis validates your navigation configuration at compile time. If there are\n          issues with your annotations, the build will fail with clear error messages\n          showing exactly what  />\n        <p>\n          See <Link to= >Validation & Error Messages</Link> for\n          the complete list of validation rules.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <p>\n          Now that you have basic navigation working, explore more advanced features:\n        </p>\n        <ul>\n          <li>\n            <a href= >Annotation API</a> — Full reference for all annotations\n            including <code>@Tabs</code>, <code>@Pane</code>, and more\n          </li>\n          <li>\n            <a href= >Tabbed Navigation</a> — Set up tab-based navigation\n            with independent backstacks\n          </li>\n          <li>\n            <a href= >Transitions</a> — Add custom animations and shared element\n            transitions\n          </li>\n          <li>\n            <a href="
  },
  {
    "id": "Home",
    "title": "Home",
    "route": "/Home",
    "content": ">\n            <img src=  />\n          </a>\n          <a href= >\n            <img src=  />\n          </a>\n          <img src=  />\n          <img src=  />\n          <img src=  />\n          <img src=  />\n          <img src=  />\n          <img src= >View on GitHub</a>\n        </div>\n      </section>\n\n      {/* Overview */}\n      <section>\n        <h2 id= >Overview</h2>\n        <p>\n          <strong>Quo Vadis</strong> (Latin for  ) is a comprehensive, type-safe navigation \n          library for Kotlin Multiplatform and Compose Multiplatform. It uses a tree-based navigation architecture \n          where navigation state is an immutable tree of NavNode objects, providing a clean, intuitive API for \n          managing navigation across Android, iOS, Desktop, and Web platforms with zero string-based routing.\n        </p>\n      </section>\n\n            {/* Why Quo Vadis */}\n      <section>\n        <h2 id= >Show Me The Code!</h2>\n        <p style={{ marginBottom:  >Or Use Manual DSL for Full Control</h2>\n        <p style={{ marginBottom:   }}>\n          Prefer full control? The manual DSL API is still available for advanced use cases:\n        </p>\n        <CodeBlock code={manualDSLCode} language=  />\n      </section>\n\n      {/* Resources */}\n      <section>\n        <h2 id= >Resources</h2>\n        <ul>\n          <li><Link to= >Getting Started Guide</Link> - Installation and basic setup</li>\n          <li><Link to= >Features Documentation</Link> - Detailed feature explanations</li>\n          <li><a href= >API Reference</a> - Complete API documentation</li>\n          <li><Link to= >Demo Application</Link> - See all features in action</li>\n          <li><a href="
  }
]