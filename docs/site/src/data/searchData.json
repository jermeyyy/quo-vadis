[
  {
    "id": "Demo/demo",
    "title": "Demo",
    "route": "/Demo/demo",
    "content": "@components/CodeBlock/CodeBlock \n\nconst bottomNavCode = `val bottomNavGraph = navigationGraph( ) {\n        startDestination(HomeDestination.Main)\n        destination(HomeDestination.Main) { _, nav -> HomeScreen(nav) }\n        destination(HomeDestination.Details) { _, nav -> DetailsScreen(nav) }\n    }\n    \n    tab( ) {\n        startDestination(ProfileDestination.Main)\n        destination(ProfileDestination.Main) { _, nav -> ProfileScreen(nav) }\n    }\n    \n    tab( ) {\n        startDestination(SettingsDestination.Main)\n        destination(SettingsDestination.Main) { _, nav -> SettingsScreen(nav) }\n    }\n}`\n\nconst masterDetailCode = `// List screen\nLazyColumn {\n    items(products) { product ->\n        ProductCard(\n            product = product,\n            onClick = { \n                navigator.navigate(ProductDestination.Details(product.id)) \n            },\n            imageModifier = Modifier.sharedElement(\n                sharedConfig = SharedElementConfig(\n                    key =  ,\n                    type = SharedElementType.Bounds\n                ),\n                navigator = navigator\n            )\n        )\n    }\n}`\n\nconst multiStepCode = `sealed class ProcessStep : Destination {\n    object Step1 : ProcessStep() { override val route =   }\n    object Step2 : ProcessStep() { override val route =   }\n    object Step3 : ProcessStep() { override val route =   }\n    object Complete : ProcessStep() { override val route =   }\n}\n\n// Navigate forward through steps\nfun onNext(currentStep: ProcessStep) {\n    when (currentStep) {\n        is ProcessStep.Step1 -> navigator.navigate(ProcessStep.Step2)\n        is ProcessStep.Step2 -> navigator.navigate(ProcessStep.Step3)\n        is ProcessStep.Step3 -> navigator.navigateAndClearTo(\n            destination = ProcessStep.Complete,\n            clearRoute =  ,\n            inclusive = false\n        )\n    }\n}`\n\nconst cloneRunCode = `# Clone the repository\ngit clone https://github.com/jermeyyy/quo-vadis.git\ncd quo-vadis\n\n# Run on Android\n./gradlew :composeApp:installDebug\n\n# Run on iOS (macOS only)\nopen iosApp/iosApp.xcodeproj\n\n# Run on Desktop\n./gradlew :composeApp:run\n\n# Run on Web (JavaScript)\n./gradlew :composeApp:jsBrowserDevelopmentRun\n\n# Run on Web (WebAssembly)\n./gradlew :composeApp:wasmJsBrowserDevelopmentRun`\n\nconst mainAppCode = `@Composable\nfun DemoApp() {\n    val navigator = rememberNavigator(startDestination = MainDestination.Home)\n    \n    Scaffold(\n        bottomBar = {\n            BottomNavigationBar(\n                currentRoute = navigator.currentDestination.value?.route,\n                onTabSelected = { destination ->\n                    navigator.navigate(destination)\n                }\n            )\n        }\n    ) { paddingValues ->\n        NavigationHost(\n            navigator = navigator,\n            screenRegistry = MainDestinationScreenRegistry,\n            modifier = Modifier.padding(paddingValues),\n            defaultTransition = NavigationTransitions.SlideHorizontal,\n            predictiveBackMode = PredictiveBackMode.FULL_CASCADE\n        )\n    }\n}`\n\nconst featureModuleCode = `// Using annotation-based API\n@Graph( )\nsealed class ProductDestination : Destination\n\n@Route( )\ndata object ProductList : ProductDestination()\n\n@Serializable\ndata class ProductDetailsData(val productId: String)\n\n@Route( >Navigation Patterns Demonstrated</h2>\n        \n        <h3 id= >1. Bottom Navigation Pattern</h3>\n        <p>\n          The demo uses bottom navigation for main app sections (Home, Profile, Settings). \n          Each tab is represented as a child of a TabNode in the NavNode tree, maintaining \n          independent navigation stacks within each tab.\n        </p>\n        <CodeBlock code={bottomNavCode} language= >2. Master-Detail Flow</h3>\n        <p>\n          Classic list-to-detail pattern enhanced with shared element transitions. \n          Images and text smoothly animate from the list to the detail screen.\n        </p>\n        <CodeBlock code={masterDetailCode} language= >3. Multi-Step Process</h3>\n        <p>\n          Wizard-style flows are handled elegantly with TreeMutator operations. \n          The demo includes validation, progress tracking, and the ability to jump \n          to specific steps using immutable state transformations.\n        </p>\n        <CodeBlock code={multiStepCode} language= >4. Nested Navigation</h3>\n        <p>\n          The demo shows how to implement tabs within tabs using nested TabNode and \n          StackNode structures in the NavNode tree. Each level of navigation is independent \n          and maintains its own state.\n        </p>\n\n        <h3 id= >5. Transition Showcase</h3>\n        <p>A dedicated screen demonstrates all available transitions:</p>\n        <ul>\n          <li><strong>Slide Horizontal:</strong> Standard left/right slide</li>\n          <li><strong>Slide Vertical:</strong> Bottom-up modal style</li>\n          <li><strong>Fade:</strong> Simple cross-fade</li>\n          <li><strong>Fade Through:</strong> Material Design fade through</li>\n          <li><strong>Scale In:</strong> Zoom-in effect</li>\n          <li><strong>Custom:</strong> User-defined transitions</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Running the Demo</h2>\n        \n        <h3>Prerequisites</h3>\n        <ul>\n          <li>Kotlin 2.2.20+</li>\n          <li>Android Studio or IntelliJ IDEA</li>\n          <li>For iOS: macOS with Xcode installed</li>\n        </ul>\n\n        <h3>Clone and Run</h3>\n        <CodeBlock code={cloneRunCode} language= >Code Examples from Demo</h2>\n        \n        <h3>Main Application Structure</h3>\n        <CodeBlock code={mainAppCode} language=  />\n\n        <h3>Feature Module Example</h3>\n        <CodeBlock code={featureModuleCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Explore More</h2>\n        <ul>\n          <li><a href= >Demo Source Code</a> - Full implementation on GitHub</li>\n          <li><a href= >Getting Started</a> - Build your own navigation</li>\n          <li><a href= >Features</a> - Learn about all capabilities</li>\n          <li><a href="
  },
  {
    "id": "Features/AnnotationAPI/annotationapi",
    "title": "Annotation A P I",
    "route": "/Features/AnnotationAPI/annotationapi",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css , startDestination = HomeDestination.Feed::class)\nsealed class HomeDestination : NavDestination {\n    // Destinations defined here\n}`\n\nconst destinationExample = `@Stack(name =  , startDestination = HomeDestination.Feed::class)\nsealed class HomeDestination : NavDestination {\n\n    // Simple destination (no arguments)\n    @Destination(route =  )\n    data object Feed : HomeDestination()\n\n    // Destination with a path parameter\n    @Destination(route =  )\n    data class Article(@Argument val articleId: String) : HomeDestination()\n\n    // Destination with multiple parameters\n    @Destination(route =  )\n    data class UserPost(\n        @Argument val userId: String,\n        @Argument val postId: String\n    ) : HomeDestination()\n}`\n\nconst argumentExample = `@Destination(route =  )\ndata class ProductDetail(\n    @Argument val id: String,                              // Required argument\n    @Argument(optional = true) val referrer: String? = null,  // Optional argument\n    @Argument(key =  ) val showReviews: Boolean = false  // Custom URL key\n) : ProductsDestination()`\n\nconst screenExample = `// Simple destination (data object) - navigator only\n@Screen(HomeDestination.Feed::class)\n@Composable\nfun FeedScreen(navigator: Navigator) {\n    Column {\n        Text( )\n        Button(onClick = { navigator.navigate(HomeDestination.Article( )) }) {\n            Text( )\n        }\n    }\n}\n\n// Destination with arguments (data class) - access destination data\n@Screen(HomeDestination.Article::class)\n@Composable\nfun ArticleScreen(\n    destination: HomeDestination.Article,\n    navigator: Navigator\n) {\n    Column {\n        Text( )\n        Button(onClick = { navigator.navigateBack() }) {\n            Text( )\n        }\n    }\n}`\n\nconst tabsExample = `@Tabs(\n    name =  ,\n    initialTab = MainTabs.HomeTab::class,\n    items = [MainTabs.HomeTab::class, MainTabs.ExploreTab::class, MainTabs.ProfileTab::class]\n)\nsealed class MainTabs : NavDestination {\n\n    @TabItem(label =  )\n    @Destination(route =  )\n    data object HomeTab : MainTabs()\n\n    @TabItem(label =  )\n    @Destination(route =  )\n    data object ExploreTab : MainTabs()\n\n    @TabItem(label =  )\n    @Destination(route =  )\n    data object ProfileTab : MainTabs()\n}`\n\nconst tabsContainerExample = `@TabsContainer(MainTabs::class)\n@Composable\nfun MainTabsWrapper(\n    scope: TabsContainerScope,\n    content: @Composable () -> Unit\n) {\n    Scaffold(\n        bottomBar = {\n            NavigationBar {\n                scope.tabMetadata.forEachIndexed { index, meta ->\n                    NavigationBarItem(\n                        selected = index == scope.activeTabIndex,\n                        onClick = { scope.switchTab(index) },\n                        icon = { Icon(getIcon(meta.icon), meta.label) },\n                        label = { Text(meta.label) }\n                    )\n                }\n            }\n        }\n    ) { padding ->\n        Box(Modifier.padding(padding)) { content() }\n    }\n}`\n\nconst paneExample = `@Pane(name =  , backBehavior = PaneBackBehavior.PopUntilContentChange)\nsealed class MessagesPane : NavDestination {\n\n    @PaneItem(role = PaneRole.PRIMARY)\n    @Destination(route =  )\n    data object ConversationList : MessagesPane()\n\n    @PaneItem(role = PaneRole.SECONDARY, adaptStrategy = AdaptStrategy.OVERLAY)\n    @Destination(route =  )\n    data class ConversationDetail(\n        @Argument val id: String\n    ) : MessagesPane()\n}`\n\nconst paneContainerExample = `@PaneContainer(MessagesPane::class)\n@Composable\nfun MessagesPaneContainer(\n    scope: PaneContainerScope,\n    content: @Composable () -> Unit\n) {\n    if (scope.isExpanded) {\n        Row(modifier = Modifier.fillMaxSize()) {\n            scope.paneContents.filter { it.isVisible }.forEach { pane ->\n                Box(\n                    modifier = Modifier.weight(\n                        if (pane.role == PaneRole.PRIMARY) 0.4f else 0.6f\n                    )\n                ) {\n                    pane.content()\n                }\n            }\n        }\n    } else {\n        content()  // Single pane mode\n    }\n}`\n\nconst transitionExample = `@Transition(type = TransitionType.SlideHorizontal)\n@Destination(route =  )\ndata class Details(@Argument val id: String) : HomeDestination()\n\n@Transition(type = TransitionType.SlideVertical)\n@Destination(route =  )\ndata object Modal : HomeDestination()\n\n@Transition(type = TransitionType.Fade)\n@Destination(route =  )\ndata object Help : HomeDestination()\n\n@Transition(type = TransitionType.None)\n@Destination(route =  )\ndata object InstantSwitch : HomeDestination()`\n\nconst generatedExample = `// Generated NavigationConfig usage\nval navigator = TreeNavigator(\n    config = GeneratedNavigationConfig,\n    initialState = GeneratedNavigationConfig.buildNavNode(\n        HomeDestination::class, \n        null\n    )!!\n)\n\n// Type-safe navigation (generated)\nnavigator.navigate(HomeDestination.Article(articleId =  ))\nnavigator.navigate(MainTabs.ProfileTab)`\n\nconst completeExample = `// Define a stack with destinations\n@Stack(name =  , startDestination = AppDestination.Main::class)\nsealed class AppDestination : NavDestination {\n\n    @Destination(route =  )\n    data object Main : AppDestination()\n\n    @Transition(type = TransitionType.SlideHorizontal)\n    @Destination(route =  )\n    data class Detail(\n        @Argument val itemId: String,\n        @Argument(optional = true) val highlight: Boolean = false\n    ) : AppDestination()\n\n    @Transition(type = TransitionType.SlideVertical)\n    @Destination(route =  )\n    data object Settings : AppDestination()\n}\n\n// Bind screens to destinations\n@Screen(AppDestination.Main::class)\n@Composable\nfun MainScreen(navigator: Navigator) {\n    Column {\n        Text( )\n        Button(onClick = { navigator.navigate(AppDestination.Detail( )) }) {\n            Text( )\n        }\n        Button(onClick = { navigator.navigate(AppDestination.Settings) }) {\n            Text( )\n        }\n    }\n}\n\n@Screen(AppDestination.Detail::class)\n@Composable\nfun DetailScreen(destination: AppDestination.Detail, navigator: Navigator) {\n    Column {\n        Text( )\n        if (destination.highlight) {\n            Text( )\n        }\n        Button(onClick = { navigator.navigateBack() }) {\n            Text( )\n        }\n    }\n}\n\n@Screen(AppDestination.Settings::class)\n@Composable\nfun SettingsScreen(navigator: Navigator) {\n    Column {\n        Text( )\n        Button(onClick = { navigator.navigateBack() }) {\n            Text( >@Stack Annotation</h2>\n        <p>\n          The <code>@Stack</code> annotation defines a navigation stack — a collection of destinations \n          that supports push and pop operations. Every navigation graph starts with a stack.\n        </p>\n\n        <CodeBlock code={stackExample} language=  />\n\n        <h3>Properties</h3>\n        <ul>\n          <li><code>name: String</code> — Unique identifier for the stack</li>\n          <li><code>startDestination: KClass&lt;*&gt;</code> — The initial destination when the stack is created</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >@Destination Annotation</h2>\n        <p>\n          The <code>@Destination</code> annotation marks a class as a navigation destination. \n          Use <code>data object</code> for destinations without arguments and <code>data class</code> for those with arguments.\n        </p>\n\n        <CodeBlock code={destinationExample} language=  />\n\n        <h3>Route Patterns</h3>\n        <ul>\n          <li><strong>Static route:</strong> <code> </code> — No parameters</li>\n          <li><strong>Path parameter:</strong> <code> </code> — Required parameter in URL path</li>\n          <li><strong>Multiple parameters:</strong> <code> </code> — Multiple path params</li>\n          <li><strong>Empty route:</strong> Omit or use <code> </code> for destinations that aren >@Argument Annotation</h2>\n        <p>\n          The <code>@Argument</code> annotation marks constructor parameters as navigation arguments. \n          These are automatically serialized for deep linking and state restoration.\n        </p>\n\n        <CodeBlock code={argumentExample} language=  />\n\n        <h3>Properties</h3>\n        <ul>\n          <li><code>key: String</code> — Custom URL parameter key (defaults to property name)</li>\n          <li><code>optional: Boolean</code> — Whether the argument can be omitted in deep links</li>\n        </ul>\n\n        <h3>Supported Types</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>Type</th>\n              <th>Example</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr><td>String</td><td><code>@Argument val id: String</code></td></tr>\n            <tr><td>Int</td><td><code>@Argument val count: Int</code></td></tr>\n            <tr><td>Long</td><td><code>@Argument val timestamp: Long</code></td></tr>\n            <tr><td>Float</td><td><code>@Argument val rating: Float</code></td></tr>\n            <tr><td>Double</td><td><code>@Argument val price: Double</code></td></tr>\n            <tr><td>Boolean</td><td><code>@Argument val enabled: Boolean</code></td></tr>\n            <tr><td>Enum</td><td><code>@Argument val status: OrderStatus</code></td></tr>\n            <tr><td>@Serializable</td><td><code>@Argument val filter: FilterData</code></td></tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >@Screen Annotation</h2>\n        <p>\n          The <code>@Screen</code> annotation binds a composable function to render a specific destination. \n          The function can receive the navigator and the destination instance as parameters.\n        </p>\n\n        <CodeBlock code={screenExample} language=  />\n\n        <h3>Function Parameters</h3>\n        <ul>\n          <li><code>navigator: Navigator</code> — The navigation controller for performing navigation actions</li>\n          <li><code>destination: T</code> — The destination instance (for data class destinations with arguments)</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >@Tabs and @TabItem Annotations</h2>\n        <p>\n          For tabbed navigation where each tab maintains its own backstack. \n          Use <code>@Tabs</code> on the sealed class and <code>@TabItem</code> on each tab destination.\n        </p>\n\n        <CodeBlock code={tabsExample} language=  />\n\n        <h3>@Tabs Properties</h3>\n        <ul>\n          <li><code>name: String</code> — Unique identifier for the tab container</li>\n          <li><code>initialTab: KClass&lt;*&gt;</code> — The initially selected tab</li>\n          <li><code>items: Array&lt;KClass&lt;*&gt;&gt;</code> — Tab classes in display order</li>\n        </ul>\n\n        <h3>@TabItem Properties</h3>\n        <ul>\n          <li><code>label: String</code> — Display label for the tab</li>\n          <li><code>icon: String</code> — Icon identifier for the tab</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >@TabsContainer Annotation</h2>\n        <p>\n          Define a custom tab bar UI with <code>@TabsContainer</code>. \n          The composable receives a scope with tab metadata and switching functionality.\n        </p>\n\n        <CodeBlock code={tabsContainerExample} language=  />\n\n        <h3>TabsContainerScope</h3>\n        <ul>\n          <li><code>tabMetadata: List&lt;TabMetadata&gt;</code> — Label and icon info for each tab</li>\n          <li><code>activeTabIndex: Int</code> — Currently selected tab index</li>\n          <li><code>switchTab(index: Int)</code> — Function to switch to a different tab</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >@Pane and @PaneItem Annotations</h2>\n        <p>\n          For adaptive multi-pane layouts that adjust based on screen size. \n          Use <code>@Pane</code> on the sealed class and <code>@PaneItem</code> on each pane destination.\n        </p>\n\n        <CodeBlock code={paneExample} language=  />\n\n        <h3>@Pane Properties</h3>\n        <ul>\n          <li><code>name: String</code> — Unique identifier for the pane container</li>\n          <li><code>backBehavior: PaneBackBehavior</code> — Back navigation strategy</li>\n        </ul>\n\n        <h3>@PaneItem Properties</h3>\n        <ul>\n          <li><code>role: PaneRole</code> — <code>PRIMARY</code>, <code>SECONDARY</code>, or <code>EXTRA</code></li>\n          <li><code>adaptStrategy: AdaptStrategy</code> — <code>HIDE</code>, <code>COLLAPSE</code>, <code>OVERLAY</code>, or <code>REFLOW</code></li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >@PaneContainer Annotation</h2>\n        <p>\n          Define custom pane layout behavior with <code>@PaneContainer</code>. \n          Control how panes are arranged based on screen size.\n        </p>\n\n        <CodeBlock code={paneContainerExample} language=  />\n      </section>\n\n      <section>\n        <h2 id= >@Transition Annotation</h2>\n        <p>\n          Specify transition animations for destinations with <code>@Transition</code>. \n          Different destinations can have different transition styles.\n        </p>\n\n        <CodeBlock code={transitionExample} language= >What Gets Generated</h2>\n        <p>\n          The KSP processor generates several components from your annotated classes:\n        </p>\n\n        <ul>\n          <li><strong>NavigationConfig:</strong> Central configuration object containing all routes and screen mappings</li>\n          <li><strong>ScreenRegistry:</strong> Maps destinations to their composable screens</li>\n          <li><strong>RouteParser:</strong> Handles deep link parsing and argument extraction</li>\n          <li><strong>NavNode Builders:</strong> Functions to construct the navigation tree</li>\n          <li><strong>Type-safe Extensions:</strong> Generated <code>navigate()</code> extensions for each destination</li>\n        </ul>\n\n        <CodeBlock code={generatedExample} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Complete Example</h2>\n        <p>\n          Here  />\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Get started</a> with the quick start guide</li>\n          <li><a href= >Type-Safe Navigation</a> — Learn about programmatic destination building</li>\n          <li><a href= >Deep Linking</a> — Configure deep link handling</li>\n          <li><a href= >Transitions</a> — Customize navigation animations</li>\n          <li><a href="
  },
  {
    "id": "Features/BackStack/backstack",
    "title": "Back Stack",
    "route": "/Features/BackStack/backstack",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css )\n\n// Get active path from root to leaf\nval path: List<NavNode> = rootNode.activePathToLeaf()\n\n// Get deepest active screen\nval activeScreen: ScreenNode? = rootNode.activeLeaf()\n\n// Get active stack (for push/pop operations)\nval stack: StackNode? = rootNode.activeStack()\n\n// Get all screens in subtree\nval screens: List<ScreenNode> = rootNode.allScreens()\n\n// Check if node can handle back internally\nval canHandleBack: Boolean = rootNode.canHandleBackInternally()`\n\nconst navigatorBackCode = `// Simple back navigation\nnavigator.navigateBack()\n\n// Navigate and clear to specific point\nnavigator.navigateAndClearTo(\n    destination = HomeDestination.Feed,\n    clearRoute =  ,\n    inclusive = true\n)\n\n// Replace current screen\nnavigator.navigateAndReplace(\n    destination = ProfileDestination.Edit,\n    transition = NavigationTransitions.Fade\n)\n\n// Clear entire backstack\nnavigator.navigateAndClearAll(AuthDestination.Login)`\n\nconst treeMutatorCode = `// Push onto active stack\nval newTree = TreeMutator.push(currentTree, destination)\nnavigator.updateState(newTree, transition)\n\n// Pop from active stack\nval newTree = TreeMutator.pop(currentTree, PopBehavior.CASCADE)\n\n// Pop to specific destination type\nval newTree = TreeMutator.popToDestination<HomeDestination>(currentTree, inclusive = false)\n\n// Pop to route string\nval newTree = TreeMutator.popToRoute(currentTree,  , inclusive = false)\n\n// Push multiple destinations\nval newTree = TreeMutator.pushAll(currentTree, listOf(\n    OrderListDestination,\n    OrderDetailDestination( ),\n    TrackingDestination( )\n))\n\n// Clear and push\nval newTree = TreeMutator.clearAndPush(currentTree, HomeDestination.Feed)\n\n// Replace current\nval newTree = TreeMutator.replaceCurrent(currentTree, DashboardDestination)`\n\nconst tabOperationsCode = `// Switch to specific tab\nval newTree = TreeMutator.switchTab(currentTree, tabNodeKey, newIndex)\n\n// Switch active TabNode >NavNode Types</h2>\n        <p>\n          Each node type serves a specific navigation pattern:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Type</th>\n              <th>Purpose</th>\n              <th>Contains</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>ScreenNode</code></td>\n              <td>Leaf destination</td>\n              <td>Destination data</td>\n            </tr>\n            <tr>\n              <td><code>StackNode</code></td>\n              <td>Linear navigation</td>\n              <td>List of children (last = active)</td>\n            </tr>\n            <tr>\n              <td><code>TabNode</code></td>\n              <td>Parallel tabs</td>\n              <td>List of StackNodes</td>\n            </tr>\n            <tr>\n              <td><code>PaneNode</code></td>\n              <td>Adaptive panes</td>\n              <td>Map of PaneRole to PaneConfiguration</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Tree Traversal Extensions</h2>\n        <p>\n          NavNode provides extension functions for traversing and querying the tree:\n        </p>\n        <CodeBlock code={treeTraversalCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Navigator Back Operations</h2>\n        <p>\n          Navigator provides high-level methods for common back navigation scenarios:\n        </p>\n        <CodeBlock code={navigatorBackCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >TreeMutator Operations</h2>\n        <p>\n          For advanced scenarios, use TreeMutator  />\n      </section>\n\n      <section>\n        <h2 id= >PopBehavior Options</h2>\n        <p>\n          Control how empty stacks are handled after a pop operation:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Behavior</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>PRESERVE_EMPTY</code></td>\n              <td>Keep empty stacks in place</td>\n            </tr>\n            <tr>\n              <td><code>CASCADE</code></td>\n              <td>Remove empty stacks, cascading up the tree</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Tab Operations</h2>\n        <p>\n          TreeMutator provides operations for tab-based navigation:\n        </p>\n        <CodeBlock code={tabOperationsCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Pane Operations</h2>\n        <p>\n          For adaptive multi-pane layouts, use pane-specific operations:\n        </p>\n        <CodeBlock code={paneOperationsCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Back Navigation with Tab Awareness</h2>\n        <p>\n          Handle back navigation that properly accounts for tab state:\n        </p>\n        <CodeBlock code={backWithTabsCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >BackResult Types</h2>\n        <p>\n          The <code>popWithTabBehavior</code> function returns a sealed class indicating the result:\n        </p>\n        <CodeBlock code={backResultCode} language=  />\n        <ul>\n          <li><strong>Handled:</strong> Back was processed, apply the new state</li>\n          <li><strong>DelegateToSystem:</strong> Let the platform handle back (e.g., exit app)</li>\n          <li><strong>CannotHandle:</strong> Navigation cannot process this back gesture</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Checking Back Availability</h2>\n        <p>\n          Check whether back navigation is possible before showing UI elements:\n        </p>\n        <CodeBlock code={checkBackCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Best Practices</h2>\n        <ul>\n          <li><strong>Use Navigator for standard operations:</strong> It handles common cases and provides type safety</li>\n          <li><strong>Use TreeMutator for batch operations:</strong> When you need multiple mutations or custom logic</li>\n          <li><strong>The original tree is never modified:</strong> All operations are immutable</li>\n          <li><strong>Unchanged subtrees are reused:</strong> Structural sharing ensures efficiency</li>\n          <li><strong>All TreeMutator operations are thread-safe:</strong> Pure functions can be called from any context</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Tabbed Navigation</a> - Deep dive into TabNode patterns</li>\n          <li><a href= >Multi-Pane Layouts</a> - Adaptive pane navigation</li>\n          <li><a href= >Transitions</a> - Animate navigation changes</li>\n          <li><a href="
  },
  {
    "id": "Features/DIIntegration/diintegration",
    "title": "D I Integration",
    "route": "/Features/DIIntegration/diintegration",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css No container registered for MainTabs >Navigator Registration</h2>\n        <p>\n          Register the <code>Navigator</code> as a singleton in Koin. Combine multiple \n          <code>NavigationConfig</code> instances from different feature modules using the \n          <code>+</code> operator:\n        </p>\n        <CodeBlock code={navigatorRegistrationCode} language=  />\n        <p>\n          The <code>NavigationConfig</code> handles route resolution, destination mapping, \n          and container registration. The <code>TreeNavigator</code> is initialized with \n          the combined config and builds the initial navigation tree from the start destination.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Screen-Scoped Containers</h2>\n        <p>\n          Use <code>navigationContainer</code> to register MVI containers that are tied \n          to individual screen lifecycles. The container is created when the screen enters \n          composition and destroyed when removed from the navigation tree.\n        </p>\n        <CodeBlock code={screenScopedContainerCode} language=  />\n        <p>\n          The <code>NavigationContainerScope</code> provides access to:\n        </p>\n        <ul>\n          <li><code>navigator</code> - Navigator instance for navigation operations</li>\n          <li><code>screenKey</code> - Unique identifier for this screen instance</li>\n          <li><code>coroutineScope</code> - Scope tied to screen lifecycle</li>\n          <li><code>get()</code> - Inject dependencies from parent Koin scope</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Container-Scoped Containers</h2>\n        <p>\n          Use <code>sharedNavigationContainer</code> for state shared across all screens \n          within a Tab or Pane container. The container lives as long as the TabNode/PaneNode.\n        </p>\n        <CodeBlock code={containerScopedCode} language=  />\n        <p>\n          Shared containers are perfect for:\n        </p>\n        <ul>\n          <li>Tab-wide notification badges</li>\n          <li>Master-detail selection state</li>\n          <li>Cross-screen communication</li>\n          <li>Shared preferences within a container</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Multi-Module Organization</h2>\n        <p>\n          Organize container registrations by feature module for clean separation of concerns:\n        </p>\n        <CodeBlock code={multiModuleCode} language=  />\n        <p>\n          Each feature module exports its own Koin module containing containers and \n          dependencies. The app module combines all feature modules during Koin initialization.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Injecting Navigator in Screens</h2>\n        <p>\n          Inject the <code>Navigator</code> directly into screen composables using \n          <code>koinInject()</code>:\n        </p>\n        <CodeBlock code={navigatorInjectionCode} language=  />\n        <p>\n          When using the <code>@Screen</code> annotation, the Navigator can also be \n          provided as a parameter automatically by the code generator.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Scope Lifecycle</h2>\n        <p>\n          Koin scopes are automatically tied to navigation node lifecycle:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Scope Type</th>\n              <th>Created When</th>\n              <th>Destroyed When</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Screen scope</td>\n              <td>Screen enters composition</td>\n              <td>Screen removed from navigation tree</td>\n            </tr>\n            <tr>\n              <td>Container scope</td>\n              <td>TabNode/PaneNode is created</td>\n              <td>TabNode/PaneNode is destroyed</td>\n            </tr>\n          </tbody>\n        </table>\n        <p>\n          When a scope is closed:\n        </p>\n        <ul>\n          <li>The associated <code>CoroutineScope</code> is cancelled</li>\n          <li>All ongoing operations are stopped</li>\n          <li>Container instances are garbage collected</li>\n          <li>Resources are automatically cleaned up</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Complete App Setup</h2>\n        <p>\n          Here  />\n      </section>\n\n      <section>\n        <h2 id= >Best Practices</h2>\n        <ul>\n          <li><strong>Register Navigator as singleton</strong> - One Navigator instance per app</li>\n          <li><strong>Use <code>scope.get()</code></strong> - Inject dependencies from Koin scope, not directly</li>\n          <li><strong>Keep container factories simple</strong> - Defer complex logic to the container itself</li>\n          <li><strong>Organize modules by feature</strong> - One Koin module per feature for maintainability</li>\n          <li><strong>Don >Next Steps</h2>\n        <ul>\n          <li><a href= >FlowMVI Integration</a> - MVI state management with containers</li>\n          <li><a href= >Modular Architecture</a> - Structure your features</li>\n          <li><a href="
  },
  {
    "id": "Features/DeepLinks/deeplinks",
    "title": "Deep Links",
    "route": "/Features/DeepLinks/deeplinks",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css , startDestination = Feed::class)\nsealed class HomeDestination : NavDestination {\n\n    @Destination(route =  )\n    data object Feed : HomeDestination()\n\n    // Path parameters\n    @Destination(route =  )\n    data class Article(\n        @Argument val articleId: String\n    ) : HomeDestination()\n\n    // Multiple path parameters\n    @Destination(route =  )\n    data class UserPost(\n        @Argument val userId: String,\n        @Argument val postId: String\n    ) : HomeDestination()\n\n    // Query parameters\n    @Destination(route =  )\n    data class Search(\n        @Argument val query: String,\n        @Argument(optional = true) val page: Int = 1,\n        @Argument(optional = true) val sortAsc: Boolean = true\n    ) : HomeDestination()\n}`\n\nconst argumentAnnotationCode = `@Destination(route =  )\ndata class Detail(\n    @Argument val id: String,                    // Required, maps to {id}\n    @Argument(key =  ) val referrer: String? = null,  // Custom key\n    @Argument(optional = true) val showReviews: Boolean = false  // Optional\n) : ProductsDestination()\n\n// Deep link: app://products/detail/123?ref=home&showReviews=true`\n\nconst handlingDeepLinksCode = `// Handle incoming URI string\nval handled = navigator.handleDeepLink( )\n\nif (!handled) {\n    showError( )\n}\n\n// Using DeepLink object\nval deepLink = DeepLink.parse( )\nnavigator.handleDeepLink(deepLink)`\n\nconst runtimeRegistrationCode = `@Composable\nfun MyScreen() {\n    LaunchedEffect(Unit) {\n        navigator.getDeepLinkRegistry().register( ) { params ->\n            PromoDestination(code = params[ ]!!)\n        }\n    }\n}\n\n// Now   navigates to PromoDestination( )`\n\nconst androidManifestCode = `<!-- AndroidManifest.xml -->\n<activity ...>\n    <intent-filter android:autoVerify= >\n        <action android:name=  />\n        <category android:name=  />\n        <category android:name=  />\n        <data android:scheme=  />\n        <data android:scheme= >Defining Deep Link Routes</h2>\n        <p>\n          Define deep link routes using the <code>route</code> parameter in your{ }\n          <code>@Destination</code> annotations. Path parameters are enclosed in curly \n          braces and automatically extracted during navigation.\n        </p>\n        <CodeBlock code={definingRoutesCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Route Pattern Syntax</h2>\n        <p>\n          Quo Vadis supports flexible route patterns for matching incoming deep links:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Pattern</th>\n              <th>Example</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Static</td>\n              <td><code> </code></td>\n              <td>Exact match</td>\n            </tr>\n            <tr>\n              <td>Path parameter</td>\n              <td><code> </code></td>\n              <td>Extracts value from path</td>\n            </tr>\n            <tr>\n              <td>Multiple params</td>\n              <td><code> </code></td>\n              <td>Multiple path segments</td>\n            </tr>\n            <tr>\n              <td>Query params</td>\n              <td><code> </code></td>\n              <td>Query string parameters</td>\n            </tr>\n            <tr>\n              <td>Optional</td>\n              <td>(with <code>@Argument(optional = true)</code>)</td>\n              <td>Can be omitted</td>\n            </tr>\n            <tr>\n              <td>Not deep-linkable</td>\n              <td>(empty route)</td>\n              <td>Internal destination only</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >@Argument for Deep Links</h2>\n        <p>\n          The <code>@Argument</code> annotation configures how parameters are extracted \n          from deep links and serialized for navigation state.\n        </p>\n        <CodeBlock code={argumentAnnotationCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Supported Argument Types</h2>\n        <p>\n          Quo Vadis automatically handles serialization and deserialization for common types:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Type</th>\n              <th>Serialization</th>\n              <th>Notes</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>String</code></td>\n              <td>Direct</td>\n              <td>No conversion</td>\n            </tr>\n            <tr>\n              <td><code>Int</code>, <code>Long</code>, <code>Float</code>, <code>Double</code></td>\n              <td><code>.toString()</code> / <code>.toXxx()</code></td>\n              <td>Numeric conversion</td>\n            </tr>\n            <tr>\n              <td><code>Boolean</code></td>\n              <td><code> </code></td>\n              <td>Case-insensitive</td>\n            </tr>\n            <tr>\n              <td><code>Enum&lt;T&gt;</code></td>\n              <td><code>.name</code> / <code>enumValueOf()</code></td>\n              <td>Enum name</td>\n            </tr>\n            <tr>\n              <td><code>@Serializable</code></td>\n              <td>JSON</td>\n              <td>kotlinx.serialization</td>\n            </tr>\n            <tr>\n              <td><code>List&lt;T&gt;</code>, <code>Set&lt;T&gt;</code></td>\n              <td>JSON</td>\n              <td>Where T is serializable</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Handling Deep Links</h2>\n        <p>\n          Process incoming deep links using the navigator  />\n      </section>\n\n      <section>\n        <h2 id= >Runtime Pattern Registration</h2>\n        <p>\n          Register additional deep link patterns at runtime for dynamic routing scenarios \n          like promotional campaigns or A/B testing.\n        </p>\n        <CodeBlock code={runtimeRegistrationCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Android Deep Link Setup</h2>\n        <p>\n          Configure intent filters in your Android manifest to handle incoming deep links:\n        </p>\n        <CodeBlock code={androidManifestCode} language=  />\n        <p>Handle the incoming intent in your Activity:</p>\n        <CodeBlock code={androidActivityCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >iOS Universal Links</h2>\n        <p>\n          Handle universal links in your iOS app  />\n      </section>\n\n      <section>\n        <h2 id= >Web Browser History</h2>\n        <p>\n          On web targets, enable browser URL synchronization to keep the address bar \n          in sync with navigation state:\n        </p>\n        <CodeBlock code={webBrowserHistoryCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >DeepLinkRegistry Interface</h2>\n        <p>\n          The <code>DeepLinkRegistry</code> provides programmatic control over deep link \n          pattern registration:\n        </p>\n        <CodeBlock code={deepLinkRegistryCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Best Practices</h2>\n        <ul>\n          <li><strong>Consistent route naming:</strong> Use <code>feature/action/{ }</code> pattern</li>\n          <li><strong>Required vs optional:</strong> Make navigation-critical params required, UI-only params optional</li>\n          <li><strong>Test thoroughly:</strong> Test deep links with various parameter combinations</li>\n          <li><strong>Handle gracefully:</strong> Always handle invalid or unknown deep links with appropriate fallbacks</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Multiplatform Support</a> - Deep links on all platforms</li>\n          <li><a href= >Type Safety</a> - Type-safe argument handling</li>\n          <li><a href="
  },
  {
    "id": "Features/features",
    "title": "Features",
    "route": "/Features/features",
    "content": "@components/CodeBlock/CodeBlock ./Features.module.css )\nsealed class ShopDestination : Destination\n\n// 2. Add destinations with routes\n@Route( )\ndata object ProductList : ShopDestination()\n\n// 3. Add typed destinations with arguments\n@Serializable\ndata class ProductData(val productId: String, val mode: String =  )\n@Argument(ProductData::class)\ndata class ProductDetail(\n    val productId: String,\n    val mode: String =  \n) : ShopDestination(), TypedDestination<ProductData> {\n    override val data = ProductData(productId, mode)\n}\n\n// 4. Define content with @Content annotation\n@Content(ProductList::class)\n@Composable\nfun ProductListContent(navigator: Navigator) {\n    ProductListScreen(\n        onProductClick = { id ->\n            // Type-safe navigation with generated extension\n            navigator.navigateToProductDetail(\n                productId = id,\n                mode =  \n            )\n        }\n    )\n}\n\n@Content(ProductDetail::class)\n@Composable\nfun ProductDetailContent(data: ProductData, navigator: Navigator) {\n    ProductDetailScreen(\n        productId = data.productId,\n        mode = data.mode,\n        onBack = { navigator.navigateBack() }\n    )\n}\n\n// 5. Use generated graph builder\nval shopGraph = buildShopDestinationGraph()\n\n// That )\nsealed class FeatureDestination : Destination\n\n@Route( )\ndata object List : FeatureDestination()\n\n@Serializable\ndata class DetailData(val id: String, val mode: ViewMode = ViewMode.READ)\n\n@Route( )\n@Argument(DetailData::class)\ndata class Details(val id: String, val mode: ViewMode = ViewMode.READ) \n    : FeatureDestination(), TypedDestination<DetailData> {\n    override val data = DetailData(id, mode)\n}\n\n// Navigate with generated extension\nnavigator.navigateToDetails(id =  , mode = ViewMode.EDIT)`\n\nconst typeSafeManualCode = `// Define destinations manually\nsealed class FeatureDestination : Destination {\n    object List : FeatureDestination() {\n        override val route =  \n    }\n    \n    data class Details(\n        val id: String,\n        val mode: ViewMode = ViewMode.READ\n    ) : FeatureDestination() {\n        override val route =  \n        override val arguments = mapOf(\n              to mode.name\n        )\n    }\n}\n\n// Navigate with destination instance\nnavigator.navigate(FeatureDestination.Details( , ViewMode.EDIT))`\n\nconst stackManagementCode = `// Access current NavNode tree state\nval navState = navigator.state.value\n\n// Pop from active stack\nnavigator.navigateBack()\n\n// Clear to specific destination using TreeMutator\nval newState = TreeMutator.clearAndPush(navState, HomeDestination)\nnavigator.updateState(newState)\n\n// Navigate and replace current screen\nnavigator.navigateAndReplace(NewDestination)\n\n// Clear everything and start fresh\nnavigator.navigateAndClearAll(StartDestination)\n\n// Switch active tab (for TabNode)\nval tabState = TreeMutator.switchActiveTab(navState, newIndex = 1)\nnavigator.updateState(tabState)`\n\nconst deepLinkCode = `val graph = navigationGraph( ) {\n    // Simple path\n    deepLink( ) {\n        HomeDestination\n    }\n    \n    // Path parameters\n    deepLink( ) { args ->\n        UserDestination(userId = args[ ] as String)\n    }\n    \n    // Query parameters\n    deepLink( ) { args ->\n        SearchDestination(query = args[ ] as String)\n    }\n    \n    // Optional parameters\n    deepLink( ) { args ->\n        SettingsDestination(section = args[ ] as? String)\n    }\n}`\n\nconst predictiveBackCode = `NavigationHost(\n    navigator = navigator,\n    screenRegistry = MainScreenRegistry,\n    predictiveBackMode = PredictiveBackMode.FULL_CASCADE\n)`\n\nconst sharedElementCode = `// Define shared element configuration\nval imageConfig = SharedElementConfig(\n    key =  ,\n    type = SharedElementType.Bounds\n)\n\n// Source screen\nImage(\n    modifier = Modifier.sharedElement(\n        sharedConfig = imageConfig,\n        navigator = navigator\n    )\n)\n\n// Destination screen (same key!)\nImage(\n    modifier = Modifier.sharedElement(\n        sharedConfig = imageConfig,\n        navigator = navigator\n    )\n)`\n\nconst customTransitionCode = `val customTransition = NavigationTransition(\n    enter = slideInVertically { it } + fadeIn(),\n    exit = slideOutVertically { -it / 2 } + fadeOut(),\n    popEnter = slideInVertically { -it / 2 } + fadeIn(),\n    popExit = slideOutVertically { it } + fadeOut()\n)`\n\nconst testingCode = `@Test\nfun \\`navigates to details when item clicked\\`() {\n    // Arrange\n    val navigator = FakeNavigator()\n    val viewModel = ProductListViewModel(navigator)\n    \n    // Act\n    viewModel.onProductClicked( )\n    \n    // Assert\n    assertEquals(\n        ProductDestination.Details( ),\n        navigator.lastDestination\n    )\n}\n\n@Test\nfun \\`clears navigation stack on logout\\`() {\n    // Arrange\n    val navigator = FakeNavigator()\n    val viewModel = SettingsViewModel(navigator)\n    \n    // Act\n    viewModel.onLogout()\n    \n    // Assert\n    assertTrue(navigator.stackCleared)\n    assertEquals(LoginDestination, navigator.lastDestination)\n}`\n\nconst modularCode = `// Feature exposes navigation graph\nobject ProfileFeature {\n    fun navigationGraph(): NavigationGraph = navigationGraph( ) {\n        startDestination(ProfileDestination.List)\n        \n        destination(ProfileDestination.List) { _, nav -> ... }\n        destination(ProfileDestination.Details) { _, nav -> ... }\n    }\n    \n    // Public entry points\n    val entryPoint: Destination = ProfileDestination.List\n}\n\n// Main app integrates feature\nval mainGraph = navigationGraph( ) {\n    includeGraph(ProfileFeature.navigationGraph())\n    \n    // Navigate to feature\n    navigator.navigate(ProfileFeature.entryPoint)\n}`\n\nconst koinCode = `// Define content with DI\n@Content(HomeDestination::class)\n@Composable\nfun HomeContent(navigator: Navigator) {\n    val viewModel: HomeViewModel = koinInject()\n    HomeScreen(viewModel, navigator)\n}\n\n// Use NavigationHost with generated registry\nNavigationHost(\n    navigator = navigator,\n    screenRegistry = AppScreenRegistry\n)`\n\nconst customInjectionCode = `// Create custom destination factory\ninterface DestinationFactory {\n    @Composable\n    fun create(destination: Destination, navigator: Navigator)\n}\n\n// Use in navigation graph\nval graph = navigationGraph( >Getting Started - Alternative Approach</a>.\n        </div>\n      </section>\n\n      <section>\n        <h2 id= >Type-Safe Navigation</h2>\n        <p>\n          Quo Vadis eliminates string-based routing entirely, providing compile-time safety \n          for all navigation operations through two approaches: the annotation-based API (recommended) \n          and the manual DSL (for advanced use cases).\n        </p>\n\n        <h3>Benefits</h3>\n        <ul>\n          <li><strong>Compile-time Safety:</strong> Catch navigation errors at compile time with sealed classes</li>\n          <li><strong>IDE Support:</strong> Full autocompletion and refactoring for both approaches</li>\n          <li><strong>Type-safe Arguments:</strong> Pass complex data types, not just strings</li>\n          <li><strong>Two Approaches:</strong> Use annotations (recommended) or manual DSL (advanced)</li>\n        </ul>\n\n        <h3>Annotation-Based Approach (Recommended)</h3>\n        <CodeBlock code={typeSafeAnnotationCode} language=  />\n\n        <h3>Manual DSL Approach</h3>\n        <CodeBlock code={typeSafeManualCode} language=  />\n\n        <p>\n          Both approaches provide complete type safety and work seamlessly together. \n          The annotation-based approach requires less code and generates helpful extensions,\n          while the manual DSL offers more control for complex scenarios.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Stack Management (NavNode Tree)</h2>\n        <p>\n          Quo Vadis uses an immutable NavNode tree to represent navigation state. \n          All state mutations are performed through TreeMutator operations, providing \n          predictable and testable navigation behavior.\n        </p>\n\n        <h3>Operations</h3>\n        <CodeBlock code={stackManagementCode} language=  />\n\n        <h3>Use Cases</h3>\n        <ul>\n          <li>Multi-step wizards with immutable state transformations</li>\n          <li>Authentication flows that clear navigation stacks</li>\n          <li>Tab-based navigation with independent TabNode children</li>\n          <li>State restoration via NavNode serialization</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Deep Link Support</h2>\n        <p>\n          Comprehensive deep linking system that works across all platforms. Define URL \n          patterns and automatically map them to type-safe destinations.\n        </p>\n\n        <h3>Pattern Matching</h3>\n        <CodeBlock code={deepLinkCode} language=  />\n\n        <h3>Platform Integration</h3>\n        <ul>\n          <li><strong>Android:</strong> Intent filters and App Links</li>\n          <li><strong>iOS:</strong> Universal Links and custom URL schemes</li>\n          <li><strong>Web:</strong> Direct URL navigation</li>\n          <li><strong>Desktop:</strong> Custom protocol handlers</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Predictive Back Navigation</h2>\n        <p>\n          Modern, gesture-driven back navigation with smooth animations. Users can preview \n          the previous screen before committing to navigation. Built into NavigationHost \n          via the <code>predictiveBackMode</code> parameter.\n        </p>\n\n        <h3>Supported Platforms</h3>\n        <ul>\n          <li><strong>Android 13+:</strong> System predictive back API</li>\n          <li><strong>iOS:</strong> Interactive pop gesture</li>\n          <li><strong>Custom Implementations:</strong> Desktop and Web</li>\n        </ul>\n\n        <h3>Features</h3>\n        <ul>\n          <li>Smooth, interruptible animations</li>\n          <li>Cross-fade between screens</li>\n          <li>Scale and position transitions</li>\n          <li>Cancelable gestures</li>\n          <li>Cascade pop support for TabNode structures</li>\n        </ul>\n\n        <CodeBlock code={predictiveBackCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Shared Element Transitions</h2>\n        <p>\n          Material Design 3 shared element transitions with full bidirectional support. \n          Create stunning visual continuity between screens.\n        </p>\n\n        <h3>Key Features</h3>\n        <ul>\n          <li><strong>Bidirectional:</strong> Works for both forward and back navigation</li>\n          <li><strong>Type-Safe:</strong> Compile-time verified shared element keys</li>\n          <li><strong>Flexible:</strong> Bounds, content, or both transitions</li>\n          <li><strong>Platform-Aware:</strong> Native behavior on each platform</li>\n        </ul>\n\n        <h3>Example</h3>\n        <CodeBlock code={sharedElementCode} language=  />\n\n        <h3>Transition Types</h3>\n        <ul>\n          <li><strong>Bounds:</strong> Animate position and size</li>\n          <li><strong>Content:</strong> Cross-fade content</li>\n          <li><strong>Both:</strong> Animate bounds and content together</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >MVI Architecture Support</h2>\n        <p>\n          First-class integration with MVI (Model-View-Intent) architecture pattern through \n          the <strong>quo-vadis-core-flow-mvi</strong> module. Navigation is treated as a \n          side effect of business logic, keeping your UI clean and testable.\n        </p>\n\n        <h3>Key Benefits</h3>\n        <ul>\n          <li><strong>Testable:</strong> Test navigation logic without UI using FakeNavigator</li>\n          <li><strong>Predictable:</strong> Navigation as pure side effect of state changes</li>\n          <li><strong>Centralized:</strong> All navigation logic in one place (Container)</li>\n          <li><strong>Decoupled:</strong> UI doesn >FlowMVI Integration Guide</a> for complete documentation.\n        </div>\n      </section>\n\n      <section>\n        <h2 id=  />\n      </section>\n\n      <section>\n        <h2 id= >Testing Support</h2>\n        <p>\n          Built-in testing utilities make it easy to verify navigation behavior without \n          UI testing. Test navigation logic in fast, reliable unit tests.\n        </p>\n\n        <h3>FakeNavigator</h3>\n        <CodeBlock code={testingCode} language=  />\n\n        <h3>Verification Methods</h3>\n        <ul>\n          <li><code>verifyNavigate(destination)</code> - Verify navigation to destination</li>\n          <li><code>verifyNavigateBack()</code> - Verify back navigation</li>\n          <li><code>clearCalls()</code> - Reset navigation call history</li>\n          <li><code>navigationCalls</code> - Access full navigation history</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Modular Architecture</h2>\n        <p>\n          Gray box pattern support enables true modular architecture. Features can \n          define their own navigation graphs and expose public entry points.\n        </p>\n\n        <h3>Feature Module Example</h3>\n        <CodeBlock code={modularCode} language=  />\n\n        <h3>Benefits</h3>\n        <ul>\n          <li>Independent feature development</li>\n          <li>Clear module boundaries</li>\n          <li>Reusable feature modules</li>\n          <li>Easier testing and maintenance</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >DI Framework Integration</h2>\n        <p>\n          Easy integration with popular DI frameworks like Koin, Kodein, and others. \n          Inject dependencies into destination composables seamlessly.\n        </p>\n\n        <h3>Koin Example</h3>\n        <CodeBlock code={koinCode} language=  />\n\n        <h3>Custom Injection</h3>\n        <CodeBlock code={customInjectionCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Performance</h2>\n        <p>\n          Optimized for performance with minimal overhead. Lazy initialization, \n          efficient state management, and smart recomposition.\n        </p>\n\n        <h3>Optimizations</h3>\n        <ul>\n          <li><strong>Lazy Loading:</strong> Destinations created only when needed</li>\n          <li><strong>Efficient State:</strong> StateFlow with structural sharing</li>\n          <li><strong>Smart Recomposition:</strong> Minimal recomposition on navigation</li>\n          <li><strong>No Reflection:</strong> Zero runtime reflection overhead</li>\n          <li><strong>Small Footprint:</strong> No external dependencies</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >No External Dependencies</h2>\n        <p>\n          Quo Vadis is completely self-contained with zero external navigation dependencies. \n          This means:\n        </p>\n        <ul>\n          <li>Smaller app size</li>\n          <li>No version conflicts</li>\n          <li>No dependency chain issues</li>\n          <li>Full control over updates</li>\n          <li>Better long-term stability</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Get started</a> with the quick start guide</li>\n          <li><a href= >See the demo</a> to explore features in action</li>\n          <li><a href= >Browse API docs</a> for detailed reference</li>\n          <li><a href="
  },
  {
    "id": "Features/FlowMVI/flowmvi",
    "title": "Flow M V I",
    "route": "/Features/FlowMVI/flowmvi",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css io.github.jermeyyy:quo-vadis-core-flow-mvi:0.3.3 ))\n            updateState { ProfileState.Error(exception.message ?:  ) }\n            null\n        }\n    }\n\n    private suspend fun Ctx.handleLoadProfile() {\n        updateState { ProfileState.Loading }\n        val user = repository.getUser()\n        updateState { ProfileState.Content(user = user) }\n    }\n}`\n\nconst sharedContainerCode = `data class DemoTabsState(\n    val totalItemsViewed: Int = 0,\n    val favoriteItems: List<String> = emptyList()\n) : MVIState\n\nsealed interface DemoTabsIntent : MVIIntent {\n    data object IncrementViewed : DemoTabsIntent\n    data class AddFavorite(val itemId: String) : DemoTabsIntent\n}\n\nsealed interface DemoTabsAction : MVIAction\n\nclass DemoTabsContainer(\n    scope: SharedContainerScope\n) : SharedNavigationContainer<DemoTabsState, DemoTabsIntent, DemoTabsAction>(scope) {\n\n    override val store = store(DemoTabsState()) {\n        reduce { intent ->\n            when (intent) {\n                is DemoTabsIntent.IncrementViewed -> updateState {\n                    copy(totalItemsViewed = totalItemsViewed + 1)\n                }\n                is DemoTabsIntent.AddFavorite -> updateState {\n                    copy(favoriteItems = favoriteItems + intent.itemId)\n                }\n            }\n        }\n    }\n}\n\n// Provide shared store via CompositionLocal\nval LocalDemoTabsStore = staticCompositionLocalOf<Store<DemoTabsState, DemoTabsIntent, DemoTabsAction>> {\n    throw IllegalStateException( )\n}`\n\nconst rememberContainerCode = `@Screen(MainTabs.ProfileTab::class)\n@Composable\nfun ProfileScreen() {\n    val store = rememberContainer<ProfileContainer, ProfileState, ProfileIntent, ProfileAction>()\n    val snackbarHostState = remember { SnackbarHostState() }\n    val scope = rememberCoroutineScope()\n\n    val state by store.subscribe { action ->\n        scope.launch {\n            when (action) {\n                is ProfileAction.ShowToast -> {\n                    snackbarHostState.showSnackbar(action.message)\n                }\n            }\n        }\n    }\n\n    Scaffold(snackbarHost = { SnackbarHost(snackbarHostState) }) {\n        when (state) {\n            is ProfileState.Loading -> LoadingContent()\n            is ProfileState.Content -> ProfileContent(\n                state = state as ProfileState.Content,\n                onIntent = store::intent\n            )\n            is ProfileState.Error -> ErrorContent(\n                message = (state as ProfileState.Error).message,\n                onRetry = { store.intent(ProfileIntent.LoadProfile) }\n            )\n        }\n    }\n}`\n\nconst rememberSharedContainerCode = `@TabsContainer(DemoTabs::class)\n@Composable\nfun DemoTabsWrapper(\n    scope: TabsContainerScope,\n    content: @Composable () -> Unit\n) {\n    val sharedStore = rememberSharedContainer<DemoTabsContainer, DemoTabsState, DemoTabsIntent, DemoTabsAction>()\n    val state by sharedStore.subscribe()\n\n    CompositionLocalProvider(LocalDemoTabsStore provides sharedStore) {\n        Scaffold(\n            topBar = {\n                TopAppBar(title = { Text( https://github.com/respawn-app/FlowMVI }\n        state management with navigation lifecycle, providing automatic container lifecycle management and Koin integration.\n      </p>\n\n      <section>\n        <h2 id= >Overview</h2>\n        <p>\n          This module provides a seamless integration between FlowMVI >Dependencies</h2>\n        <p>\n          Add the FlowMVI integration module to your project. This module transitively includes FlowMVI, Koin, and quo-vadis-core.\n        </p>\n        <CodeBlock code={dependencyCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >MVI Contract</h2>\n        <p>\n          FlowMVI uses three main components: <strong>State</strong> (what UI displays),\n          <strong>Intent</strong> (user actions), and <strong>Action</strong> (side effects like toasts).\n        </p>\n        <CodeBlock code={contractCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Screen-Scoped Container</h2>\n        <p>\n          <code>NavigationContainer</code> extends FlowMVI  />\n        <h3>NavigationContainerScope Properties</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>Property</th>\n              <th>Type</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>navigator</code></td>\n              <td><code>Navigator</code></td>\n              <td>For navigation operations</td>\n            </tr>\n            <tr>\n              <td><code>screenKey</code></td>\n              <td><code>String</code></td>\n              <td>Unique screen identifier</td>\n            </tr>\n            <tr>\n              <td><code>coroutineScope</code></td>\n              <td><code>CoroutineScope</code></td>\n              <td>Tied to screen lifecycle</td>\n            </tr>\n            <tr>\n              <td><code>screenNode</code></td>\n              <td><code>ScreenNode</code></td>\n              <td>Navigation node for the screen</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Container-Scoped Shared State</h2>\n        <p>\n          <code>SharedNavigationContainer</code> provides state that persists across all screens within a Tab or Pane container.\n          This is useful for sharing data between screens without prop drilling or global state.\n        </p>\n        <CodeBlock code={sharedContainerCode} language=  />\n        <h3>SharedContainerScope Properties</h3>\n        <table>\n          <thead>\n            <tr>\n              <th>Property</th>\n              <th>Type</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>navigator</code></td>\n              <td><code>Navigator</code></td>\n              <td>For navigation operations</td>\n            </tr>\n            <tr>\n              <td><code>containerKey</code></td>\n              <td><code>String</code></td>\n              <td>Unique container identifier</td>\n            </tr>\n            <tr>\n              <td><code>coroutineScope</code></td>\n              <td><code>CoroutineScope</code></td>\n              <td>Tied to container lifecycle</td>\n            </tr>\n            <tr>\n              <td><code>containerNode</code></td>\n              <td><code>LifecycleAwareNode</code></td>\n              <td>TabNode or PaneNode</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Using rememberContainer</h2>\n        <p>\n          The <code>rememberContainer</code> composable creates or retrieves a screen-scoped container.\n          It automatically manages the container  />\n        <h3>Key Points</h3>\n        <ul>\n          <li>Container is created when the screen enters composition</li>\n          <li>Store is automatically started and subscribes to state</li>\n          <li>Actions are handled via the subscribe callback</li>\n          <li>Container is cleaned up when screen is removed from navigation</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Using rememberSharedContainer</h2>\n        <p>\n          The <code>rememberSharedContainer</code> composable creates or retrieves a container-scoped shared store.\n          Use it in <code>@TabsContainer</code> or <code>@PaneContainer</code> annotated composables to share state across child screens.\n        </p>\n        <CodeBlock code={rememberSharedContainerCode} language=  />\n        <h3>Key Points</h3>\n        <ul>\n          <li>Shared container lives as long as the Tab/Pane container</li>\n          <li>Use <code>CompositionLocalProvider</code> to share the store with child screens</li>\n          <li>Child screens access shared state via <code>CompositionLocal</code></li>\n          <li>State persists across tab switches within the container</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Lifecycle Management</h2>\n        <p>\n          The FlowMVI integration automatically manages container lifecycle based on navigation state.\n          Here  />\n        <h3>Lifecycle Guarantees</h3>\n        <ul>\n          <li><strong>Creation</strong> - Container and scope created on first access</li>\n          <li><strong>Persistence</strong> - Same instance returned for same screen key</li>\n          <li><strong>Cleanup</strong> - Automatic cleanup when screen is destroyed</li>\n          <li><strong>Coroutine cancellation</strong> - All coroutines cancelled on cleanup</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Koin Module Registration</h2>\n        <p>\n          Register your containers with Koin using the provided DSL functions.\n          The <code>navigationContainer</code> and <code>sharedNavigationContainer</code> functions\n          handle scoping automatically.\n        </p>\n        <CodeBlock code={koinModuleCode} language=  />\n        <h3>Registration Functions</h3>\n        <ul>\n          <li><code>navigationContainer&lt;T&gt;</code> - Register a screen-scoped container</li>\n          <li><code>sharedNavigationContainer&lt;T&gt;</code> - Register a container-scoped shared container</li>\n          <li><code>navigationModule</code> - Required base module with Navigator binding</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Common Patterns</h2>\n        <h3>Navigation from Container</h3>\n        <CodeBlock code={`reduce { intent ->\n    when (intent) {\n        is ProfileIntent.NavigateToSettings -> {\n            // Use navigator from scope\n            navigator.navigate(SettingsDestination.Main)\n        }\n        is ProfileIntent.NavigateBack -> {\n            navigator.navigateBack()\n        }\n    }\n}`} language=  />\n\n        <h3>Conditional Navigation</h3>\n        <CodeBlock code={`reduce { intent ->\n    when (intent) {\n        is ProfileIntent.SaveAndNavigate -> {\n            try {\n                repository.save(currentState.data)\n                action(ProfileAction.ShowToast( ))\n                navigator.navigateBack()\n            } catch (e: Exception) {\n                action(ProfileAction.ShowToast( ))\n                // Stay on screen\n            }\n        }\n    }\n}`} language=  />\n\n        <h3>Sharing State Between Tabs</h3>\n        <CodeBlock code={`// In tab wrapper - increment view count\n@TabsContainer(MainTabs::class)\n@Composable\nfun MainTabsWrapper(scope: TabsContainerScope, content: @Composable () -> Unit) {\n    val store = rememberSharedContainer<MainTabsContainer, ...>()\n    CompositionLocalProvider(LocalMainTabsStore provides store) {\n        content()\n    }\n}\n\n// In any child screen - access shared state\n@Screen(MainTabs.Home::class)\n@Composable\nfun HomeScreen() {\n    val sharedStore = LocalMainTabsStore.current\n    val sharedState by sharedStore.subscribe()\n    \n    Text(  />\n      </section>\n\n      <section>\n        <h2 id= >Best Practices</h2>\n        <h3>✅ DO:</h3>\n        <ul>\n          <li>Keep navigation logic in containers, not UI</li>\n          <li>Use <code>NavigationContainer</code> for screen-specific state</li>\n          <li>Use <code>SharedNavigationContainer</code> for cross-screen state</li>\n          <li>Handle all errors with <code>recover</code> plugin</li>\n          <li>Use meaningful intent names describing user actions</li>\n          <li>Provide shared stores via <code>CompositionLocal</code></li>\n        </ul>\n        <h3>❌ DON t navigate directly from UI composables</li>\n          <li>Don t pass navigator as parameter (use scope t ignore the lifecycle - let the framework manage cleanup</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >FlowMVI Documentation</a> - Learn more about FlowMVI</li>\n          <li><a href= >Tabs & Panes</a> - Use shared containers with tab navigation</li>\n          <li><a href= >Deep Links</a> - Handle deep links with MVI</li>\n          <li><a href="
  },
  {
    "id": "Features/Modular/modular",
    "title": "Modular",
    "route": "/Features/Modular/modular",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css   // Generates Feature1NavigationConfig\n}\n\n// feature2/build.gradle.kts\nquoVadis {\n    modulePrefix =    // Generates Feature2NavigationConfig\n}`\n\nconst combiningConfigsCode = `// app/src/commonMain/kotlin/DI.kt\nval navigationModule = module {\n    single<NavigationConfig> {\n        AppNavigationConfig +      // App module screens\n            Feature1NavigationConfig +  // Feature 1 module\n            Feature2NavigationConfig    // Feature 2 module\n    }\n    \n    single<Navigator> {\n        val config = get<NavigationConfig>()\n        val initialState = config.buildNavNode(MainTabs::class, null)!!\n        TreeNavigator(config = config, initialState = initialState)\n    }\n}`\n\nconst navigationConfigInterface = `interface NavigationConfig {\n    val screenRegistry: ScreenRegistry\n    val scopeRegistry: ScopeRegistry\n    val transitionRegistry: TransitionRegistry\n    val containerRegistry: ContainerRegistry\n    val deepLinkRegistry: DeepLinkRegistry\n    val paneRoleRegistry: PaneRoleRegistry\n    \n    fun buildNavNode(destinationClass: KClass<*>, parentKey: String?): NavNode?\n    \n    operator fun plus(other: NavigationConfig): NavigationConfig\n}`\n\nconst featureModuleCode = `// feature1/src/commonMain/kotlin/Feature1Destinations.kt\n@Stack(name =  , startDestination = Feature1List::class)\nsealed class Feature1Destination : NavDestination {\n    @Destination(route =  )\n    data object Feature1List : Feature1Destination()\n    \n    @Destination(route =  )\n    data class Feature1Detail(@Argument val id: String) : Feature1Destination()\n}\n\n// feature1/src/commonMain/kotlin/Feature1Screens.kt\n@Screen(Feature1Destination.Feature1List::class)\n@Composable\nfun Feature1ListScreen(navigator: Navigator) { /* ... */ }\n\n@Screen(Feature1Destination.Feature1Detail::class)\n@Composable\nfun Feature1DetailScreen(\n    destination: Feature1Destination.Feature1Detail, \n    navigator: Navigator\n) { /* ... */ }\n\n// After KSP generates Feature1NavigationConfig`\n\nconst crossModuleCode = `// In feature1, navigate to feature2 destination\nnavigator.navigate(Feature2Destination.SomeScreen)\n\n// Works because configs are combined in app module`\n\nconst featureDependenciesCode = `// feature1/build.gradle.kts\nplugins {\n    kotlin( com.google.devtools.ksp io.github.jermeyyy.quo-vadis ))\n            implementation(project( ))\n        }\n    }\n}\n\nquoVadis {\n    modulePrefix =  >Module Structure Pattern</h2>\n        <p>\n          A typical multi-module project organizes navigation across feature modules, \n          with each module containing its destinations, screens, and a generated \n          NavigationConfig:\n        </p>\n        <CodeBlock code={moduleStructure} language=  />\n      </section>\n\n      <section>\n        <h2 id= >KSP Module Prefix Configuration</h2>\n        <p>\n          Each module needs a unique prefix to generate distinct NavigationConfig classes. \n          Configure this in each feature module  />\n      </section>\n\n      <section>\n        <h2 id= >Combining Configurations</h2>\n        <p>\n          Use the <code>+</code> operator to combine NavigationConfig instances from \n          multiple modules. This is typically done in your app module  />\n        <p>\n          <strong>Priority rule:</strong> The right-hand config takes priority for \n          duplicate registrations. This allows feature modules to override app-level \n          defaults when needed.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >NavigationConfig Interface</h2>\n        <p>\n          The NavigationConfig interface combines all navigation-related registries \n          and provides the <code>plus</code> operator for composition:\n        </p>\n        <CodeBlock code={navigationConfigInterface} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Feature Module Example</h2>\n        <p>\n          Each feature module defines its own destinations and screens. KSP generates \n          the NavigationConfig automatically:\n        </p>\n        <CodeBlock code={featureModuleCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Cross-Module Navigation</h2>\n        <p>\n          Navigate between modules using type-safe destination references. This works \n          because all configs are combined in the app module:\n        </p>\n        <CodeBlock code={crossModuleCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Feature Module Dependencies</h2>\n        <p>\n          Each feature module requires the Quo Vadis plugin and core dependencies:\n        </p>\n        <CodeBlock code={featureDependenciesCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Hybrid Configuration</h2>\n        <p>\n          Combine generated configs with manual additions for dynamic features \n          like feature flags:\n        </p>\n        <CodeBlock code={hybridConfigCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Generated Files Per Module</h2>\n        <table>\n          <thead>\n            <tr>\n              <th>Module</th>\n              <th>Generated Config</th>\n              <th>Contains</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>app</code></td>\n              <td><code>AppNavigationConfig</code></td>\n              <td>Tab containers, main screens</td>\n            </tr>\n            <tr>\n              <td><code>feature1</code></td>\n              <td><code>Feature1NavigationConfig</code></td>\n              <td>Feature 1 screens</td>\n            </tr>\n            <tr>\n              <td><code>feature2</code></td>\n              <td><code>Feature2NavigationConfig</code></td>\n              <td>Feature 2 screens</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Best Practices</h2>\n        <ul>\n          <li><strong>Consistent naming:</strong> Use <code>{ }NavigationConfig</code> pattern</li>\n          <li><strong>Co-location:</strong> Define destinations close to their screens</li>\n          <li><strong>Independence:</strong> Keep feature modules independent of each other</li>\n          <li><strong>Central composition:</strong> Combine configs only in app module</li>\n          <li><strong>Cross-boundary testing:</strong> Test navigation across module boundaries</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >DI Integration</a> - Set up dependency injection with navigation</li>\n          <li><a href= >Deep Linking</a> - Add URL-based navigation</li>\n          <li><a href="
  },
  {
    "id": "Features/Multiplatform/multiplatform",
    "title": "Multiplatform",
    "route": "/Features/Multiplatform/multiplatform",
    "content": "../Features.module.css @components/CodeBlock/CodeBlock >Single Codebase Benefits</h2>\n        <p>\n          Write your navigation logic once in <code>commonMain</code> and it runs identically \n          on all platforms:\n        </p>\n        \n        <CodeBlock language=  code={`// commonMain - shared across ALL platforms\n@Stack(name =  , startDestination = Feed::class)\nsealed class HomeDestination : NavDestination {\n    @Destination(route =  )\n    data object Feed : HomeDestination()\n}\n\n@Screen(HomeDestination.Feed::class)\n@Composable\nfun FeedScreen(navigator: Navigator) {\n    // Same code runs on Android, iOS, Desktop, Web\n}`} />\n      </section>\n\n      <section>\n        <h2 id= >Platform-Specific Features</h2>\n        <p>\n          While core navigation works identically everywhere, each platform has its own \n          native capabilities:\n        </p>\n        \n        <table>\n          <thead>\n            <tr>\n              <th>Feature</th>\n              <th>Android</th>\n              <th>iOS</th>\n              <th>Desktop</th>\n              <th>Web</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Stack navigation</td>\n              <td>✅</td>\n              <td>✅</td>\n              <td>✅</td>\n              <td>✅</td>\n            </tr>\n            <tr>\n              <td>Tab navigation</td>\n              <td>✅</td>\n              <td>✅</td>\n              <td>✅</td>\n              <td>✅</td>\n            </tr>\n            <tr>\n              <td>Pane layouts</td>\n              <td>✅</td>\n              <td>✅</td>\n              <td>✅</td>\n              <td>✅</td>\n            </tr>\n            <tr>\n              <td>Deep links</td>\n              <td>✅</td>\n              <td>✅</td>\n              <td>⚡</td>\n              <td>✅</td>\n            </tr>\n            <tr>\n              <td>Predictive back</td>\n              <td>✅</td>\n              <td>✅</td>\n              <td>—</td>\n              <td>—</td>\n            </tr>\n            <tr>\n              <td>Shared elements</td>\n              <td>✅</td>\n              <td>✅</td>\n              <td>✅</td>\n              <td>✅</td>\n            </tr>\n            <tr>\n              <td>Browser history</td>\n              <td>—</td>\n              <td>—</td>\n              <td>—</td>\n              <td>✅</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Gradle Setup for All Platforms</h2>\n        <p>\n          Configure your <code>build.gradle.kts</code> to target all platforms:\n        </p>\n        \n        <CodeBlock language=  code={`// build.gradle.kts\nkotlin {\n    androidTarget()\n    \n    listOf(\n        iosX64(),\n        iosArm64(),\n        iosSimulatorArm64()\n    ).forEach { iosTarget ->\n        iosTarget.binaries.framework {\n            baseName =  \n            isStatic = true\n        }\n    }\n    \n    jvm( )\n    \n    js(IR) {\n        browser()\n    }\n    \n    @OptIn(ExperimentalWasmDsl::class)\n    wasmJs {\n        browser()\n    }\n    \n    sourceSets {\n        commonMain.dependencies {\n            implementation( )\n            implementation( )\n        }\n    }\n}`} />\n      </section>\n\n      <section>\n        <h2 id= >Running on Different Platforms</h2>\n        <p>\n          Use these Gradle commands to run your app on each platform:\n        </p>\n        \n        <CodeBlock language=  code={`# Android\n./gradlew :composeApp:installDebug\n\n# Desktop (JVM)\n./gradlew :composeApp:run\n\n# iOS (requires Xcode)\n./gradlew :composeApp:iosSimulatorArm64Test\n\n# JavaScript Browser\n./gradlew :composeApp:jsBrowserDevelopmentRun\n\n# WebAssembly Browser\n./gradlew :composeApp:wasmJsBrowserDevelopmentRun`} />\n      </section>\n\n      <section>\n        <h2 id= >Web-Specific Features</h2>\n        <p>\n          On web platforms, Quo Vadis integrates with browser history and URL routing:\n        </p>\n        \n        <CodeBlock language=  code={`// Enable browser history integration\nNavigationHost(\n    navigator = navigator,\n    enableBrowserHistory = true  // Syncs with browser URL\n)\n\n// Deep links work as URLs\n// https://yourapp.com/home/article/123`} />\n      </section>\n\n      <section>\n        <h2 id= >iOS-Specific Features</h2>\n        <p>\n          On iOS, predictive back works with native swipe gestures:\n        </p>\n        \n        <CodeBlock language=  code={`// Predictive back via edge swipe\nNavigationHost(\n    navigator = navigator,\n    enablePredictiveBack = true  // Works with iOS swipe gesture\n)`} />\n      </section>\n\n      <section>\n        <h2 id= >Desktop-Specific Features</h2>\n        <p>\n          Desktop platforms support keyboard navigation and adaptive window layouts:\n        </p>\n        \n        <CodeBlock language=  code={`// Keyboard navigation\nNavigationHost(\n    navigator = navigator,\n    enableKeyboardBack = true  // Escape key for back\n)\n\n// Window size class for adaptive layouts\nval windowSizeClass = calculateWindowSizeClass()\nNavigationHost(\n    navigator = navigator,\n    windowSizeClass = windowSizeClass  // Triggers pane layout changes\n)`} />\n      </section>\n\n      <section>\n        <h2 id= >Platform-Agnostic Architecture</h2>\n        <p>\n          The architecture keeps platform-specific code minimal while maximizing code sharing:\n        </p>\n        \n        <CodeBlock language=  code={`┌─────────────────────────────────────────────────────────────┐\n│                        commonMain                            │\n│  - Destinations (@Stack, @Destination)                       │\n│  - Screens (@Screen)                                         │\n│  - Containers (NavigationContainer)                          │\n│  - Business logic                                            │\n└─────────────────────────────────────────────────────────────┘\n                              │\n              ┌───────────────┼───────────────┐\n              ▼               ▼               ▼\n        androidMain       iosMain        desktopMain\n        - MainActivity    - AppDelegate  - Main window\n        - Deep links      - Universal    - System tray\n        - Back handler      links        - Keyboard`} />\n        \n        <p>\n          This means 90%+ of your navigation code lives in <code>commonMain</code> and is shared \n          across all platforms, while platform-specific integrations are handled automatically.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Predictive Back</a> - Platform-specific back navigation</li>\n          <li><a href= >Deep Links</a> - URL patterns and deep linking</li>\n          <li><a href="
  },
  {
    "id": "Features/Performance/performance",
    "title": "Performance",
    "route": "/Features/Performance/performance",
    "content": "../Features.module.css >Optimizations</h2>\n        <ul>\n          <li><strong>Lazy Loading:</strong> Destinations created only when needed</li>\n          <li><strong>Efficient State:</strong> StateFlow with structural sharing</li>\n          <li><strong>Smart Recomposition:</strong> Minimal recomposition on navigation</li>\n          <li><strong>No Reflection:</strong> Zero runtime reflection overhead</li>\n          <li><strong>Small Footprint:</strong> No external dependencies</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >No External Dependencies</h2>\n        <p>\n          Quo Vadis is completely self-contained with zero external navigation dependencies. \n          This means:\n        </p>\n        <ul>\n          <li>Smaller app size</li>\n          <li>No version conflicts</li>\n          <li>No dependency chain issues</li>\n          <li>Full control over updates</li>\n          <li>Better long-term stability</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Get started</a> with Quo Vadis</li>\n          <li><a href="
  },
  {
    "id": "Features/PredictiveBack/predictiveback",
    "title": "Predictive Back",
    "route": "/Features/PredictiveBack/predictiveback",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css >Platform Support</h2>\n        <table>\n          <thead>\n            <tr>\n              <th>Platform</th>\n              <th>Support</th>\n              <th>Features</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Android 13+</td>\n              <td>✅ Full</td>\n              <td>Predictive back gestures with visual preview</td>\n            </tr>\n            <tr>\n              <td>iOS</td>\n              <td>✅ Full</td>\n              <td>Edge swipe-back gesture</td>\n            </tr>\n            <tr>\n              <td>Desktop</td>\n              <td>⚡ Partial</td>\n              <td>Keyboard back (Escape key)</td>\n            </tr>\n            <tr>\n              <td>Web</td>\n              <td>⚡ Partial</td>\n              <td>Browser back button integration</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Enabling Predictive Back</h2>\n        <p>\n          Predictive back is enabled by default in <code>NavigationHost</code>:\n        </p>\n        <CodeBlock code={enablePredictiveBackCode} language=  />\n        <p>\n          Disable for specific scenarios where gesture preview isn  />\n      </section>\n\n      <section>\n        <h2 id= >How It Works</h2>\n        <p>\n          The predictive back gesture follows a defined lifecycle:\n        </p>\n        <ol>\n          <li><strong>Gesture Start:</strong> <code>PredictiveBackController</code> activates when the user begins the back gesture</li>\n          <li><strong>Progress Updates:</strong> Visual transforms are applied based on gesture progress (0.0 to 1.0)</li>\n          <li><strong>Completion:</strong> When gesture is committed, animated transition to final state occurs</li>\n          <li><strong>Cancellation:</strong> If gesture is released early, animated return to original state</li>\n        </ol>\n      </section>\n\n      <section>\n        <h2 id= >Visual Behavior</h2>\n        <p>\n          During the gesture, visual transforms create a preview effect:\n        </p>\n        <CodeBlock code={visualBehaviorCode} language=  />\n        <p>\n          The current screen slides right and scales down slightly, while the previous screen \n          has a parallax effect sliding in from the left.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >PredictiveBackController State</h2>\n        <p>\n          The <code>PredictiveBackController</code> manages gesture state:\n        </p>\n        <CodeBlock code={controllerStateCode} language=  />\n        <h3>Progress Ranges</h3>\n        <ul>\n          <li><strong>During gesture:</strong> <code>0.0</code> to <code>0.17</code> (clamped to prevent excessive movement)</li>\n          <li><strong>During completion:</strong> <code>0.0</code> to <code>1.0</code></li>\n          <li><strong>During cancellation:</strong> Animates back to <code>0.0</code></li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Navigator Back Operations</h2>\n        <p>\n          <code>TreeNavigator</code> provides methods for programmatic control:\n        </p>\n        <CodeBlock code={navigatorBackOpsCode} language=  />\n        <p>\n          These methods are typically called by the platform-specific gesture handlers, \n          but can be invoked directly for custom implementations.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >TransitionState Types</h2>\n        <p>\n          The <code>TransitionState</code> sealed interface represents the current state:\n        </p>\n        <CodeBlock code={transitionStateCode} language=  />\n        <p>\n          The <code>touchX</code> and <code>touchY</code> values are normalized to 0.0-1.0, \n          representing the position on screen where the gesture originated.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Observing State in Compose</h2>\n        <p>\n          You can observe the transition state to react to gesture progress:\n        </p>\n        <CodeBlock code={observingStateCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Context-Specific Behavior</h2>\n        <p>\n          Predictive back behavior varies by navigation context:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Context</th>\n              <th>Predictive Back</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Stack navigation</td>\n              <td>✅ Enabled</td>\n            </tr>\n            <tr>\n              <td>Tab switching</td>\n              <td>❌ Disabled (instant)</td>\n            </tr>\n            <tr>\n              <td>Pane transitions</td>\n              <td>Depends on compact/expanded mode</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Android Manifest Setup</h2>\n        <p>\n          To enable predictive back on Android, add this to your <code>AndroidManifest.xml</code>:\n        </p>\n        <CodeBlock code={androidManifestCode} language=  />\n        <p>\n          This is required for Android 13+ to opt-in to the new back gesture API.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >iOS Integration</h2>\n        <p>\n          On iOS, predictive back integrates with the system edge swipe gesture through \n          a <code>NavigateBackHandler</code> in the SwiftUI integration layer. The edge \n          swipe gesture is automatically handled when using the standard iOS navigation setup.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Transitions & Animations</a> - Transition types and customization</li>\n          <li><a href= >Stack Management</a> - NavNode tree operations</li>\n          <li><a href="
  },
  {
    "id": "Features/SharedElements/sharedelements",
    "title": "Shared Elements",
    "route": "/Features/SharedElements/sharedelements",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css \n                            ),\n                            animatedVisibilityScope = transitionScope.animatedVisibilityScope\n                        )\n                    }\n                } else Modifier\n            )\n            Text(item.title)\n        }\n    }\n}`\n\nconst sharedElementDetailCode = `@Screen(MasterDetailDestination.Detail::class)\n@OptIn(ExperimentalSharedTransitionApi::class)\n@Composable\nfun DetailScreen(destination: MasterDetailDestination.Detail) {\n    val transitionScope = LocalTransitionScope.current\n    val itemId = destination.itemId\n\n    Column {\n        Icon(\n            imageVector = Icons.Default.AccountCircle,\n            modifier = if (transitionScope != null) {\n                with(transitionScope.sharedTransitionScope) {\n                    Modifier.sharedElement(\n                        sharedContentState = rememberSharedContentState(\n                            key =  \n                        ),\n                        animatedVisibilityScope = transitionScope.animatedVisibilityScope\n                    )\n                }\n            } else Modifier\n        )\n        Text( )\n    }\n}`\n\nconst sharedBoundsCode = `// List item card\nCard(\n    modifier = if (transitionScope != null) {\n        with(transitionScope.sharedTransitionScope) {\n            Modifier.sharedBounds(\n                sharedContentState = rememberSharedContentState(\n                    key =  \n                ),\n                animatedVisibilityScope = transitionScope.animatedVisibilityScope\n            )\n        }\n    } else Modifier\n) {\n    // List item content\n}\n\n// Detail card (same key, bounds morph)\nCard(\n    modifier = if (transitionScope != null) {\n        with(transitionScope.sharedTransitionScope) {\n            Modifier.sharedBounds(\n                sharedContentState = rememberSharedContentState(\n                    key =  \n                ),\n                animatedVisibilityScope = transitionScope.animatedVisibilityScope\n            )\n        }\n    } else Modifier\n) {\n    // Expanded detail content\n}`\n\nconst animateEnterExitCode = `@Composable\nfun DetailScreen() {\n    val transitionScope = LocalTransitionScope.current\n\n    Column {\n        // Shared element (morphs)\n        Icon(modifier = sharedElementModifier)\n        \n        // Non-shared content with enter/exit animation\n        Text(\n             ,\n            modifier = Modifier.animateEnterExit(\n                transitionScope,\n                enter = fadeIn(tween(300, delayMillis = 100)),\n                exit = fadeOut(tween(200))\n            )\n        )\n    }\n}\n\n// Helper extension\nprivate fun Modifier.animateEnterExit(\n    transitionScope: TransitionScope?,\n    enter: EnterTransition,\n    exit: ExitTransition\n): Modifier = if (transitionScope != null) {\n    with(transitionScope.animatedVisibilityScope) {\n        this@animateEnterExit.animateEnterExit(enter = enter, exit = exit)\n    }\n} else this`\n\nconst transitionTypeNoneCode = `@Transition(type = TransitionType.None)\n@Destination(route =  >How It Works</h2>\n        <p>\n          <code>NavigationHost</code> automatically wraps content in <code>SharedTransitionLayout</code>, \n          providing the transition scope to all child screens:\n        </p>\n        <CodeBlock code={navigationHostCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Accessing TransitionScope</h2>\n        <p>\n          Access the transition scope in any screen using <code>LocalTransitionScope</code>:\n        </p>\n        <CodeBlock code={transitionScopeAccessCode} language=  />\n        <p>The <code>TransitionScope</code> interface provides:</p>\n        <CodeBlock code={transitionScopeInterfaceCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >sharedElement vs sharedBounds</h2>\n        <p>Choose the right modifier based on your use case:</p>\n        <table>\n          <thead>\n            <tr>\n              <th>Modifier</th>\n              <th>Use Case</th>\n              <th>Content Behavior</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>sharedElement</code></td>\n              <td>Exact visual matches (same icon, same image)</td>\n              <td>Content stays identical during transition</td>\n            </tr>\n            <tr>\n              <td><code>sharedBounds</code></td>\n              <td>Container morphing (card expanding to full screen)</td>\n              <td>Content can change while bounds morph</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >sharedElement Example</h2>\n        <p>\n          Use <code>sharedElement</code> for icons, images, and other elements that remain \n          visually identical between screens.\n        </p>\n        <h3>List Screen</h3>\n        <CodeBlock code={sharedElementListCode} language=  />\n        <h3>Detail Screen</h3>\n        <CodeBlock code={sharedElementDetailCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >sharedBounds Example</h2>\n        <p>\n          Use <code>sharedBounds</code> for cards and containers where the content changes \n          but the bounds should morph smoothly:\n        </p>\n        <CodeBlock code={sharedBoundsCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Key Rules</h2>\n        <ol>\n          <li><strong>Keys must match exactly</strong> between source and destination screens</li>\n          <li>Use unique, stable identifiers: <code> card-$&#123;itemId&#125; element-type-unique-id </code>)</li>\n        </ol>\n      </section>\n\n      <section>\n        <h2 id= >Combining with animateEnterExit</h2>\n        <p>\n          For non-shared content, use <code>animateEnterExit</code> alongside shared elements \n          to create coordinated animations:\n        </p>\n        <CodeBlock code={animateEnterExitCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Using TransitionType.None</h2>\n        <p>\n          When shared elements are your primary transition effect, disable the default \n          screen transition with <code>TransitionType.None</code>:\n        </p>\n        <CodeBlock code={transitionTypeNoneCode} language=  />\n        <p>\n          This gives you full control of animations using shared elements and <code>animateEnterExit</code>.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Best Practices</h2>\n        <ul>\n          <li><strong>Keep keys consistent and predictable</strong> - Use a clear naming convention</li>\n          <li><strong>Use TransitionType.None</strong> when shared elements are the primary transition</li>\n          <li><strong>Test both directions</strong> - Verify forward and backward navigation</li>\n          <li><strong>Handle null gracefully</strong> - Always provide a fallback for null transitionScope</li>\n          <li><strong>Don >Next Steps</h2>\n        <ul>\n          <li><a href= >Transitions & Animations</a> - All animation options</li>\n          <li><a href="
  },
  {
    "id": "Features/TabbedNavigation/tabbednavigation",
    "title": "Tabbed Navigation",
    "route": "/Features/TabbedNavigation/tabbednavigation",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css ,\n    initialTab = MainTabs.HomeTab::class,\n    items = [MainTabs.HomeTab::class, MainTabs.ExploreTab::class, \n             MainTabs.ProfileTab::class, MainTabs.SettingsTab::class]\n)\nsealed class MainTabs : NavDestination {\n\n    @TabItem(label =  )\n    @Destination(route =  )\n    @Transition(type = TransitionType.Fade)\n    data object HomeTab : MainTabs()\n\n    @TabItem(label =  )\n    @Destination(route =  )\n    @Transition(type = TransitionType.Fade)\n    data object ExploreTab : MainTabs()\n\n    @TabItem(label =  )\n    @Destination(route =  )\n    @Transition(type = TransitionType.Fade)\n    data object ProfileTab : MainTabs()\n\n    @TabItem(label =  , startDestination = SettingsTab.Main::class)\n    @Transition(type = TransitionType.Fade)\n    sealed class SettingsTab : MainTabs() {\n        @Destination(route =  )\n        data object Main : SettingsTab()\n\n        @Destination(route =  )\n        @Transition(type = TransitionType.SlideHorizontal)\n        data object Profile : SettingsTab()\n    }\n}`\n\nconst tabNodeStructureCode = `@Serializable\n@SerialName( )\ndata class TabNode(\n    override val key: String,\n    override val parentKey: String?,\n    val stacks: List<StackNode>,\n    val activeStackIndex: Int = 0,\n    val wrapperKey: String? = null,\n    val tabMetadata: List<GeneratedTabMetadata> = emptyList(),\n    val scopeKey: String? = null\n) : NavNode {\n    val activeStack: StackNode   // Currently selected tab ,\n    initialTab = AppTabs.HomeTab::class,\n    items = [AppTabs.HomeTab::class, AppTabs.SearchTab::class]\n)\nsealed class AppTabs : NavDestination {\n\n    // Tab with its own nested navigation stack\n    @TabItem(label =  , startDestination = HomeTab.Feed::class)\n    sealed class HomeTab : AppTabs() {\n        @Destination(route =  )\n        data object Feed : HomeTab()\n        \n        @Destination(route =  )\n        data class Article(@Argument val id: String) : HomeTab()\n        \n        @Destination(route =  )\n        data class Comments(@Argument val articleId: String) : HomeTab()\n    }\n\n    // Another tab with its own stack\n    @TabItem(label =  , startDestination = SearchTab.Main::class)\n    sealed class SearchTab : AppTabs() {\n        @Destination(route =  )\n        data object Main : SearchTab()\n        \n        @Destination(route =  >Overview</h2>\n        <p>\n          Quo Vadis provides a powerful annotation-driven system for tabbed navigation that eliminates \n          boilerplate while ensuring type safety. Each tab operates as an independent navigation stack, \n          preserving scroll positions, form data, and navigation history when switching between tabs.\n        </p>\n        <h3>Key Features</h3>\n        <ul>\n          <li><strong>Independent Backstacks</strong> - Each tab maintains its own navigation history</li>\n          <li><strong>State Preservation</strong> - Tab content survives tab switches</li>\n          <li><strong>Nested Stacks</strong> - Tabs can contain their own deep navigation</li>\n          <li><strong>Custom UI</strong> - Full control over tab bar appearance</li>\n          <li><strong>Shared State</strong> - Share data across tabs with MVI containers</li>\n          <li><strong>Platform Icons</strong> - Native icon support per platform</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >@Tabs + @TabItem Annotations</h2>\n        <p>\n          Define your tab structure using <code>@Tabs</code> on a sealed class and <code>@TabItem</code> \n          on each tab destination. The KSP processor generates all configuration code automatically.\n        </p>\n        <CodeBlock code={tabsAnnotationCode} language=  />\n        <p>\n          Notice how <code>SettingsTab</code> is both a tab item and contains its own nested stack \n          with multiple destinations. This enables deep navigation within individual tabs.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >@Tabs Properties</h2>\n        <table>\n          <thead>\n            <tr>\n              <th>Property</th>\n              <th>Type</th>\n              <th>Default</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>name</code></td>\n              <td><code>String</code></td>\n              <td>—</td>\n              <td>Unique identifier for the tab container</td>\n            </tr>\n            <tr>\n              <td><code>initialTab</code></td>\n              <td><code>KClass&lt;*&gt;</code></td>\n              <td><code>Unit::class</code></td>\n              <td>Initially selected tab (Unit = first tab)</td>\n            </tr>\n            <tr>\n              <td><code>items</code></td>\n              <td><code>Array&lt;KClass&lt;*&gt;&gt;</code></td>\n              <td><code>[]</code></td>\n              <td>Tab classes in display order</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >@TabItem Properties</h2>\n        <table>\n          <thead>\n            <tr>\n              <th>Property</th>\n              <th>Type</th>\n              <th>Default</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>label</code></td>\n              <td><code>String</code></td>\n              <td>—</td>\n              <td>Display label for the tab</td>\n            </tr>\n            <tr>\n              <td><code>icon</code></td>\n              <td><code>String</code></td>\n              <td><code> </code></td>\n              <td>Icon identifier (platform-specific)</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >TabNode Structure</h2>\n        <p>\n          At runtime, tab navigation is represented by a <code>TabNode</code> in the navigation tree. \n          This node holds all tab stacks and tracks which tab is currently active.\n        </p>\n        <CodeBlock code={tabNodeStructureCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >TabNode Behavior</h2>\n        <p>\n          Understanding how TabNode responds to navigation operations helps you design intuitive flows:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Operation</th>\n              <th>Effect</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><strong>Switch Tab</strong></td>\n              <td>Updates <code>activeStackIndex</code></td>\n            </tr>\n            <tr>\n              <td><strong>Push</strong></td>\n              <td>Affects only the active stack</td>\n            </tr>\n            <tr>\n              <td><strong>Pop</strong></td>\n              <td>Removes from active stack; may switch tabs</td>\n            </tr>\n          </tbody>\n        </table>\n        <p>\n          When popping from an empty non-primary tab, Quo Vadis can automatically switch to the \n          primary tab, providing a familiar back-navigation experience.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >@TabsContainer - Custom Tab UI</h2>\n        <p>\n          Use <code>@TabsContainer</code> to create custom tab bar UI with full control over \n          appearance and behavior. The container receives a <code>TabsContainerScope</code> with \n          all necessary state and actions.\n        </p>\n        <CodeBlock code={tabsContainerCode} language=  />\n        <p>\n          This pattern works with any tab UI: bottom navigation bars, navigation rails, \n          top tabs, or completely custom designs.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >TabsContainerScope Properties</h2>\n        <table>\n          <thead>\n            <tr>\n              <th>Property</th>\n              <th>Type</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>navigator</code></td>\n              <td><code>Navigator</code></td>\n              <td>Navigation operations</td>\n            </tr>\n            <tr>\n              <td><code>activeTabIndex</code></td>\n              <td><code>Int</code></td>\n              <td>Currently selected tab (0-based)</td>\n            </tr>\n            <tr>\n              <td><code>tabCount</code></td>\n              <td><code>Int</code></td>\n              <td>Total number of tabs</td>\n            </tr>\n            <tr>\n              <td><code>tabMetadata</code></td>\n              <td><code>List&lt;TabMetadata&gt;</code></td>\n              <td>Labels, icons, routes for tabs</td>\n            </tr>\n            <tr>\n              <td><code>isTransitioning</code></td>\n              <td><code>Boolean</code></td>\n              <td>Whether transition is in progress</td>\n            </tr>\n            <tr>\n              <td><code>switchTab(index)</code></td>\n              <td>Function</td>\n              <td>Switch to different tab</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Tabs with Nested Stacks</h2>\n        <p>\n          Tabs can contain their own navigation stacks for deep navigation within each tab. \n          This is perfect for sections like a home feed where users drill into articles, \n          then comments, while preserving the ability to switch tabs.\n        </p>\n        <CodeBlock code={nestedStacksCode} language=  />\n        <p>\n          Each tab t \n          affect the Search tab >Icon Platform Support</h2>\n        <p>\n          The <code>icon</code> property in <code>@TabItem</code> is interpreted differently per platform:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Platform</th>\n              <th>Interpretation</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Android</td>\n              <td>Material icon name or drawable resource</td>\n            </tr>\n            <tr>\n              <td>iOS</td>\n              <td>SF Symbol name</td>\n            </tr>\n            <tr>\n              <td>Desktop/Web</td>\n              <td>Icon library identifier</td>\n            </tr>\n          </tbody>\n        </table>\n        <p>\n          Your <code>@TabsContainer</code> implementation is responsible for mapping these \n          identifiers to actual icons using platform-appropriate APIs.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Shared State with SharedNavigationContainer</h2>\n        <p>\n          When tabs need to share state (like a shopping cart count or user preferences), \n          use <code>SharedNavigationContainer</code> with the FlowMVI integration. The container \n          is scoped to the tab node  />\n        <p>\n          Screens within any tab can access the shared store via the CompositionLocal, \n          enabling coordinated state across the entire tab structure.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Adaptive Panes</a> - Multi-pane layouts for larger screens</li>\n          <li><a href= >MVI Integration</a> - State management with FlowMVI</li>\n          <li><a href= >Transitions</a> - Animate between tabs and screens</li>\n          <li><a href="
  },
  {
    "id": "Features/Testing/testing",
    "title": "Testing",
    "route": "/Features/Testing/testing",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css ))\nassertEquals(HomeDestination.Article( ), navigator.currentDestination.value)\n\n// Test back navigation\nassertTrue(navigator.navigateBack())\nassertEquals(HomeDestination.Feed, navigator.currentDestination.value)`\n\nconst fakeNavigatorCode = `class FakeNavigator : Navigator {\n    var lastDestination: NavDestination? = null\n    var backPressed = false\n    \n    override fun navigate(destination: NavDestination, transition: NavigationTransition?) {\n        lastDestination = destination\n    }\n    \n    override fun navigateBack(): Boolean {\n        backPressed = true\n        return true\n    }\n    \n    override val currentDestination = MutableStateFlow<NavDestination?>(null)\n    override val canNavigateBack = MutableStateFlow(false)\n    // ... other properties\n}`\n\nconst mviContainerTestCode = `class ProfileContainerTest {\n    \n    private lateinit var repository: FakeProfileRepository\n    private lateinit var navigator: FakeNavigator\n    private lateinit var container: ProfileContainer\n    \n    @BeforeTest\n    fun setup() {\n        repository = FakeProfileRepository()\n        navigator = FakeNavigator()\n        \n        val testScope = TestNavigationContainerScope(\n            navigator = navigator,\n            screenKey =  \n        )\n        \n        container = ProfileContainer(\n            scope = testScope,\n            repository = repository\n        )\n    }\n    \n    @Test\n    fun \\`loading profile emits loading then content state\\`() = runTest {\n        val testUser = UserData(id =  ), awaitAction())\n}`\n\nconst navigationResultsTestCode = `@Test\nfun \\`navigateForResult returns selected item\\`() = runTest {\n    val navigator = TreeNavigator(config, initialState)\n    \n    launch {\n        // Simulate picker returning result\n        delay(100)\n        navigator.navigateBackWithResult(SelectedItem( ))\n    }\n    \n    val result = navigator.navigateForResult(ItemPicker)\n    \n    assertEquals(SelectedItem( ), result)\n}\n\n@Test\nfun \\`navigateForResult returns null on back\\`() = runTest {\n    val navigator = TreeNavigator(config, initialState)\n    \n    launch {\n        delay(100)\n        navigator.navigateBack()  // No result\n    }\n    \n    val result = navigator.navigateForResult(ItemPicker)\n    \n    assertNull(result)\n}`\n\nconst deepLinkTestCode = `@Test\nfun \\`deep link navigates to article\\`() {\n    val navigator = TreeNavigator(config, initialState)\n    \n    val handled = navigator.handleDeepLink( )\n    \n    assertTrue(handled)\n    assertEquals(\n        HomeDestination.Article( ),\n        navigator.currentDestination.value\n    )\n}\n\n@Test\nfun \\`unknown deep link returns false\\`() {\n    val navigator = TreeNavigator(config, initialState)\n    \n    val handled = navigator.handleDeepLink( )\n    \n    assertFalse(handled)\n}`\n\nconst composeUiTestCode = `class ProfileScreenTest {\n    \n    @get:Rule\n    val composeTestRule = createComposeRule()\n    \n    @Test\n    fun \\`profile screen shows loading then content\\`() {\n        val fakeStore = FakeStore<ProfileState, ProfileIntent, ProfileAction>(\n            initialState = ProfileState.Loading\n        )\n        \n        composeTestRule.setContent {\n            ProfileScreen(container = fakeStore)\n        }\n        \n        composeTestRule.onNodeWithText( ).assertIsDisplayed()\n        \n        fakeStore.emitState(ProfileState.Content(testUser))\n        \n        composeTestRule.onNodeWithText( ).assertIsDisplayed()\n    }\n}`\n\nconst stateAssertionsCode = `// Assert current destination type\nassertTrue(navigator.currentDestination.value is HomeDestination.Article)\n\n// Assert destination arguments\nval article = navigator.currentDestination.value as HomeDestination.Article\nassertEquals( >TreeNavigator for Unit Tests</h2>\n        <p>\n          Use <code>TreeNavigator</code> directly in tests to verify navigation logic\n          with the real navigation implementation:\n        </p>\n        <CodeBlock code={treeNavigatorCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >FakeNavigator Pattern</h2>\n        <p>\n          Create a fake navigator for lightweight unit tests that don  />\n      </section>\n\n      <section>\n        <h2 id= >Testing MVI Containers</h2>\n        <p>\n          Test FlowMVI containers with fake dependencies to verify state transitions\n          and navigation side effects:\n        </p>\n        <CodeBlock code={mviContainerTestCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >TestNavigationContainerScope</h2>\n        <p>\n          Create a test scope to provide dependencies for container testing:\n        </p>\n        <CodeBlock code={testScopeCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >FlowMVI Store Testing</h2>\n        <p>\n          Use the FlowMVI test DSL to verify state transitions and actions:\n        </p>\n        <CodeBlock code={flowMviTestCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Testing Navigation with Results</h2>\n        <p>\n          Test the <code>navigateForResult</code> pattern with coroutines:\n        </p>\n        <CodeBlock code={navigationResultsTestCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Testing Deep Links</h2>\n        <p>\n          Verify that deep links are handled correctly and navigate to the expected destinations:\n        </p>\n        <CodeBlock code={deepLinkTestCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Compose UI Testing</h2>\n        <p>\n          Test Compose screens with fake stores to verify UI behavior:\n        </p>\n        <CodeBlock code={composeUiTestCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Navigation State Assertions</h2>\n        <p>\n          Common assertion patterns for verifying navigation state:\n        </p>\n        <CodeBlock code={stateAssertionsCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Best Practices</h2>\n        <ul>\n          <li>Test navigation logic separately from UI</li>\n          <li>Use <code>FakeNavigator</code> for container tests</li>\n          <li>Use <code>TreeNavigator</code> for integration tests</li>\n          <li>Test state transitions, not implementation details</li>\n          <li>Mock repositories and dependencies</li>\n          <li>Test deep link handling with various patterns</li>\n          <li>Verify navigation effects on state</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >FlowMVI Integration</a> - Learn about MVI container patterns</li>\n          <li><a href= >Navigation Results</a> - Understand navigating for results</li>\n          <li><a href= >Deep Links</a> - Configure deep link handling</li>\n          <li><a href="
  },
  {
    "id": "Features/Transitions/transitions",
    "title": "Transitions",
    "route": "/Features/Transitions/transitions",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css , startDestination = HomeDestination.List::class)\nsealed class HomeDestination : NavDestination {\n\n    @Destination(route =  )\n    data object List : HomeDestination()\n\n    @Transition(type = TransitionType.SlideHorizontal)\n    @Destination(route =  )\n    data class Details(@Argument val id: String) : HomeDestination()\n\n    @Transition(type = TransitionType.SlideVertical)\n    @Destination(route =  )\n    data object Filter : HomeDestination()\n\n    @Transition(type = TransitionType.Fade)\n    @Destination(route =  )\n    data object Help : HomeDestination()\n}`\n\nconst customTransitionBuilderCode = `// Using TransitionBuilder DSL\nval myTransition = customTransition {\n    enter = fadeIn() + expandHorizontally()\n    exit = fadeOut() + shrinkHorizontally()\n    popEnter = fadeIn() + expandHorizontally(expandFrom = Alignment.End)\n    popExit = fadeOut() + shrinkHorizontally(shrinkTowards = Alignment.End)\n}\n\n// Using NavTransition directly\nval scaleAndFade = NavTransition(\n    enter = scaleIn(initialScale = 0.8f) + fadeIn(),\n    exit = scaleOut(targetScale = 1.2f) + fadeOut(),\n    popEnter = scaleIn(initialScale = 1.2f) + fadeIn(),\n    popExit = scaleOut(targetScale = 0.8f) + fadeOut()\n)`\n\nconst dslRegistrationCode = `val config = navigationConfig {\n    transition<DetailScreen>(NavTransition.SlideHorizontal)\n    transition<ModalScreen>(NavTransition.SlideVertical)\n    transition<SettingsScreen>(NavTransition.Fade)\n}`\n\nconst transitionScopeAccessCode = `@Composable\nfun MyScreen() {\n    val transitionScope = LocalTransitionScope.current\n    \n    transitionScope?.let { scope ->\n        // scope.sharedTransitionScope - for sharedElement/sharedBounds\n        // scope.animatedVisibilityScope - for animateEnterExit\n    }\n}`\n\nconst sharedElementCode = `Icon(\n    modifier = if (transitionScope != null) {\n        with(transitionScope.sharedTransitionScope) {\n            Modifier.sharedElement(\n                sharedContentState = rememberSharedContentState(key =  ),\n                animatedVisibilityScope = transitionScope.animatedVisibilityScope\n            )\n        }\n    } else Modifier\n)`\n\nconst sharedBoundsCode = `Card(\n    modifier = if (transitionScope != null) {\n        with(transitionScope.sharedTransitionScope) {\n            Modifier.sharedBounds(\n                sharedContentState = rememberSharedContentState(key =  >How Transitions Work</h2>\n        <p>\n          Transitions in Quo Vadis are deeply integrated with the tree-based navigation \n          architecture. The system provides smooth, coordinated animations across all \n          navigation contexts.\n        </p>\n        <ul>\n          <li><strong>NavigationHost</strong> wraps content in <code>SharedTransitionLayout</code> for shared element support</li>\n          <li><strong>NavNodeRenderer</strong> dispatches to specialized renderers for each node type</li>\n          <li>Each renderer uses <strong>AnimatedNavContent</strong> for coordinated transitions</li>\n        </ul>\n        <p>\n          This architecture ensures transitions work consistently whether you >@Transition Annotation</h2>\n        <p>\n          Apply transitions per-destination using the <code>@Transition</code> annotation. \n          This allows fine-grained control over how each screen enters and exits.\n        </p>\n        <CodeBlock code={transitionAnnotationCode} language=  />\n        <p>\n          Each destination can specify its own transition type, overriding the default \n          for its navigation context.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Transition Phases</h2>\n        <p>\n          Every transition defines four animation phases to handle both forward \n          navigation (push) and backward navigation (pop):\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Phase</th>\n              <th>Direction</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>enter</code></td>\n              <td>Forward</td>\n              <td>New screen appearing (push)</td>\n            </tr>\n            <tr>\n              <td><code>exit</code></td>\n              <td>Forward</td>\n              <td>Current screen disappearing (push)</td>\n            </tr>\n            <tr>\n              <td><code>popEnter</code></td>\n              <td>Back</td>\n              <td>Previous screen re-appearing (pop)</td>\n            </tr>\n            <tr>\n              <td><code>popExit</code></td>\n              <td>Back</td>\n              <td>Current screen disappearing (pop)</td>\n            </tr>\n          </tbody>\n        </table>\n        <p>\n          This four-phase model ensures animations look correct in both directions, \n          providing a polished user experience.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Custom Transitions</h2>\n        <p>\n          Create custom transitions using either the DSL builder or by constructing \n          <code>NavTransition</code> directly. Compose  />\n        <p>\n          Custom transitions give you complete control over timing, easing, and \n          animation composition for unique navigation effects.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >DSL-based Registration</h2>\n        <p>\n          Register transitions programmatically using the navigation config DSL. \n          This approach works well when transitions are determined at runtime or \n          managed centrally.\n        </p>\n        <CodeBlock code={dslRegistrationCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Shared Element Transitions</h2>\n        <p>\n          Quo Vadis integrates with Compose  />\n\n        <h3>sharedElement (Exact Visual Matches)</h3>\n        <p>\n          Use <code>sharedElement</code> for content that remains visually identical \n          between screens, such as icons, images, or avatars.\n        </p>\n        <CodeBlock code={sharedElementCode} language=  />\n\n        <h3>sharedBounds (Containers with Different Content)</h3>\n        <p>\n          Use <code>sharedBounds</code> for containers where the bounds transition \n          but the content may differ, such as expanding cards.\n        </p>\n        <CodeBlock code={sharedBoundsCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Key Rules for Shared Elements</h2>\n        <ul>\n          <li><strong>Keys must match exactly</strong> between source and destination screens</li>\n          <li><strong>Use unique, stable identifiers:</strong> <code> </code></li>\n          <li>Works in <strong>both forward AND backward</strong> navigation</li>\n          <li>Use <code>sharedElement</code> for icons/images, <code>sharedBounds</code> for containers</li>\n          <li>Always check for <code>null</code> when accessing <code>LocalTransitionScope</code></li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Context-Specific Behavior</h2>\n        <p>\n          Different navigation contexts use different default transitions optimized \n          for their use case:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Context</th>\n              <th>Default Transition</th>\n              <th>Notes</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Stack navigation</td>\n              <td><code>SlideHorizontal</code></td>\n              <td>Hierarchical push/pop</td>\n            </tr>\n            <tr>\n              <td>Tab switching</td>\n              <td><code>Fade</code></td>\n              <td>Parallel content switching</td>\n            </tr>\n            <tr>\n              <td>Pane transitions</td>\n              <td><code>Fade</code></td>\n              <td>Based on adaptive mode</td>\n            </tr>\n          </tbody>\n        </table>\n        <p>\n          These defaults can be overridden per-destination using the <code>@Transition</code> \n          annotation or programmatically via the DSL.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Predictive Back</a> - Gesture-driven navigation with preview</li>\n          <li><a href= >Deep Links</a> - URL-based navigation</li>\n          <li><a href="
  },
  {
    "id": "Features/TypeSafe/typesafe",
    "title": "Type Safe",
    "route": "/Features/TypeSafe/typesafe",
    "content": "@components/CodeBlock/CodeBlock ../Features.module.css ))\n\n// With explicit transition\nnavigator.navigate(\n    destination = HomeDestination.Article(articleId =  ),\n    transition = NavigationTransitions.SlideHorizontal\n)`\n\nconst backNavigationCode = `val didNavigate = navigator.navigateBack()`\n\nconst clearReplaceCode = `// Navigate and clear back to specific route\nnavigator.navigateAndClearTo(\n    destination = SettingsDestination.Main,\n    clearRoute =  ,\n    inclusive = false\n)\n\n// Replace current screen\nnavigator.navigateAndReplace(\n    destination = ProfileDestination.EditProfile,\n    transition = NavigationTransitions.Fade\n)\n\n// Clear entire backstack\nnavigator.navigateAndClearAll(AuthDestination.Login)`\n\nconst navigationResultsCode = `// Define result-returning destination\ndata class SelectedItem(val id: String, val name: String)\n\n@Destination(route =  )\ndata object ItemPicker : PickerDestination(), ReturnsResult<SelectedItem>\n\n// Navigate for result (suspends until result)\nval result: SelectedItem? = navigator.navigateForResult(ItemPicker)\n\n// Return result and navigate back\nnavigator.navigateBackWithResult(SelectedItem(id =  ))`\n\nconst paneNavigationCode = `// Cast to PaneNavigator for pane operations\nval paneNavigator = navigator.asPaneNavigator()\n\n// Navigate within a specific pane\npaneNavigator?.navigateToPane(\n    MessagesPane.ConversationDetail(conversationId),\n    role = PaneRole.Supporting\n)\n\n// Check pane availability\nif (paneNavigator?.isPaneAvailable(PaneRole.Extra) == true) {\n    // Show extra content\n}`\n\nconst stateObservationCode = `@Composable\nfun NavigationAwareContent(navigator: Navigator) {\n    val currentDest by navigator.currentDestination.collectAsState()\n    val canBack by navigator.canNavigateBack.collectAsState()\n    \n    // UI based on navigation state\n    IconButton(\n        onClick = { navigator.navigateBack() },\n        enabled = canBack\n    ) {\n        Icon(Icons.Default.ArrowBack,  >Navigator Interface</h2>\n        <p>\n          The <code>Navigator</code> interface is the central API for all navigation operations. It exposes \n          reactive state properties and type-safe navigation methods:\n        </p>\n        <CodeBlock code={navigatorInterfaceCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >State Properties</h2>\n        <p>\n          The Navigator exposes several observable properties that allow your UI to react to navigation changes:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Property</th>\n              <th>Type</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>state</code></td>\n              <td><code>StateFlow&lt;NavNode&gt;</code></td>\n              <td>Complete navigation tree (single source of truth)</td>\n            </tr>\n            <tr>\n              <td><code>currentDestination</code></td>\n              <td><code>StateFlow&lt;NavDestination?&gt;</code></td>\n              <td>Active leaf destination</td>\n            </tr>\n            <tr>\n              <td><code>previousDestination</code></td>\n              <td><code>StateFlow&lt;NavDestination?&gt;</code></td>\n              <td>Destination before current</td>\n            </tr>\n            <tr>\n              <td><code>canNavigateBack</code></td>\n              <td><code>StateFlow&lt;Boolean&gt;</code></td>\n              <td>Whether back navigation is possible</td>\n            </tr>\n            <tr>\n              <td><code>config</code></td>\n              <td><code>NavigationConfig</code></td>\n              <td>Navigation configuration</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Navigation Operations</h2>\n        \n        <h3>Forward Navigation</h3>\n        <p>\n          Navigate to a destination using the type-safe <code>navigate()</code> method. \n          Optionally specify a transition animation:\n        </p>\n        <CodeBlock code={forwardNavigationCode} language=  />\n\n        <h3>Back Navigation</h3>\n        <p>\n          Navigate back to the previous screen. Returns <code>true</code> if navigation occurred:\n        </p>\n        <CodeBlock code={backNavigationCode} language=  />\n\n        <h3>Clear and Replace</h3>\n        <p>\n          Advanced navigation operations for managing the back stack:\n        </p>\n        <CodeBlock code={clearReplaceCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Navigation with Results</h2>\n        <p>\n          Quo Vadis supports type-safe result passing between screens using the <code>ReturnsResult</code> interface. \n          The calling screen suspends until a result is returned:\n        </p>\n        <CodeBlock code={navigationResultsCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Pane Navigation</h2>\n        <p>\n          For adaptive layouts on tablets and large screens, cast the Navigator to <code>PaneNavigator</code> \n          to access pane-specific operations:\n        </p>\n        <CodeBlock code={paneNavigationCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >State Observation in Compose</h2>\n        <p>\n          Use <code>collectAsState()</code> to observe navigation state changes and update your UI reactively:\n        </p>\n        <CodeBlock code={stateObservationCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >TreeNavigator Setup</h2>\n        <p>\n          <code>TreeNavigator</code> is the concrete implementation of the Navigator interface. \n          Create it with a configuration and initial state:\n        </p>\n        <CodeBlock code={treeNavigatorSetupCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Multi-Module Configuration</h2>\n        <p>\n          In multi-module projects, combine navigation configs from different features using the <code>+</code> operator:\n        </p>\n        <CodeBlock code={multiModuleConfigCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Koin Integration</h2>\n        <p>\n          Set up the Navigator as a singleton in your Koin module for dependency injection:\n        </p>\n        <CodeBlock code={koinIntegrationCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><a href= >Annotation-Based API</a> - Learn about <code>@Destination</code>, <code>@Stack</code>, and code generation</li>\n          <li><a href= >Tree Architecture</a> - Understand the navigation tree structure</li>\n          <li><a href= >Adaptive Navigation</a> - Build responsive layouts with panes</li>\n          <li><a href="
  },
  {
    "id": "GettingStarted/gettingstarted",
    "title": "Getting Started",
    "route": "/GettingStarted/gettingstarted",
    "content": "@components/CodeBlock/CodeBlock ./GettingStarted.module.css org.jetbrains.kotlin.plugin.serialization com.google.devtools.ksp io.github.jermeyyy.quo-vadis \n}\n\nkotlin {\n    sourceSets {\n        commonMain.dependencies {\n            implementation( )\n            implementation( )\n        }\n    }\n}\n\n// Optional: Configure the plugin\nquoVadis {\n    modulePrefix =    // Generates MyAppNavigationConfig\n}`\n\n// Installation - Option 2: Manual Configuration\nconst installationManualCode = `// build.gradle.kts\nplugins {\n    kotlin( org.jetbrains.kotlin.plugin.serialization com.google.devtools.ksp \n}\n\nkotlin {\n    sourceSets {\n        commonMain.dependencies {\n            implementation( )\n            implementation( )\n        }\n    }\n    \n    ksp {\n        arg( )\n    }\n}\n\ndependencies {\n    add( io.github.jermeyyy:quo-vadis-ksp:0.3.3 build/generated/ksp/metadata/commonMain/kotlin , ignoreCase = true)) {\n            dependsOn( , startDestination = Feed::class)\nsealed class HomeDestination : NavDestination {\n\n    @Destination(route =  )\n    data object Feed : HomeDestination()\n\n    @Destination(route =  )\n    data class Article(\n        @Argument val articleId: String,\n        @Argument(optional = true) val showComments: Boolean = false\n    ) : HomeDestination()\n\n    @Destination(route =  )\n        Button(onClick = { \n            navigator.navigate(HomeDestination.Article(articleId =  ))\n        }) {\n            Text( )\n        }\n    }\n}\n\n@Screen(HomeDestination.Article::class)\n@Composable\nfun ArticleScreen(\n    destination: HomeDestination.Article,\n    navigator: Navigator\n) {\n    Column {\n        Text( )\n        if (destination.showComments) {\n            Text( )\n        }\n        Button(onClick = { navigator.navigateBack() }) {\n            Text( >Installation</h2>\n\n        <p>\n          Choose one of the following installation methods. The Gradle plugin approach is recommended\n          as it handles KSP configuration automatically.\n        </p>\n\n        <h3 id= >Option 1: Using Gradle Plugin (Recommended)</h3>\n        <p>\n          The Gradle plugin automatically configures KSP and registers generated sources, making setup\n          simpler and more reliable.\n        </p>\n        <CodeBlock code={installationGradlePluginCode} language= >Option 2: Manual Configuration</h3>\n        <p>\n          If you need more control over the build configuration, you can set up KSP manually.\n        </p>\n        <CodeBlock code={installationManualCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Define Your Navigation Stack</h2>\n        <p>\n          Create a sealed class extending <code>NavDestination</code> and annotate it with <code>@Stack</code>.\n          Each destination is defined as a nested class with the <code>@Destination</code> annotation.\n        </p>\n        <CodeBlock code={defineStackCode} language= >Bind Screens with @Screen</h2>\n        <p>\n          Use the <code>@Screen</code> annotation to connect your composables to destinations.\n          The navigator is automatically injected, and destination data classes receive the destination instance.\n        </p>\n        <CodeBlock code={bindScreensCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Setup NavigationHost</h2>\n        <p>\n          Finally, set up the <code>NavigationHost</code> in your app  />\n      </section>\n\n      <section>\n        <h2 id= >What Gets Generated</h2>\n        <p>\n          KSP generates several classes based on your annotations. The prefix is configurable\n          via <code>modulePrefix</code> in your Gradle configuration.\n        </p>\n\n        <table>\n          <thead>\n            <tr>\n              <th>Generated Class</th>\n              <th>Purpose</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>{ }NavigationConfig</code></td>\n              <td>Main configuration with all registries</td>\n            </tr>\n            <tr>\n              <td><code>{ }ScreenRegistry</code></td>\n              <td>Maps destinations to composables</td>\n            </tr>\n            <tr>\n              <td><code>{ }DeepLinkHandler</code></td>\n              <td>Handles URI-based navigation</td>\n            </tr>\n            <tr>\n              <td><code>{ }ScopeRegistry</code></td>\n              <td>Scope membership for containers</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <p>\n          Now that you have basic navigation working, explore more advanced features:\n        </p>\n        <ul>\n          <li>\n            <a href= >Annotation API</a> — Full reference for all annotations\n            including <code>@Tabs</code>, <code>@Pane</code>, and more\n          </li>\n          <li>\n            <a href= >Tabbed Navigation</a> — Set up tab-based navigation\n            with independent backstacks\n          </li>\n          <li>\n            <a href= >Transitions</a> — Add custom animations and shared element\n            transitions\n          </li>\n          <li>\n            <a href="
  },
  {
    "id": "Home",
    "title": "Home",
    "route": "/Home",
    "content": "@components/CodeBlock/CodeBlock \n\nconst quickstartCode = `[versions]\nquoVadis =  \n\n[libraries]\nquo-vadis-core = { module =   }\nquo-vadis-annotations = { module =   }\n\n[plugins]\nksp = { id =   }\nquo-vadis = { id =   }`\n\nconst step1Code = `// Define a navigation stack with destinations\n@Stack(name =  , startDestination = Feed::class)\nsealed class HomeDestination : NavDestination {\n\n    @Destination(route =  )\n    data object Feed : HomeDestination()\n\n    @Destination(route =  )\n    data class Article(\n        @Argument val articleId: String,\n        @Argument(optional = true) val showComments: Boolean = false\n    ) : HomeDestination()\n}`\n\nconst step2Code = `// Bind screens with @Screen annotation\n@Screen(HomeDestination.Feed::class)\n@Composable\nfun FeedScreen(navigator: Navigator) {\n    Column {\n        Text( )\n        Button(onClick = { \n            navigator.navigate(HomeDestination.Article(articleId =  ))\n        }) {\n            Text( )\n        }\n    }\n}\n\n@Screen(HomeDestination.Article::class)\n@Composable\nfun ArticleScreen(\n    destination: HomeDestination.Article,\n    navigator: Navigator\n) {\n    Column {\n        Text( )\n        Button(onClick = { navigator.navigateBack() }) {\n            Text( >\n            <img src=  />\n          </a>\n          <a href= >\n            <img src=  />\n          </a>\n          <img src=  />\n          <img src=  />\n          <img src=  />\n          <img src=  />\n          <img src=  />\n          <img src= >View on GitHub</a>\n        </div>\n      </section>\n\n      {/* Overview */}\n      <section>\n        <h2 id= >Overview</h2>\n        <p>\n          <strong>Quo Vadis</strong> (Latin for  ) is a comprehensive, type-safe navigation \n          library for Kotlin Multiplatform and Compose Multiplatform. It uses a tree-based navigation architecture \n          where navigation state is an immutable tree of NavNode objects, providing a clean, intuitive API for \n          managing navigation across Android, iOS, Desktop, and Web platforms with zero string-based routing.\n        </p>\n      </section>\n\n            {/* Why Quo Vadis */}\n      <section>\n        <h2 id= >Show Me The Code!</h2>\n        <p style={{ marginBottom:  >Or Use Manual DSL for Full Control</h2>\n        <p style={{ marginBottom:   }}>\n          Prefer full control? The manual DSL API is still available for advanced use cases:\n        </p>\n        <CodeBlock code={manualDSLCode} language=  />\n      </section>\n\n      {/* Resources */}\n      <section>\n        <h2 id= >Resources</h2>\n        <ul>\n          <li><a href= >Getting Started Guide</a> - Installation and basic setup</li>\n          <li><a href= >Features Documentation</a> - Detailed feature explanations</li>\n          <li><a href= >API Reference</a> - Complete API documentation</li>\n          <li><a href= >Demo Application</a> - See all features in action</li>\n          <li><a href="
  }
]