package com.jermey.quo.vadis.ksp.generators

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.jermey.quo.vadis.ksp.QuoVadisClassNames
import com.jermey.quo.vadis.ksp.models.ScreenInfo
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.ksp.writeTo

/**
 * Generates the screen registry mapping destinations to composable content.
 *
 * Consumes [ScreenInfo] models and produces a single `GeneratedScreenRegistry.kt`
 * file containing:
 * - `object GeneratedScreenRegistry : ScreenRegistry`
 * - `Content()` composable with `when` expression dispatching to @Screen functions
 * - `hasContent()` method for destination availability checks
 *
 * ## Function Signature Handling
 *
 * The generator handles three function signatures:
 * 1. **Simple**: `fun FeedScreen(navigator: Navigator)`
 * 2. **With destination**: `fun DetailScreen(destination: Detail, navigator: Navigator)`
 * 3. **With shared scopes**: `fun GalleryScreen(destination: Gallery, navigator: Navigator,
 *    sharedTransitionScope: SharedTransitionScope, animatedVisibilityScope: AnimatedVisibilityScope)`
 *
 * @property codeGenerator KSP code generator for writing output files
 * @property logger KSP logger for diagnostic output
 */
class ScreenRegistryGenerator(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) {

    companion object {
        private const val GENERATED_PACKAGE = "com.jermey.quo.vadis.generated"
        private const val REGISTRY_NAME = "GeneratedScreenRegistry"

        // Compose type references
        private val COMPOSABLE = ClassName("androidx.compose.runtime", "Composable")
        private val SHARED_TRANSITION_SCOPE = ClassName("androidx.compose.animation", "SharedTransitionScope")
        private val ANIMATED_VISIBILITY_SCOPE = ClassName("androidx.compose.animation", "AnimatedVisibilityScope")
    }

    /**
     * Generate the screen registry from extracted screen information.
     *
     * @param screens List of ScreenInfo models from ScreenExtractor
     */
    fun generate(screens: List<ScreenInfo>) {
        if (screens.isEmpty()) {
            logger.warn("No @Screen annotations found, skipping registry generation")
            return
        }

        val fileSpec = buildFileSpec(screens)

        val dependencies = Dependencies(
            aggregating = true,
            sources = screens.mapNotNull { it.functionDeclaration.containingFile }.toTypedArray()
        )

        fileSpec.writeTo(codeGenerator, dependencies)

        logger.info("Generated $REGISTRY_NAME with ${screens.size} screen bindings")
    }

    private fun buildFileSpec(screens: List<ScreenInfo>): FileSpec {
        return FileSpec.builder(GENERATED_PACKAGE, REGISTRY_NAME)
            .addFileComment("DO NOT EDIT - Auto-generated by Quo Vadis KSP processor")
            .addType(buildRegistryObject(screens))
            .build()
    }

    private fun buildRegistryObject(screens: List<ScreenInfo>): TypeSpec {
        return TypeSpec.objectBuilder(REGISTRY_NAME)
            .addKdoc(
                """
                |KSP-generated screen registry mapping destinations to composable content.
                |
                |Generated from @Screen annotations found in the codebase.
                |DO NOT EDIT - This file is auto-generated by Quo Vadis KSP processor.
                """.trimMargin()
            )
            .addSuperinterface(QuoVadisClassNames.SCREEN_REGISTRY)
            .addFunction(buildContentFunction(screens))
            .addFunction(buildHasContentFunction(screens))
            .build()
    }

    private fun buildContentFunction(screens: List<ScreenInfo>): FunSpec {
        val whenCases = buildWhenCases(screens)

        return FunSpec.builder("Content")
            .addAnnotation(COMPOSABLE)
            .addModifiers(KModifier.OVERRIDE)
            .addParameter("destination", QuoVadisClassNames.DESTINATION)
            .addParameter("navigator", QuoVadisClassNames.NAVIGATOR)
            .addParameter(
                ParameterSpec.builder(
                    "sharedTransitionScope",
                    SHARED_TRANSITION_SCOPE.copy(nullable = true)
                ).build()
            )
            .addParameter(
                ParameterSpec.builder(
                    "animatedVisibilityScope",
                    ANIMATED_VISIBILITY_SCOPE.copy(nullable = true)
                ).build()
            )
            .beginControlFlow("when (destination)")
            .apply {
                whenCases.forEach { addStatement(it) }
            }
            .addStatement("else -> error(%S)", "No screen registered for destination: \$destination")
            .endControlFlow()
            .build()
    }

    private fun buildWhenCases(screens: List<ScreenInfo>): List<String> {
        val cases = mutableListOf<String>()

        // Group screens by parent class for comments
        val groupedScreens = screens.groupBy { screen ->
            screen.destinationClass.parentDeclaration?.simpleName?.asString()
        }

        groupedScreens.forEach { (parent, groupedScreens) ->
            // Add comment for grouped destinations
            val comment = if (parent != null) "// $parent screens" else "// Screens"
            cases.add(comment)

            groupedScreens.forEach { screen ->
                cases.add(buildWhenCase(screen))
            }
        }

        return cases
    }

    private fun buildWhenCase(screen: ScreenInfo): String {
        val destClassName = buildDestinationClassName(screen)
        val functionCall = buildFunctionCall(screen)
        return "is $destClassName -> $functionCall"
    }

    private fun buildDestinationClassName(screen: ScreenInfo): String {
        val destClass = screen.destinationClass
        val parentClass = destClass.parentDeclaration?.simpleName?.asString()
        val simpleName = destClass.simpleName.asString()
        return if (parentClass != null) "$parentClass.$simpleName" else simpleName
    }

    private fun buildFunctionCall(screen: ScreenInfo): String {
        val funcName = screen.functionName
        val args = mutableListOf<String>()

        // Add destination parameter if needed (cast to specific type)
        if (screen.hasDestinationParam) {
            val destClassName = buildDestinationClassName(screen)
            args.add("destination as $destClassName")
        }

        // Navigator is always passed
        args.add("navigator")

        // Add shared transition scopes if needed
        if (screen.hasSharedTransitionScope) {
            args.add("sharedTransitionScope!!")
        }
        if (screen.hasAnimatedVisibilityScope) {
            args.add("animatedVisibilityScope!!")
        }

        return "$funcName(${args.joinToString(", ")})"
    }

    private fun buildHasContentFunction(screens: List<ScreenInfo>): FunSpec {
        val destPatterns = screens.map { buildDestinationClassName(it) }

        return FunSpec.builder("hasContent")
            .addModifiers(KModifier.OVERRIDE)
            .addParameter("destination", QuoVadisClassNames.DESTINATION)
            .returns(Boolean::class)
            .beginControlFlow("return when (destination)")
            .apply {
                if (destPatterns.isNotEmpty()) {
                    // Join all patterns with commas for multi-branch
                    val patternList = destPatterns.joinToString(",\n        is ") { "is $it" }
                    addStatement("$patternList -> true")
                }
            }
            .addStatement("else -> false")
            .endControlFlow()
            .build()
    }
}
