package com.jermey.quo.vadis.ksp

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.buildCodeBlock

/**
 * Generates complete graph builder functions that wire @Content functions to destinations.
 * 
 * This replaces manual graph building with fully generated DSL using KotlinPoet.
 */
object GraphGenerator {

    private val OPT_IN = ClassName("kotlin", "OptIn")
    private val EXPERIMENTAL_SHARED_TRANSITION_API = ClassName(
        "androidx.compose.animation", 
        "ExperimentalSharedTransitionApi"
    )

    fun generate(
        graphInfo: GraphInfo,
        contentMappings: Map<String, ContentFunctionInfo>,
        codeGenerator: CodeGenerator,
        logger: KSPLogger
    ) {
        logger.info("Generating complete graph DSL: ${graphInfo.className}Graph")
        
        val fileSpec = buildFileSpec(graphInfo, contentMappings)
        
        val file = codeGenerator.createNewFile(
            dependencies = Dependencies(false),
            packageName = graphInfo.packageName,
            fileName = "${graphInfo.className}Graph"
        )
        
        file.writer().use { writer ->
            fileSpec.writeTo(writer)
        }
    }
    
    private fun buildFileSpec(
        graphInfo: GraphInfo,
        contentMappings: Map<String, ContentFunctionInfo>
    ): FileSpec {
        val className = graphInfo.className
        
        // Find first object destination for start destination
        val startDestination = graphInfo.destinations
            .firstOrNull { it.isObject }?.name 
            ?: graphInfo.destinations.firstOrNull()?.name 
            ?: "Unknown"
        
        return FileSpec.builder(graphInfo.packageName, "${className}Graph")
            .addFileComment("Generated by Quo Vadis KSP. Do not edit manually.")
            .addImport(QuoVadisClassNames.NAVIGATION_GRAPH_BUILDER.packageName, "navigationGraph")
            .apply {
                // Import content function packages - import individual functions
                contentMappings.values
                    .filter { mapping -> 
                        graphInfo.destinations.any { 
                            "${graphInfo.packageName}.${className}.${it.name}" == mapping.destinationClass 
                        }
                    }
                    .forEach { mapping ->
                        if (mapping.packageName != graphInfo.packageName) {
                            addImport(mapping.packageName, mapping.functionName)
                        }
                    }
            }
            .addFunction(buildGraphFunction(graphInfo, contentMappings, startDestination))
            .build()
    }
    
    private fun buildGraphFunction(
        graphInfo: GraphInfo,
        contentMappings: Map<String, ContentFunctionInfo>,
        startDestination: String
    ): FunSpec {
        val className = graphInfo.className
        val graphName = graphInfo.graphName
        
        return FunSpec.builder("build${className}Graph")
            .returns(QuoVadisClassNames.NAVIGATION_GRAPH)
            .addKdoc(
                """
                Auto-generated navigation graph for $className.
                
                Wires @Content annotated functions to their destinations.
                All routing and type-safe argument passing is handled automatically.
                """.trimIndent()
            )
            .addCode(
                buildCodeBlock {
                    beginControlFlow("return navigationGraph(%S)", graphName)
                    addStatement("startDestination(%T.%L)", 
                        ClassName(graphInfo.packageName, className),
                        startDestination
                    )
                    add("\n")
                    
                    // Generate destination registrations
                    graphInfo.destinations.forEach { dest ->
                        val fullDestName = "${graphInfo.packageName}.${className}.${dest.name}"
                        val contentInfo = contentMappings[fullDestName]
                        
                        if (contentInfo != null) {
                            add(buildDestinationCode(graphInfo, dest, contentInfo))
                        } else {
                            // Generate placeholder for destinations without @Content
                            addStatement("// TODO: Add @Content annotation for %L", dest.name)
                            addStatement(
                                "// destination(%T.%L)·{·_,·navigator·->", 
                                ClassName(graphInfo.packageName, className),
                                dest.name
                            )
                            addStatement("//     TODO(\"Implement %L content\")", dest.name)
                            addStatement("// }")
                            add("\n")
                        }
                    }
                    
                    endControlFlow()
                }
            )
            .build()
    }
    
    private fun buildDestinationCode(
        graphInfo: GraphInfo,
        dest: DestinationInfo,
        contentInfo: ContentFunctionInfo
    ): CodeBlock {
        val className = graphInfo.className
        val destName = dest.name
        val contentFuncName = contentInfo.functionName
        val classType = ClassName(graphInfo.packageName, className)
        
        return buildCodeBlock {
            addStatement("// Typed destination: %L", destName)
            if (dest.argumentType != null) {
                // Typed destination with argument
                addStatement("@%T(%T::class)", OPT_IN, EXPERIMENTAL_SHARED_TRANSITION_API)
                beginControlFlow(
                    "typedDestination%LWithScopes(destination·=·%T.%L::class)·{·data,·navigator,·transitionScope·->",
                    destName,
                    classType,
                    destName
                )
                addStatement("%L(data,·navigator)", contentFuncName)
                endControlFlow()
            } else {
                // Simple destination without argument
                beginControlFlow("destination(%T.%L)·{·_,·navigator·->", classType, destName)
                addStatement("%L(navigator)", contentFuncName)
                endControlFlow()
            }
            add("\n")
        }
    }
}
