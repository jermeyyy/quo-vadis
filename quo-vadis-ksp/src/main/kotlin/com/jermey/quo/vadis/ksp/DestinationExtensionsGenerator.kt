package com.jermey.quo.vadis.ksp

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.LambdaTypeName
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.UNIT
import com.squareup.kotlinpoet.asClassName
import com.squareup.kotlinpoet.ksp.writeTo
import kotlin.reflect.KClass

/**
 * Generates route registration and typed destination extensions.
 */
object DestinationExtensionsGenerator {
    
    fun generate(graphInfo: GraphInfo, codeGenerator: CodeGenerator, logger: KSPLogger) {
        val fileName = "${graphInfo.className}Registry"
        
        val initClassName = "${graphInfo.className}RouteInitializer"
        
        val fileSpec = FileSpec.builder(graphInfo.packageName, fileName)
            .addFileComment("Generated by Quo Vadis KSP. Do not edit manually.")
            .addImport(QuoVadisClassNames.ROUTE_REGISTRY.packageName, QuoVadisClassNames.ROUTE_REGISTRY.simpleName)
            .addType(
                TypeSpec.objectBuilder(initClassName)
                    .addKdoc("Registers routes for ${graphInfo.className} destinations")
                    .addInitializerBlock(
                        CodeBlock.builder().apply {
                            graphInfo.destinations.forEach { dest ->
                                val destinationType = ClassName(graphInfo.packageName, graphInfo.className, dest.name)
                                addStatement(
                                    "%T.register(%T::class, %S)",
                                    QuoVadisClassNames.ROUTE_REGISTRY,
                                    destinationType,
                                    dest.route
                                )
                            }
                        }.build()
                    )
                    .build()
            )
            .apply {
                // Generate typed destination extensions for destinations with @Argument
                graphInfo.destinations.filter { it.argumentType != null }.forEach { dest ->
                    generateTypedDestinationExtension(graphInfo, dest)
                    generateTypedDestinationWithScopesExtension(graphInfo, dest)
                }
            }
            .build()
        
        fileSpec.writeTo(codeGenerator, Dependencies(false, graphInfo.graphClass.containingFile!!))
        logger.info("Generated route registration and typed destination extensions: $fileName")
    }
    
    @Suppress("LongMethod")
    private fun FileSpec.Builder.generateTypedDestinationExtension(
        graphInfo: GraphInfo,
        dest: DestinationInfo
    ) {
        val destinationType = ClassName(graphInfo.packageName, graphInfo.className, dest.name)
        val argumentTypeName = ClassName.bestGuess(dest.argumentType!!)
        val functionName = "typedDestination${dest.name}"  // Include destination name to avoid JVM signature clashes
        
        addImport(
            QuoVadisClassNames.NAVIGATION_GRAPH_BUILDER.packageName,
            QuoVadisClassNames.NAVIGATION_GRAPH_BUILDER.simpleName
        )
        addImport(QuoVadisClassNames.NAVIGATOR.packageName, QuoVadisClassNames.NAVIGATOR.simpleName)
        addImport(QuoVadisClassNames.NAVIGATION_GRAPH_BUILDER.packageName, "typedDestination")
        addImport(
            QuoVadisClassNames.NAVIGATION_TRANSITION.packageName,
            QuoVadisClassNames.NAVIGATION_TRANSITION.simpleName
        )
        addImport("androidx.compose.runtime", "Composable")
        addImport("kotlin.reflect", "KClass")
        
        addFunction(
            FunSpec.builder(functionName)
                .receiver(QuoVadisClassNames.NAVIGATION_GRAPH_BUILDER)
                .addParameter(
                    ParameterSpec.builder(
                        "destination",
                        KClass::class.asClassName().parameterizedBy(destinationType)
                    ).build()
                )
                .addParameter(
                    ParameterSpec.builder(
                        "transition",
                        QuoVadisClassNames.NAVIGATION_TRANSITION.copy(nullable = true)
                    )
                        .defaultValue("null")
                        .build()
                )
                .addParameter(
                    ParameterSpec.builder(
                        "content",
                        LambdaTypeName.get(
                            parameters = listOf(
                                ParameterSpec.unnamed(argumentTypeName),
                                ParameterSpec.unnamed(QuoVadisClassNames.NAVIGATOR)
                            ),
                            returnType = UNIT
                        ).copy(
                            annotations = listOf(
                                AnnotationSpec.builder(
                                    ClassName("androidx.compose.runtime", "Composable")
                                ).build()
                            )
                        )
                    )
                        .build()
                )
                .addKdoc(
                    """
                    Type-safe destination registration for ${dest.name}.
                    
                    Automatically handles serialization of ${argumentTypeName.simpleName}.
                    
                    @param destination The destination class reference (${dest.name}::class)
                    @param transition Optional transition animation
                    @param content Composable content receiving typed data and navigator
                    """.trimIndent()
                )
                .addStatement(
                    "typedDestination<%T, %T>(%S, transition, content)",
                    destinationType,
                    argumentTypeName,
                    dest.route
                )
                .build()
        )
    }
    
    @Suppress("LongMethod")
    private fun FileSpec.Builder.generateTypedDestinationWithScopesExtension(
        graphInfo: GraphInfo,
        dest: DestinationInfo
    ) {
        val destinationType = ClassName(graphInfo.packageName, graphInfo.className, dest.name)
        val argumentTypeName = ClassName.bestGuess(dest.argumentType!!)
        // Include destination name to avoid JVM signature clashes
        val functionName = "typedDestination${dest.name}WithScopes"
        
        addImport(QuoVadisClassNames.NAVIGATION_GRAPH_BUILDER.packageName, "typedDestinationWithScopes")
        addImport(QuoVadisClassNames.TRANSITION_SCOPE.packageName, QuoVadisClassNames.TRANSITION_SCOPE.simpleName)
        
        addFunction(
            FunSpec.builder(functionName)
                .receiver(QuoVadisClassNames.NAVIGATION_GRAPH_BUILDER)
                .addParameter(
                    ParameterSpec.builder(
                        "destination",
                        KClass::class.asClassName().parameterizedBy(destinationType)
                    ).build()
                )
                .addParameter(
                    ParameterSpec.builder(
                        "transition",
                        QuoVadisClassNames.NAVIGATION_TRANSITION.copy(nullable = true)
                    )
                        .defaultValue("null")
                        .build()
                )
                .addParameter(
                    ParameterSpec.builder(
                        "content",
                        LambdaTypeName.get(
                            parameters = listOf(
                                ParameterSpec.unnamed(argumentTypeName),
                                ParameterSpec.unnamed(QuoVadisClassNames.NAVIGATOR),
                                ParameterSpec.unnamed(QuoVadisClassNames.TRANSITION_SCOPE.copy(nullable = true))
                            ),
                            returnType = UNIT
                        ).copy(
                            annotations = listOf(
                                AnnotationSpec.builder(
                                    ClassName("androidx.compose.runtime", "Composable")
                                ).build()
                            )
                        )
                    )
                        .build()
                )
                .addKdoc(
                    """
                    Type-safe destination registration for ${dest.name} with shared element support.
                    
                    Automatically handles serialization of ${argumentTypeName.simpleName}.
                    Provides TransitionScope for shared element animations.
                    
                    @param destination The destination class reference (${dest.name}::class)
                    @param transition Optional transition animation
                    @param content Composable content receiving typed data, navigator, and transition scope
                    """.trimIndent()
                )
                .addAnnotation(
                    AnnotationSpec.builder(ClassName("kotlin", "OptIn"))
                        .addMember(
                            "%T::class",
                            ClassName("androidx.compose.animation", "ExperimentalSharedTransitionApi")
                        )
                        .build()
                )
                .addStatement(
                    "typedDestinationWithScopes<%T, %T>(%S, transition, content)",
                    destinationType,
                    argumentTypeName,
                    dest.route
                )
                .build()
        )
    }
}
