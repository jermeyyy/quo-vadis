@file:Suppress("CanConvertToMultiDollarString")

package com.jermey.quo.vadis.ksp.generators

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.symbol.KSDeclaration
import com.google.devtools.ksp.symbol.KSType
import com.jermey.quo.vadis.ksp.QuoVadisClassNames
import com.jermey.quo.vadis.ksp.models.DestinationInfo
import com.jermey.quo.vadis.ksp.models.ParamInfo
import com.jermey.quo.vadis.ksp.models.SerializerType
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.LambdaTypeName
import com.squareup.kotlinpoet.LIST
import com.squareup.kotlinpoet.MAP
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.STRING
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.ksp.writeTo

/**
 * Generates a [com.jermey.quo.vadis.core.dsl.registry.DeepLinkRegistry]
 * implementation for parsing deep link URIs into destinations.
 *
 * ## Route Pattern Syntax
 *
 * | Pattern | Example URI | Extracted Params |
 * |---------|-------------|------------------|
 * | `home/feed` | `myapp://home/feed` | (none) |
 * | `home/detail/{id}` | `myapp://home/detail/123` | `id="123"` |
 * | `user/{userId}/post/{postId}` | `myapp://user/42/post/99` | `userId="42"`, `postId="99"` |
 *
 * ## Example Generated Code
 *
 * ```kotlin
 * object GeneratedDeepLinkHandler : DeepLinkRegistry {
 *     private val routes = listOf(
 *         RoutePattern("home/feed", emptyList()) { HomeDestination.Feed },
 *         RoutePattern("home/detail/{id}", listOf("id")) { params ->
 *             HomeDestination.Detail(id = params["id"]!!)
 *         }
 *     )
 *
 *     override fun handleDeepLink(uri: String): DeepLinkResult { ... }
 *     override fun createDeepLinkUri(destination: Destination, scheme: String): String? { ... }
 * }
 * ```
 *
 * @property codeGenerator KSP code generator for writing output files
 * @property logger KSP logger for diagnostic output
 * @property modulePrefix Optional prefix for generated class names (e.g., "ComposeApp" -> "ComposeAppDeepLinkHandler")
 */
class DeepLinkHandlerGenerator(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
    private val modulePrefix: String = ""
) {

    // Dynamic handler name based on modulePrefix
    private val handlerName: String = "${modulePrefix}DeepLinkHandler"
    private val routePatternClassName: String = "${modulePrefix}RoutePattern"

    companion object {
        private const val GENERATED_PACKAGE = "com.jermey.quo.vadis.generated"
    }

    /**
     * Generate the deep link handler from extracted destination information.
     *
     * Filters destinations to those with non-null, non-empty routes and generates
     * a handler implementation. If no routable destinations are found, logs a warning
     * and skips generation.
     *
     * @param destinations List of DestinationInfo models from DestinationExtractor
     */
    fun generate(destinations: List<DestinationInfo>) {
        // Filter to destinations with valid routes
        val routableDestinations = destinations.filter { !it.route.isNullOrBlank() }

        if (routableDestinations.isEmpty()) {
            logger.warn("No @Destination annotations with routes found, skipping deep link handler generation")
            return
        }

        val fileSpec = buildFileSpec(routableDestinations)

        val dependencies = Dependencies(
            aggregating = true,
            sources = routableDestinations.mapNotNull { it.classDeclaration.containingFile }.toTypedArray()
        )

        fileSpec.writeTo(codeGenerator, dependencies)

        logger.info("Generated $handlerName with ${routableDestinations.size} route patterns")
    }

    /**
     * Build the complete file specification for the generated DeepLinkRegistry.
     */
    private fun buildFileSpec(destinations: List<DestinationInfo>): FileSpec {
        return FileSpec.builder(GENERATED_PACKAGE, handlerName)
            .addFileComment("DO NOT EDIT - Auto-generated by Quo Vadis KSP processor")
            .addType(buildHandlerObject(destinations))
            .addType(buildRoutePatternClass())
            .build()
    }

    /**
     * Build the DeepLinkRegistry implementation object.
     */
    private fun buildHandlerObject(destinations: List<DestinationInfo>): TypeSpec {
        return TypeSpec.objectBuilder(handlerName)
            .addKdoc(
                """
                |KSP-generated deep link registry mapping URIs to destinations.
                |
                |Generated from @Destination annotations found in the codebase.
                |DO NOT EDIT - This file is auto-generated by Quo Vadis KSP processor.
                |
                |Supports ${destinations.size} route patterns.
                """.trimMargin()
            )
            .addSuperinterface(QuoVadisClassNames.DEEP_LINK_REGISTRY)
            .addProperty(buildRoutesProperty(destinations))
            .addProperty(buildPatternStringsProperty())
            .addFunction(buildHandleDeepLinkFunction())
            .addFunction(buildCreateUriFunction(destinations))
            .addFunction(buildExtractPathFunction())
            // DeepLinkRegistry interface methods
            .addFunction(buildResolveUriFunction())
            .addFunction(buildResolveDeepLinkFunction())
            .addFunction(buildSimpleRegisterFunction())
            .addFunction(buildRegisterActionFunction())
            .addFunction(buildHandleFunction())
            .addFunction(buildCanHandleFunction())
            .addFunction(buildGetRegisteredPatternsFunction())
            .build()
    }

    /**
     * Build the routes property containing all RoutePattern instances.
     */
    private fun buildRoutesProperty(destinations: List<DestinationInfo>): PropertySpec {
        val routePatternType = ClassName(GENERATED_PACKAGE, routePatternClassName)
        val listOfRoutePattern = ClassName("kotlin.collections", "List")
            .parameterizedBy(routePatternType)

        // Filter out empty patterns (from sealed classes that can't be instantiated)
        val routePatterns = destinations
            .map { dest -> buildRoutePatternInitializer(dest) }
            .filter { it.toString().isNotEmpty() }

        return PropertySpec.builder("routes", listOfRoutePattern)
            .addModifiers(KModifier.PRIVATE)
            .initializer(
                CodeBlock.builder()
                    .add("listOf(\n")
                    .indent()
                    .apply {
                        routePatterns.forEachIndexed { index, pattern ->
                            add(pattern)
                            if (index < routePatterns.lastIndex) add(",")
                            add("\n")
                        }
                    }
                    .unindent()
                    .add(")")
                    .build()
            )
            .build()
    }

    /**
     * Build the patternStrings property containing all route pattern strings.
     */
    private fun buildPatternStringsProperty(): PropertySpec {
        return PropertySpec.builder(
            "patternStrings",
            LIST.parameterizedBy(STRING)
        )
            .addModifiers(KModifier.PRIVATE)
            .initializer("routes.map { it.pattern }")
            .build()
    }

    /**
     * Build a single RoutePattern initializer for a destination.
     *
     * Uses %T format specifier for destination class names to ensure
     * KotlinPoet generates proper imports in the output file.
     *
     * Handles three cases:
     * - Objects (data object, companion object, regular object): `DestinationClass.Object`
     * - Data classes with route params: `DestinationClass.DataClass(param = params["param"]!!.toInt())`
     * - Data classes without route params (optional/default params): `DestinationClass.DataClass()`
     * - Sealed classes: Skipped (cannot be instantiated directly)
     *
     * Uses @Argument annotation data for proper type conversions:
     * - STRING: direct use
     * - INT: .toInt() or .toIntOrNull()
     * - LONG: .toLong() or .toLongOrNull()
     * - FLOAT: .toFloat() or .toFloatOrNull()
     * - DOUBLE: .toDouble() or .toDoubleOrNull()
     * - BOOLEAN: .toBooleanStrictOrNull()
     * - ENUM: enumValueOf<T>()
     * - JSON: fallback to string (complex types)
     */
    @Suppress("ReturnCount")
    private fun buildRoutePatternInitializer(dest: DestinationInfo): CodeBlock {
        val route = dest.route ?: return CodeBlock.of("")

        // Skip sealed classes - they cannot be instantiated directly
        // (their subclasses should be used as destinations instead)
        if (dest.isSealedClass) {
            logger.info("Skipping sealed class ${dest.className} in deep link handler - cannot be instantiated")
            return CodeBlock.of("")
        }

        val routeParams = dest.routeParams
        val destClassName = buildDestinationClassName(dest)

        return when {
            dest.isObject -> {
                // Any object (data object, companion object, regular object) - no parentheses needed
                CodeBlock.of(
                    "$routePatternClassName(%S, emptyList()) { %T }",
                    route,
                    destClassName
                )
            }
            routeParams.isEmpty() && dest.constructorParams.isEmpty() -> {
                // Data class with no route params and no constructor params - needs parentheses
                CodeBlock.of(
                    "$routePatternClassName(%S, emptyList()) { %T() }",
                    route,
                    destClassName
                )
            }
            else -> {
                // Data class with route params or constructor params - extract and pass parameters
                val paramAssignments = buildParamAssignments(dest)
                CodeBlock.of(
                    "$routePatternClassName(%S, listOf(%L)) { params ->\n    %T(%L)\n}",
                    route,
                    routeParams.joinToString(", ") { "\"$it\"" },
                    destClassName,
                    paramAssignments
                )
            }
        }
    }

    /**
     * Build parameter assignments for a destination's constructor.
     *
     * Uses constructorParams from DestinationInfo to get @Argument metadata
     * including serializerType for proper type conversion.
     *
     * For params with defaults and non-nullable types, we skip them in the generated code
     * so that Kotlin uses the default values. This is because we can't know the default
     * value at code generation time, and passing null would cause a type mismatch.
     *
     * Query params with nullable types (e.g., `count: Long?`) will be passed with
     * null-safe conversion.
     */
    private fun buildParamAssignments(dest: DestinationInfo): String {
        val routeParams = dest.routeParams.toSet()
        val constructorParams = dest.constructorParams

        // If we have constructor params with type info, use them
        if (constructorParams.isNotEmpty()) {
            return constructorParams
                .filter { param ->
                    // Include params that are:
                    // 1. In the route pattern (path params - always required)
                    // 2. @Argument with nullable type (can receive null from missing query params)
                    // Skip: non-nullable params with defaults but not in route
                    val isInRoute = routeParams.contains(param.name) ||
                        routeParams.contains(param.argumentKey.ifEmpty { param.name })

                    when {
                        isInRoute -> true // Path params are always included
                        !param.isArgument -> false // Not an argument, skip
                        param.type.isMarkedNullable -> true // Nullable type can receive null
                        !param.hasDefault -> true // Required param, must include
                        else -> false // Non-nullable with default, skip to use default
                    }
                }
                .joinToString(",\n        ") { param ->
                    buildParamAssignment(param, routeParams)
                }
        }

        // Fallback to route params only (legacy behavior)
        return routeParams.joinToString(",\n        ") { paramName ->
            "$paramName = params[\"$paramName\"]!!"
        }
    }

    /**
     * Build a single parameter assignment with proper type conversion.
     *
     * @param param The parameter info with type and @Argument metadata
     * @param routeParams Set of parameter names from the route pattern
     * @return Assignment string like "id = params[\"id\"]!!.toInt()"
     */
    private fun buildParamAssignment(param: ParamInfo, routeParams: Set<String>): String {
        val paramName = param.name
        val key = param.argumentKey.ifEmpty { paramName }
        val isInRoute = routeParams.contains(paramName) || routeParams.contains(key)
        val isOptional = param.isOptionalArgument || param.hasDefault
        val isNullableType = param.type.isMarkedNullable

        val access = buildParamAccess(key, isOptional, isInRoute)
        val conversion = buildTypeConversion(param.serializerType, isOptional, isNullableType, param.type)

        return "$paramName = $access$conversion"
    }

    /**
     * Build the parameter access expression.
     *
     * @param key The parameter key in the params map
     * @param isOptional Whether the parameter is optional
     * @param isInRoute Whether the parameter is part of the route pattern (path param)
     * @return Access expression like "params[\"key\"]!!" or "params[\"key\"]"
     */
    private fun buildParamAccess(key: String, isOptional: Boolean, isInRoute: Boolean): String {
        return if (isOptional && !isInRoute) {
            // Optional query params use null-safe access
            "params[\"$key\"]"
        } else {
            // Required params (path params) use force unwrap
            "params[\"$key\"]!!"
        }
    }

    /**
     * Build the type conversion expression based on SerializerType.
     *
     * For optional params with non-nullable types that have defaults, the generated
     * code will use `?.toXxxOrNull()` which returns `T?`. The Kotlin compiler will
     * use the default value when the expression is null.
     *
     * For optional params with nullable types, we use `?.toXxxOrNull()` directly.
     *
     * For required params, we use `.toXxx()` which throws on invalid input.
     *
     * @param serializerType The serializer type from @Argument
     * @param isOptional Whether the parameter is optional (has @Argument(optional=true) or has default)
     * @param isNullableType Whether the parameter type is nullable (e.g., Int? vs Int)
     * @param type The KSP type for enum type name extraction
     * @return Conversion expression like ".toInt()" or "?.toIntOrNull()"
     */
    @Suppress("CyclomaticComplexMethod")
    private fun buildTypeConversion(
        serializerType: SerializerType,
        isOptional: Boolean,
        isNullableType: Boolean,
        type: KSType
    ): String {
        // For optional params, use safe conversion that can return null
        // The default value will be used by Kotlin when the result is null
        val useNullSafeConversion = isOptional

        return when (serializerType) {
            SerializerType.STRING -> ""
            SerializerType.INT -> if (useNullSafeConversion) "?.toIntOrNull()" else ".toInt()"
            SerializerType.LONG -> if (useNullSafeConversion) "?.toLongOrNull()" else ".toLong()"
            SerializerType.FLOAT -> if (useNullSafeConversion) "?.toFloatOrNull()" else ".toFloat()"
            SerializerType.DOUBLE -> if (useNullSafeConversion) "?.toDoubleOrNull()" else ".toDouble()"
            SerializerType.BOOLEAN -> if (useNullSafeConversion) "?.toBooleanStrictOrNull()" else ".toBoolean()"
            SerializerType.ENUM -> buildEnumConversion(type, useNullSafeConversion)
            SerializerType.JSON -> {
                logger.warn("JSON serialization type not fully supported in deep links, falling back to String")
                ""
            }
        }
    }

    /**
     * Build enum type conversion expression.
     */
    private fun buildEnumConversion(type: KSType, isOptional: Boolean): String {
        val enumClassName = type.declaration.qualifiedName?.asString() ?: "kotlin.Enum"
        return if (isOptional) {
            "?.let { enumValueOf<$enumClassName>(it) }"
        } else {
            ".let { enumValueOf<$enumClassName>(it) }"
        }
    }

    /**
     * Build the KotlinPoet ClassName for a destination.
     *
     * For nested sealed class members (e.g., HomeDestination.Detail),
     * creates a properly nested ClassName that KotlinPoet can import.
     * Handles arbitrary nesting depth (e.g., MainTabs.SettingsTab.SettingsMain).
     *
     * @param dest The destination info containing class metadata
     * @return ClassName that will generate proper imports when used with %T
     */
    private fun buildDestinationClassName(dest: DestinationInfo): ClassName {
        val packageName = dest.classDeclaration.packageName.asString()
        val simpleNames = mutableListOf<String>()

        // Walk up the parent chain to collect all enclosing class names
        var current: KSDeclaration? = dest.classDeclaration
        while (current is com.google.devtools.ksp.symbol.KSClassDeclaration) {
            simpleNames.add(0, current.simpleName.asString())
            current = current.parentDeclaration
        }

        return ClassName(packageName, simpleNames)
    }

    /**
     * Build the handleDeepLink function implementation.
     * 
     * This is a convenience method (not part of DeepLinkRegistry interface)
     * that uses resolve(uri) to find a matching destination and returns
     * a DeepLinkResult for pattern matching.
     */
    private fun buildHandleDeepLinkFunction(): FunSpec {
        return FunSpec.builder("handleDeepLink")
            .addParameter("uri", STRING)
            .returns(QuoVadisClassNames.DEEP_LINK_RESULT)
            .addCode(
                """
                |val destination = resolve(uri)
                |return if (destination != null) {
                |    %T(destination)
                |} else {
                |    %T
                |}
                """.trimMargin(),
                QuoVadisClassNames.DEEP_LINK_RESULT_MATCHED,
                QuoVadisClassNames.DEEP_LINK_RESULT_NOT_MATCHED
            )
            .build()
    }

    /**
     * Build the createUri function implementation (DeepLinkRegistry interface method).
     *
     * Uses CodeBlock-based when cases to ensure proper destination class imports.
     * Note: Override functions cannot have default parameter values, so scheme
     * has no default here (defaults should be in the interface/base class).
     */
    private fun buildCreateUriFunction(destinations: List<DestinationInfo>): FunSpec {
        val whenCases = buildWhenCases(destinations)

        return FunSpec.builder("createUri")
            .addModifiers(KModifier.OVERRIDE)
            .addParameter("destination", QuoVadisClassNames.NAV_DESTINATION)
            .addParameter("scheme", STRING)
            .returns(STRING.copy(nullable = true))
            .beginControlFlow("return when (destination)")
            .apply {
                whenCases.forEach { caseBlock ->
                    addCode(caseBlock)
                    addCode("\n")
                }
            }
            .addStatement("else -> null")
            .endControlFlow()
            .build()
    }

    /**
     * Build when case CodeBlocks for createDeepLinkUri.
     *
     * Returns CodeBlocks with %T format specifiers to ensure proper imports.
     * Handles three cases:
     * - Objects (data object, companion object, regular object): `DestinationClass.Object -> "scheme://route"`
     * - Data classes without route params: `is DestinationClass.DataClass -> "scheme://route"`
     * - Data classes with route params: `is DestinationClass.DataClass -> "scheme://route/${destination.param}"`
     * - Sealed classes: Skipped (cannot be used as concrete destinations)
     */
    private fun buildWhenCases(destinations: List<DestinationInfo>): List<CodeBlock> {
        return destinations.mapNotNull { dest ->
            val route = dest.route ?: return@mapNotNull null

            // Skip sealed classes - they cannot be used as concrete destinations
            if (dest.isSealedClass) return@mapNotNull null

            val destClassName = buildDestinationClassName(dest)
            val params = dest.routeParams

            // All cases use %P (string template) to properly interpolate $scheme at runtime.
            // %S would escape the $ making it a literal string instead of interpolated.
            when {
                dest.isObject -> {
                    // Any object (data object, companion object, regular object) - exact match, use %T for auto-import
                    CodeBlock.of("%T -> %P", destClassName, "\$scheme://$route")
                }
                params.isEmpty() -> {
                    // Data class without route params - use "is" check
                    CodeBlock.of("is %T -> %P", destClassName, "\$scheme://$route")
                }
                else -> {
                    // Data class with route params - interpolate parameters
                    val uriPath = buildUriPathWithParams(route, params)
                    CodeBlock.of("is %T -> %P", destClassName, "\$scheme://$uriPath")
                }
            }
        }
    }

    /**
     * Build URI path with interpolated parameter references.
     *
     * Transforms "home/detail/{id}" to "home/detail/\${destination.id}"
     */
    private fun buildUriPathWithParams(route: String, params: List<String>): String {
        var result = route
        for (param in params) {
            result = result.replace("{$param}", "\${destination.$param}")
        }
        return result
    }

    /**
     * Build the extractPath helper function.
     */
    private fun buildExtractPathFunction(): FunSpec {
        return FunSpec.builder("extractPath")
            .addModifiers(KModifier.PRIVATE)
            .addParameter("uri", STRING)
            .returns(STRING)
            .addKdoc(
                """
                |Extract the path component from a URI.
                |
                |Removes the scheme (e.g., "myapp://") and any leading slashes.
                |
                |@param uri The full URI string
                |@return The path component without scheme or leading slashes
                """.trimMargin()
            )
            .addCode(
                """
                |// Remove scheme (e.g., "myapp://") and leading slashes
                |val schemeEnd = uri.indexOf("://")
                |return if (schemeEnd >= 0) {
                |    uri.substring(schemeEnd + 3).trimStart('/')
                |} else {
                |    uri.trimStart('/')
                |}
                """.trimMargin()
            )
            .build()
    }

    /**
     * Build the resolve(uri: String) function from DeepLinkRegistry interface.
     * 
     * Parses the URI and delegates to resolve(deepLink).
     */
    private fun buildResolveUriFunction(): FunSpec {
        return FunSpec.builder("resolve")
            .addModifiers(KModifier.OVERRIDE)
            .addParameter("uri", STRING)
            .returns(QuoVadisClassNames.NAV_DESTINATION.copy(nullable = true))
            .addCode(
                """
                |val deepLink = %T.parse(uri)
                |return resolve(deepLink)
                """.trimMargin(),
                QuoVadisClassNames.DEEP_LINK
            )
            .build()
    }

    /**
     * Build the resolve(deepLink: DeepLink) function from DeepLinkRegistry interface.
     * 
     * Uses the KSP-generated route patterns to resolve deep links.
     * Merges query params with path params (path params take precedence).
     */
    private fun buildResolveDeepLinkFunction(): FunSpec {
        return FunSpec.builder("resolve")
            .addModifiers(KModifier.OVERRIDE)
            .addParameter("deepLink", QuoVadisClassNames.DEEP_LINK)
            .returns(QuoVadisClassNames.NAV_DESTINATION.copy(nullable = true))
            .addCode(
                """
                |val path = deepLink.path
                |for (route in routes) {
                |    val pathParams = route.match(path)
                |    if (pathParams != null) {
                |        // Merge query params with path params (path params take precedence)
                |        val allParams = deepLink.queryParams + pathParams
                |        return route.createDestination(allParams)
                |    }
                |}
                |return null
                """.trimMargin()
            )
            .build()
    }

    /**
     * Build the register(pattern, factory) function from DeepLinkRegistry interface.
     * 
     * This is a no-op for generated handlers since routes are determined at compile time.
     */
    private fun buildSimpleRegisterFunction(): FunSpec {
        val factoryType = LambdaTypeName.get(
            parameters = listOf(
                ParameterSpec.builder("params", MAP.parameterizedBy(STRING, STRING)).build()
            ),
            returnType = QuoVadisClassNames.NAV_DESTINATION
        )
        
        return FunSpec.builder("register")
            .addModifiers(KModifier.OVERRIDE)
            .addParameter("pattern", STRING)
            .addParameter("factory", factoryType)
            .addComment("No-op: Generated handler uses compile-time routes from @Destination annotations")
            .addComment("Use RuntimeDeepLinkRegistry for runtime registration")
            .build()
    }

    /**
     * Build the registerAction(pattern, action) function from DeepLinkRegistry interface.
     * 
     * This is a no-op for generated handlers since routes are determined at compile time.
     */
    private fun buildRegisterActionFunction(): FunSpec {
        val actionType = LambdaTypeName.get(
            parameters = listOf(
                ParameterSpec.builder("navigator", QuoVadisClassNames.NAVIGATOR).build(),
                ParameterSpec.builder("params", MAP.parameterizedBy(STRING, STRING)).build()
            ),
            returnType = ClassName("kotlin", "Unit")
        )
        
        return FunSpec.builder("registerAction")
            .addModifiers(KModifier.OVERRIDE)
            .addParameter("pattern", STRING)
            .addParameter("action", actionType)
            .addComment("No-op: Generated handler uses compile-time routes from @Destination annotations")
            .addComment("Use RuntimeDeepLinkRegistry for runtime registration")
            .build()
    }

    /**
     * Build the handle function from DeepLinkRegistry interface.
     * 
     * Resolves the URI and navigates if a destination is found.
     */
    private fun buildHandleFunction(): FunSpec {
        return FunSpec.builder("handle")
            .addModifiers(KModifier.OVERRIDE)
            .addParameter("uri", STRING)
            .addParameter("navigator", QuoVadisClassNames.NAVIGATOR)
            .returns(ClassName("kotlin", "Boolean"))
            .addCode(
                """
                |val destination = resolve(uri)
                |if (destination != null) {
                |    navigator.navigate(destination)
                |    return true
                |}
                |return false
                """.trimMargin()
            )
            .build()
    }

    /**
     * Build the canHandle function from DeepLinkRegistry interface.
     * 
     * Checks if the URI matches any registered pattern.
     */
    private fun buildCanHandleFunction(): FunSpec {
        return FunSpec.builder("canHandle")
            .addModifiers(KModifier.OVERRIDE)
            .addParameter("uri", STRING)
            .returns(ClassName("kotlin", "Boolean"))
            .addCode(
                """
                |val path = %T.parse(uri).path
                |return routes.any { it.match(path) != null }
                """.trimMargin(),
                QuoVadisClassNames.DEEP_LINK
            )
            .build()
    }

    /**
     * Build the getRegisteredPatterns function from DeepLinkRegistry interface.
     * 
     * Returns all pattern strings from the generated routes.
     */
    private fun buildGetRegisteredPatternsFunction(): FunSpec {
        return FunSpec.builder("getRegisteredPatterns")
            .addModifiers(KModifier.OVERRIDE)
            .returns(LIST.parameterizedBy(STRING))
            .addStatement("return patternStrings")
            .build()
    }

    /**
     * Build the RoutePattern private data class.
     */
    private fun buildRoutePatternClass(): TypeSpec {
        val destinationLambdaType = LambdaTypeName.get(
            parameters = listOf(
                ParameterSpec.unnamed(MAP.parameterizedBy(STRING, STRING))
            ),
            returnType = QuoVadisClassNames.NAV_DESTINATION
        )

        return TypeSpec.classBuilder(routePatternClassName)
            .addModifiers(KModifier.PRIVATE, KModifier.DATA)
            .addKdoc(
                """
                |Route pattern for matching deep link URIs.
                |
                |@property pattern The route pattern string (e.g., "home/detail/{id}")
                |@property paramNames List of parameter names extracted from the pattern
                |@property createDestination Lambda to create a destination from extracted parameters
                """.trimMargin()
            )
            .primaryConstructor(
                FunSpec.constructorBuilder()
                    .addParameter("pattern", STRING)
                    .addParameter(
                        ParameterSpec.builder(
                            "paramNames",
                            ClassName("kotlin.collections", "List").parameterizedBy(STRING)
                        ).build()
                    )
                    .addParameter(
                        ParameterSpec.builder("createDestination", destinationLambdaType).build()
                    )
                    .build()
            )
            .addProperty(
                PropertySpec.builder("pattern", STRING)
                    .initializer("pattern")
                    .build()
            )
            .addProperty(
                PropertySpec.builder(
                    "paramNames",
                    ClassName("kotlin.collections", "List").parameterizedBy(STRING)
                )
                    .initializer("paramNames")
                    .build()
            )
            .addProperty(
                PropertySpec.builder("createDestination", destinationLambdaType)
                    .initializer("createDestination")
                    .build()
            )
            .addProperty(
                PropertySpec.builder("regex", ClassName("kotlin.text", "Regex"))
                    .addModifiers(KModifier.PRIVATE)
                    .initializer("buildRegex()")
                    .build()
            )
            .addFunction(buildBuildRegexFunction())
            .addFunction(buildMatchFunction())
            .build()
    }

    /**
     * Build the buildRegex helper function for RoutePattern.
     */
    private fun buildBuildRegexFunction(): FunSpec {
        return FunSpec.builder("buildRegex")
            .addModifiers(KModifier.PRIVATE)
            .returns(ClassName("kotlin.text", "Regex"))
            .addCode(
                """
                |var regexPattern = %T.escape(pattern)
                |for (param in paramNames) {
                |    regexPattern = regexPattern.replace("\\{${'$'}param\\}", "([^/]+)")
                |}
                |return %T("^${'$'}regexPattern${'$'}")
                """.trimMargin(),
                ClassName("kotlin.text", "Regex"),
                ClassName("kotlin.text", "Regex")
            )
            .build()
    }

    /**
     * Build the match function for RoutePattern.
     */
    private fun buildMatchFunction(): FunSpec {
        return FunSpec.builder("match")
            .addParameter("path", STRING)
            .returns(MAP.parameterizedBy(STRING, STRING).copy(nullable = true))
            .addKdoc(
                """
                |Match a path against this pattern and extract parameters.
                |
                |@param path The path to match (without scheme)
                |@return Map of parameter names to values, or null if no match
                """.trimMargin()
            )
            .addCode(
                """
                |val matchResult = regex.matchEntire(path) ?: return null
                |return paramNames.zip(matchResult.groupValues.drop(1)).toMap()
                """.trimMargin()
            )
            .build()
    }
}
