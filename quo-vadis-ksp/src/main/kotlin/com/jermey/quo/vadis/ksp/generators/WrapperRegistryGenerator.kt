package com.jermey.quo.vadis.ksp.generators

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.jermey.quo.vadis.ksp.QuoVadisClassNames
import com.jermey.quo.vadis.ksp.generators.base.StringTemplates
import com.jermey.quo.vadis.ksp.models.WrapperInfo
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.LambdaTypeName
import com.squareup.kotlinpoet.MemberName
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.SET
import com.squareup.kotlinpoet.STRING
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.UNIT
import com.squareup.kotlinpoet.ksp.writeTo

/**
 * Generates the wrapper registry mapping tab/pane nodes to composable wrappers.
 *
 * Consumes [WrapperInfo] models and produces a single `GeneratedWrapperRegistry.kt`
 * file containing:
 * - `object GeneratedWrapperRegistry : WrapperRegistry`
 * - `TabWrapper()` composable with `when` expression dispatching to @TabWrapper functions
 * - `PaneWrapper()` composable with `when` expression dispatching to @PaneWrapper functions
 * - `hasTabWrapper()` method for checking tab wrapper availability
 * - `hasPaneWrapper()` method for checking pane wrapper availability
 *
 * ## Generated Code Pattern
 *
 * ```kotlin
 * public object GeneratedWrapperRegistry : WrapperRegistry {
 *
 *     private val tabWrapperKeys = setOf("MyTabsDestination", "OtherTabs")
 *     private val paneWrapperKeys = setOf("MyPaneDestination")
 *
 *     @Composable
 *     override fun TabWrapper(
 *         tabNodeKey: String,
 *         scope: TabWrapperScope,
 *         content: @Composable () -> Unit
 *     ) {
 *         when (tabNodeKey) {
 *             "MyTabsDestination" -> com.example.MyTabWrapper(scope, content)
 *             "OtherTabs" -> com.example.OtherTabWrapper(scope, content)
 *             else -> content() // Default: render content directly
 *         }
 *     }
 *     // ... similar for PaneWrapper
 * }
 * ```
 *
 * @property codeGenerator KSP code generator for writing output files
 * @property logger KSP logger for diagnostic output
 */
public class WrapperRegistryGenerator(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) {

    private companion object {
        private const val GENERATED_PACKAGE = "com.jermey.quo.vadis.generated"
        private const val REGISTRY_NAME = "GeneratedWrapperRegistry"

        // Compose type references
        private val COMPOSABLE = ClassName("androidx.compose.runtime", "Composable")
    }

    /**
     * Generate the wrapper registry from extracted wrapper information.
     *
     * @param tabWrappers List of WrapperInfo models for @TabWrapper annotations
     * @param paneWrappers List of WrapperInfo models for @PaneWrapper annotations
     * @param basePackage Base package for the generated code (unused, kept for API consistency)
     * @param addDeprecations When true, adds @Deprecated annotations to generated code
     *        pointing users to use GeneratedNavigationConfig instead
     */
    public fun generate(
        tabWrappers: List<WrapperInfo>,
        paneWrappers: List<WrapperInfo>,
        @Suppress("UNUSED_PARAMETER") basePackage: String = GENERATED_PACKAGE,
        addDeprecations: Boolean = false
    ) {
        if (tabWrappers.isEmpty() && paneWrappers.isEmpty()) {
            logger.warn("No @TabWrapper or @PaneWrapper annotations found, skipping registry generation")
            return
        }

        val fileSpec = buildFileSpec(tabWrappers, paneWrappers, addDeprecations)

        // Collect all source files for dependency tracking
        val allWrappers = tabWrappers + paneWrappers
        val sourceFiles = allWrappers.mapNotNull { it.functionDeclaration.containingFile }

        val dependencies = Dependencies(
            aggregating = true,
            sources = sourceFiles.toTypedArray()
        )

        fileSpec.writeTo(codeGenerator, dependencies)

        logger.info(
            "Generated $REGISTRY_NAME with ${tabWrappers.size} tab wrappers and ${paneWrappers.size} pane wrappers"
        )
    }

    private fun buildFileSpec(
        tabWrappers: List<WrapperInfo>,
        paneWrappers: List<WrapperInfo>,
        addDeprecations: Boolean
    ): FileSpec {
        return FileSpec.builder(GENERATED_PACKAGE, REGISTRY_NAME)
            .addFileComment("DO NOT EDIT - Auto-generated by Quo Vadis KSP processor")
            .addType(buildRegistryObject(tabWrappers, paneWrappers, addDeprecations))
            .build()
    }

    private fun buildRegistryObject(
        tabWrappers: List<WrapperInfo>,
        paneWrappers: List<WrapperInfo>,
        addDeprecations: Boolean
    ): TypeSpec {
        return TypeSpec.objectBuilder(REGISTRY_NAME)
            .addKdoc(
                """
                |KSP-generated wrapper registry mapping tab/pane nodes to composable wrappers.
                |
                |Generated from @TabWrapper and @PaneWrapper annotations found in the codebase.
                |DO NOT EDIT - This file is auto-generated by Quo Vadis KSP processor.
                """.trimMargin()
            )
            .apply {
                if (addDeprecations) {
                    addAnnotation(buildDeprecationAnnotation())
                }
            }
            .addSuperinterface(QuoVadisClassNames.WRAPPER_REGISTRY)
            .addProperty(buildTabWrapperKeysProperty(tabWrappers))
            .addProperty(buildPaneWrapperKeysProperty(paneWrappers))
            .addFunction(buildTabWrapperFunction(tabWrappers))
            .addFunction(buildPaneWrapperFunction(paneWrappers))
            .addFunction(buildHasTabWrapperFunction())
            .addFunction(buildHasPaneWrapperFunction())
            .build()
    }

    /**
     * Builds the @Deprecated annotation for legacy registry objects.
     */
    private fun buildDeprecationAnnotation(): AnnotationSpec {
        return AnnotationSpec.builder(Deprecated::class)
            .addMember("message = %S", StringTemplates.deprecatedRegistryMessage(REGISTRY_NAME))
            .addMember(
                "replaceWith = %T(%S, %S)",
                ReplaceWith::class,
                "GeneratedNavigationConfig",
                "$GENERATED_PACKAGE.GeneratedNavigationConfig"
            )
            .addMember("level = %T.%L", DeprecationLevel::class, "WARNING")
            .build()
    }

    private fun buildTabWrapperKeysProperty(tabWrappers: List<WrapperInfo>): PropertySpec {
        val keys = tabWrappers.map { it.targetClassSimpleName }
        return buildKeysProperty("tabWrapperKeys", keys)
    }

    private fun buildPaneWrapperKeysProperty(paneWrappers: List<WrapperInfo>): PropertySpec {
        val keys = paneWrappers.map { it.targetClassSimpleName }
        return buildKeysProperty("paneWrapperKeys", keys)
    }

    private fun buildKeysProperty(name: String, keys: List<String>): PropertySpec {
        val setType = SET.parameterizedBy(STRING)
        val initializer = if (keys.isEmpty()) {
            CodeBlock.of("emptySet()")
        } else {
            CodeBlock.of(
                "setOf(%L)",
                keys.joinToString(", ") { "\"$it\"" }
            )
        }

        return PropertySpec.builder(name, setType)
            .addModifiers(KModifier.PRIVATE)
            .initializer(initializer)
            .build()
    }

    private fun buildTabWrapperFunction(tabWrappers: List<WrapperInfo>): FunSpec {
        val contentLambdaType = LambdaTypeName.get(
            returnType = UNIT
        ).copy(annotations = listOf(
            com.squareup.kotlinpoet.AnnotationSpec.builder(COMPOSABLE).build()
        ))

        return FunSpec.builder("TabWrapper")
            .addAnnotation(COMPOSABLE)
            .addModifiers(KModifier.OVERRIDE)
            .addParameter("tabNodeKey", STRING)
            .addParameter("scope", QuoVadisClassNames.TAB_WRAPPER_SCOPE)
            .addParameter(
                ParameterSpec.builder("content", contentLambdaType).build()
            )
            .apply {
                if (tabWrappers.isEmpty()) {
                    // No wrappers registered, just render content directly
                    addStatement("content()")
                } else {
                    beginControlFlow("when (tabNodeKey)")
                    tabWrappers.forEach { wrapper ->
                        addStatement(
                            "%S -> %M(scope, content)",
                            wrapper.targetClassSimpleName,
                            MemberName(wrapper.packageName, wrapper.functionName)
                        )
                    }
                    addStatement("else -> content() // Default: render content directly")
                    endControlFlow()
                }
            }
            .build()
    }

    private fun buildPaneWrapperFunction(paneWrappers: List<WrapperInfo>): FunSpec {
        val contentLambdaType = LambdaTypeName.get(
            returnType = UNIT
        ).copy(annotations = listOf(
            com.squareup.kotlinpoet.AnnotationSpec.builder(COMPOSABLE).build()
        ))

        return FunSpec.builder("PaneWrapper")
            .addAnnotation(COMPOSABLE)
            .addModifiers(KModifier.OVERRIDE)
            .addParameter("paneNodeKey", STRING)
            .addParameter("scope", QuoVadisClassNames.PANE_WRAPPER_SCOPE)
            .addParameter(
                ParameterSpec.builder("content", contentLambdaType).build()
            )
            .apply {
                if (paneWrappers.isEmpty()) {
                    // No wrappers registered, just render content directly
                    addStatement("content()")
                } else {
                    beginControlFlow("when (paneNodeKey)")
                    paneWrappers.forEach { wrapper ->
                        addStatement(
                            "%S -> %M(scope, content)",
                            wrapper.targetClassSimpleName,
                            MemberName(wrapper.packageName, wrapper.functionName)
                        )
                    }
                    addStatement("else -> content() // Default: render content directly")
                    endControlFlow()
                }
            }
            .build()
    }

    private fun buildHasTabWrapperFunction(): FunSpec {
        return FunSpec.builder("hasTabWrapper")
            .addModifiers(KModifier.OVERRIDE)
            .addParameter("tabNodeKey", STRING)
            .returns(Boolean::class)
            .addStatement("return tabNodeKey in tabWrapperKeys")
            .build()
    }

    private fun buildHasPaneWrapperFunction(): FunSpec {
        return FunSpec.builder("hasPaneWrapper")
            .addModifiers(KModifier.OVERRIDE)
            .addParameter("paneNodeKey", STRING)
            .returns(Boolean::class)
            .addStatement("return paneNodeKey in paneWrapperKeys")
            .build()
    }
}
