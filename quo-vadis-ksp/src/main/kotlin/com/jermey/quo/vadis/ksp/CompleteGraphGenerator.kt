package com.jermey.quo.vadis.ksp

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import java.io.OutputStreamWriter

/**
 * Generates complete graph builder functions that wire @Content functions to destinations.
 * 
 * This replaces manual graph building with fully generated DSL.
 */
object CompleteGraphGenerator {
    
    fun generate(
        graphInfo: GraphInfo,
        contentMappings: Map<String, ContentFunctionInfo>,
        codeGenerator: CodeGenerator,
        logger: KSPLogger
    ) {
        val fileName = "${graphInfo.className}Graph"
        val packageName = graphInfo.packageName
        
        logger.info("Generating complete graph DSL: $fileName")
        
        val file = codeGenerator.createNewFile(
            dependencies = Dependencies(false),
            packageName = packageName,
            fileName = fileName
        )
        
        OutputStreamWriter(file).use { writer ->
            writer.write(generateGraphBuilder(graphInfo, contentMappings))
        }
    }
    
    private fun generateGraphBuilder(
        graphInfo: GraphInfo,
        contentMappings: Map<String, ContentFunctionInfo>
    ): String {
        val className = graphInfo.className
        val graphName = graphInfo.graphName
        
        // Find first object (non-data-class) destination for start destination
        val startDestination = graphInfo.destinations
            .firstOrNull { it.isObject }?.name 
            ?: graphInfo.destinations.firstOrNull()?.name 
            ?: "Unknown"
        
        return buildString {
            appendLine("// Generated by Quo Vadis KSP. Do not edit manually.")
            appendLine("package ${graphInfo.packageName}")
            appendLine()
            appendLine("import androidx.compose.animation.ExperimentalSharedTransitionApi")
            appendLine("import androidx.compose.runtime.Composable")
            appendLine("import com.jermey.quo.vadis.core.navigation.core.*")
            appendLine("import com.jermey.quo.vadis.core.navigation.compose.TransitionScope")
            appendLine()
            
            // Import content functions
            contentMappings.values
                .filter { mapping -> 
                    graphInfo.destinations.any { 
                        "${graphInfo.packageName}.${className}.${it.name}" == mapping.destinationClass 
                    }
                }
                .distinctBy { it.packageName }
                .forEach { mapping ->
                    if (mapping.packageName != graphInfo.packageName) {
                        appendLine("import ${mapping.packageName}.*")
                    }
                }
            appendLine()
            
            // Generate main graph builder function
            appendLine("/**")
            appendLine(" * Auto-generated navigation graph for $className.")
            appendLine(" * ")
            appendLine(" * Wires @Content annotated functions to their destinations.")
            appendLine(" * All routing and type-safe argument passing is handled automatically.")
            appendLine(" */")
            appendLine("fun build${className}Graph(): NavigationGraph {")
            appendLine("    return navigationGraph(\"$graphName\") {")
            appendLine("        startDestination($className.$startDestination)")
            appendLine()
            
            // Generate destination registrations
            graphInfo.destinations.forEach { dest ->
                val fullDestName = "${graphInfo.packageName}.${className}.${dest.name}"
                val contentInfo = contentMappings[fullDestName]
                
                if (contentInfo != null) {
                    generateDestinationWithContent(this, graphInfo, dest, contentInfo)
                } else {
                    // Generate placeholder for destinations without @Content
                    appendLine("        // TODO: Add @Content annotation for ${dest.name}")
                    appendLine("        // destination($className.${dest.name}) { _, navigator ->")
                    appendLine("        //     TODO(\"Implement ${dest.name} content\")")
                    appendLine("        // }")
                    appendLine()
                }
            }
            
            appendLine("    }")
            appendLine("}")
        }
    }
    
    private fun generateDestinationWithContent(
        builder: StringBuilder,
        graphInfo: GraphInfo,
        dest: DestinationInfo,
        contentInfo: ContentFunctionInfo
    ) {
        val className = graphInfo.className
        val destName = dest.name
        val contentFuncName = contentInfo.functionName
        
        if (dest.argumentType != null) {
            // Typed destination with argument - use the helper function from Registry
            builder.appendLine("        // Typed destination: $destName")
            builder.appendLine("        @OptIn(ExperimentalSharedTransitionApi::class)")
            builder.appendLine("        typedDestination${destName}WithScopes(")
            builder.appendLine("            destination = $className.$destName::class")
            builder.appendLine("        ) { data, navigator, transitionScope ->")
            builder.appendLine("            $contentFuncName(data, navigator)")
            builder.appendLine("        }")
        } else {
            // Simple destination without argument
            builder.appendLine("        // Simple destination: $destName")
            builder.appendLine("        destination($className.$destName) { _, navigator ->")
            builder.appendLine("            $contentFuncName(navigator)")
            builder.appendLine("        }")
        }
        builder.appendLine()
    }
}
