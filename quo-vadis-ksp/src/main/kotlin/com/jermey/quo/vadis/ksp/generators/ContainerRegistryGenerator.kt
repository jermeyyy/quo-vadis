package com.jermey.quo.vadis.ksp.generators

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.symbol.KSDeclaration
import com.jermey.quo.vadis.ksp.QuoVadisClassNames
import com.jermey.quo.vadis.ksp.generators.base.StringTemplates
import com.jermey.quo.vadis.ksp.models.PaneInfo
import com.jermey.quo.vadis.ksp.models.TabInfo
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.ksp.writeTo

/**
 * Generates a ContainerRegistry implementation from @Tab and @Pane annotations.
 *
 * The generated registry maps destinations belonging to tab or pane containers
 * to their container builders and initial state. This enables automatic container
 * creation when navigating to destinations that require a container structure.
 *
 * ## Generated Code Example
 *
 * ```kotlin
 * public object GeneratedContainerRegistry : ContainerRegistry {
 *     override fun getContainerInfo(destination: Destination): ContainerInfo? {
 *         return when (destination) {
 *             // DemoTabs destinations
 *             is DemoTabs.MusicTab -> ContainerInfo.TabContainer(
 *                 builder = ::buildDemoTabsNavNode,
 *                 initialTabIndex = 0,
 *                 scopeKey = "DemoTabs"
 *             )
 *             is DemoTabs.MoviesTab -> ContainerInfo.TabContainer(
 *                 builder = ::buildDemoTabsNavNode,
 *                 initialTabIndex = 1,
 *                 scopeKey = "DemoTabs"
 *             )
 *             // Pane destinations
 *             is MasterDetail.ListPane -> ContainerInfo.PaneContainer(
 *                 builder = ::buildMasterDetailNavNode,
 *                 initialPane = PaneRole.PRIMARY,
 *                 scopeKey = "MasterDetail"
 *             )
 *             else -> null
 *         }
 *     }
 * }
 * ```
 *
 * @property codeGenerator KSP code generator for writing output files
 * @property logger KSP logger for diagnostic output
 */
public class ContainerRegistryGenerator(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) {
    private companion object {
        private const val GENERATED_PACKAGE = "com.jermey.quo.vadis.generated"
        private const val GENERATED_FILE_NAME = "GeneratedContainerRegistry"
        private const val GENERATED_CLASS_NAME = "GeneratedContainerRegistry"
    }

    /**
     * Generate the ContainerRegistry implementation.
     *
     * @param tabInfos List of all TabInfo extracted from @Tab annotations
     * @param paneInfos List of all PaneInfo extracted from @Pane annotations
     * @param addDeprecations When true, adds @Deprecated annotations to generated code
     *        pointing users to use GeneratedNavigationConfig instead
     */
    public fun generate(
        tabInfos: List<TabInfo>,
        paneInfos: List<PaneInfo>,
        addDeprecations: Boolean = false
    ) {
        // Only generate if there are tabs or panes
        if (tabInfos.isEmpty() && paneInfos.isEmpty()) {
            logger.info("No @Tab or @Pane annotations found, skipping ContainerRegistry generation")
            return
        }

        val fileSpec = buildFileSpec(tabInfos, paneInfos, addDeprecations)

        // Collect all source files for dependency tracking
        val sourceFiles = buildList {
            tabInfos.forEach { add(it.classDeclaration.containingFile) }
            paneInfos.forEach { add(it.classDeclaration.containingFile) }
        }.filterNotNull()

        val dependencies = Dependencies(
            aggregating = true,
            sources = sourceFiles.toTypedArray()
        )

        fileSpec.writeTo(codeGenerator, dependencies)
        logger.info(
            "Generated $GENERATED_FILE_NAME with " +
                "${tabInfos.size} tab containers and ${paneInfos.size} pane containers"
        )
    }

    private fun buildFileSpec(
        tabInfos: List<TabInfo>,
        paneInfos: List<PaneInfo>,
        addDeprecations: Boolean
    ): FileSpec {
        val fileSpecBuilder = FileSpec.builder(GENERATED_PACKAGE, GENERATED_FILE_NAME)
            .addFileComment("DO NOT EDIT - Auto-generated by Quo Vadis KSP processor")
        
        // Add imports for all builder functions
        tabInfos.forEach { tabInfo ->
            val builderFunctionName = "build${tabInfo.className}NavNode"
            val builderPackage = "${tabInfo.packageName}.generated"
            fileSpecBuilder.addImport(builderPackage, builderFunctionName)
        }
        paneInfos.forEach { paneInfo ->
            val builderFunctionName = "build${paneInfo.className}NavNode"
            val builderPackage = "${paneInfo.packageName}.generated"
            fileSpecBuilder.addImport(builderPackage, builderFunctionName)
        }
        
        return fileSpecBuilder
            .addType(buildContainerRegistryObject(tabInfos, paneInfos, addDeprecations))
            .build()
    }

    private fun buildContainerRegistryObject(
        tabInfos: List<TabInfo>,
        paneInfos: List<PaneInfo>,
        addDeprecations: Boolean
    ): TypeSpec {
        return TypeSpec.objectBuilder(GENERATED_CLASS_NAME)
            .addKdoc(
                """
                |KSP-generated ContainerRegistry implementation.
                |
                |Maps destinations to their container builders for container-aware navigation.
                |When navigating to a destination within a @Tab or @Pane container, this registry
                |provides the builder function and initial state needed to create the container.
                |
                |Generated from @Tab and @Pane annotations found in the codebase.
                |DO NOT EDIT - This file is auto-generated by Quo Vadis KSP processor.
                """.trimMargin()
            )
            .apply {
                if (addDeprecations) {
                    addAnnotation(buildDeprecationAnnotation())
                }
            }
            .addSuperinterface(QuoVadisClassNames.CONTAINER_REGISTRY)
            .addFunction(buildGetContainerInfoFunction(tabInfos, paneInfos))
            .build()
    }

    /**
     * Builds the @Deprecated annotation for legacy registry objects.
     */
    private fun buildDeprecationAnnotation(): AnnotationSpec {
        return AnnotationSpec.builder(Deprecated::class)
            .addMember("message = %S", StringTemplates.deprecatedRegistryMessage(GENERATED_CLASS_NAME))
            .addMember(
                "replaceWith = %T(%S, %S)",
                ReplaceWith::class,
                "GeneratedNavigationConfig",
                "$GENERATED_PACKAGE.GeneratedNavigationConfig"
            )
            .addMember("level = %T.%L", DeprecationLevel::class, "WARNING")
            .build()
    }

    private fun buildGetContainerInfoFunction(
        tabInfos: List<TabInfo>,
        paneInfos: List<PaneInfo>
    ): FunSpec {
        val codeBlock = CodeBlock.builder()
            .beginControlFlow("return when (destination)")

        // Add tab container mappings
        for (tabInfo in tabInfos) {
            addTabContainerMappings(codeBlock, tabInfo)
        }

        // Add pane container mappings
        for (paneInfo in paneInfos) {
            addPaneContainerMappings(codeBlock, paneInfo)
        }

        // Add else clause
        codeBlock.addStatement("else -> null")
        codeBlock.endControlFlow()

        return FunSpec.builder("getContainerInfo")
            .addModifiers(KModifier.OVERRIDE)
            .addParameter("destination", QuoVadisClassNames.DESTINATION)
            .returns(QuoVadisClassNames.CONTAINER_INFO.copy(nullable = true))
            .addCode(codeBlock.build())
            .build()
    }

    /**
     * Add when-expression branches for all destinations within a tab container.
     *
     * For each tab in the container, we generate a mapping that:
     * - Matches the tab item class (or its nested destinations for NESTED_STACK tabs)
     * - Returns ContainerInfo.TabContainer with:
     *   - builder: Reference to the generated build{ContainerName}NavNode function
     *   - initialTabIndex: The 0-based index of the tab within the container
     *   - scopeKey: The simple class name of the container
     */
    private fun addTabContainerMappings(
        codeBlock: CodeBlock.Builder,
        tabInfo: TabInfo
    ) {
        val scopeKey = tabInfo.className
        val builderFunctionName = "build${tabInfo.className}NavNode"

        tabInfo.tabs.forEachIndexed { index, tabItem ->
            val tabClassName = buildClassName(tabItem.classDeclaration)
            
            codeBlock.addStatement(
                "is %T -> %T(::$builderFunctionName, %L, %S)",
                tabClassName,
                QuoVadisClassNames.CONTAINER_INFO_TAB_CONTAINER,
                index,
                scopeKey
            )
        }
    }

    /**
     * Add when-expression branches for all destinations within a pane container.
     *
     * For each pane in the container, we generate a mapping that:
     * - Matches the pane destination class
     * - Returns ContainerInfo.PaneContainer with:
     *   - builder: Reference to the generated build{ContainerName}NavNode function
     *   - initialPane: The pane role (PRIMARY, SECONDARY, EXTRA)
     *   - scopeKey: The simple class name of the container
     */
    private fun addPaneContainerMappings(
        codeBlock: CodeBlock.Builder,
        paneInfo: PaneInfo
    ) {
        val scopeKey = paneInfo.className
        val builderFunctionName = "build${paneInfo.className}NavNode"

        for (paneItem in paneInfo.panes) {
            val paneClassName = buildClassName(paneItem.rootGraphClass)
            
            codeBlock.addStatement(
                "is %T -> %T(::$builderFunctionName, %T.%L, %S)",
                paneClassName,
                QuoVadisClassNames.CONTAINER_INFO_PANE_CONTAINER,
                QuoVadisClassNames.PANE_ROLE,
                paneItem.role.name,
                scopeKey
            )
        }
    }

    /**
     * Builds a ClassName for a KSClassDeclaration, handling nested classes.
     *
     * This method walks up the parent chain to collect all enclosing class names,
     * producing a properly nested ClassName like `MainTabs.HomeTab`.
     *
     * @param classDeclaration The KSP class declaration to convert
     * @return A KotlinPoet ClassName representing the class
     */
    private fun buildClassName(
        classDeclaration: com.google.devtools.ksp.symbol.KSClassDeclaration
    ): ClassName {
        val packageName = classDeclaration.packageName.asString()
        val simpleNames = mutableListOf<String>()

        // Walk up the parent chain to collect all enclosing class names
        var current: KSDeclaration? = classDeclaration
        while (current is com.google.devtools.ksp.symbol.KSClassDeclaration) {
            simpleNames.add(0, current.simpleName.asString())
            current = current.parentDeclaration
        }

        return ClassName(packageName, simpleNames)
    }
}
