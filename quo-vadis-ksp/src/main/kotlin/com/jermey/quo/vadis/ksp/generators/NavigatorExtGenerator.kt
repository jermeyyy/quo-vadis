package com.jermey.quo.vadis.ksp.generators

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.symbol.KSType
import com.jermey.quo.vadis.ksp.models.DestinationInfo
import com.jermey.quo.vadis.ksp.models.PaneInfo
import com.jermey.quo.vadis.ksp.models.PaneItemInfo
import com.jermey.quo.vadis.ksp.models.StackInfo
import com.jermey.quo.vadis.ksp.models.TabInfo
import com.jermey.quo.vadis.ksp.models.TabItemInfo
import com.squareup.kotlinpoet.ANY
import com.squareup.kotlinpoet.BOOLEAN
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.DOUBLE
import com.squareup.kotlinpoet.FLOAT
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.INT
import com.squareup.kotlinpoet.LONG
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.STRING
import com.squareup.kotlinpoet.TypeName
import com.squareup.kotlinpoet.ksp.writeTo

/**
 * Generates convenience extension functions for Navigator.
 *
 * This generator creates type-safe navigation helpers that provide
 * a more ergonomic API for common navigation actions.
 *
 * ## Generated Output
 *
 * Files are generated in a `generated` subpackage:
 * ```
 * {base.package}.generated/NavigatorExtensions.kt
 * ```
 *
 * ## Example Usage
 *
 * For a stack with `Detail(id: String)` destination:
 * ```kotlin
 * // Generated extension
 * fun Navigator.toDetail(id: String) = navigate(HomeDestination.Detail(id))
 *
 * // Usage
 * navigator.toDetail("item-123")
 * ```
 *
 * @property codeGenerator KSP code generator for writing output files
 * @property logger KSP logger for diagnostic output
 */
class NavigatorExtGenerator(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) {

    companion object {
        private const val GENERATED_PACKAGE_SUFFIX = "generated"
        private const val FILE_NAME = "NavigatorExtensions"
        private const val FILE_COMMENT = "Generated by Quo Vadis KSP - DO NOT EDIT"

        // Navigator type from quo-vadis-core
        private const val NAVIGATOR_PACKAGE = "com.jermey.quo.vadis.core.navigation.core"
        private val NAVIGATOR = ClassName(NAVIGATOR_PACKAGE, "Navigator")
    }

    /**
     * Generate all navigator extensions for the given stacks, tabs, and panes.
     *
     * Creates a single `NavigatorExtensions.kt` file containing:
     * - `to{Destination}()` extensions for stack navigation
     * - `switchTo{Tab}Tab()` extensions for tab switching
     * - `switchTo{Pane}Pane()` extensions for pane switching
     *
     * @param stacks List of stack container information
     * @param tabs List of tab container information
     * @param panes List of pane container information
     * @param basePackage Base package for the generated file
     */
    fun generate(
        stacks: List<StackInfo>,
        tabs: List<TabInfo>,
        panes: List<PaneInfo>,
        basePackage: String
    ) {
        if (stacks.isEmpty() && tabs.isEmpty() && panes.isEmpty()) {
            logger.info("No navigation containers found, skipping NavigatorExtensions generation")
            return
        }

        val packageName = "$basePackage.$GENERATED_PACKAGE_SUFFIX"

        logger.info("Generating NavigatorExtensions in $packageName")

        val fileSpec = FileSpec.builder(packageName, FILE_NAME)
            .addFileComment(FILE_COMMENT)
            .addFileComment("\nNavigator convenience extensions for type-safe navigation")
            .apply {
                // Add imports for all destination classes
                stacks.forEach { stack ->
                    addImport(stack.packageName, stack.className)
                }
                tabs.forEach { tab ->
                    addImport(tab.packageName, tab.className)
                }
                panes.forEach { pane ->
                    addImport(pane.packageName, pane.className)
                }
            }
            .apply {
                // Generate extensions for each stack
                stacks.forEach { stack ->
                    addStackExtensions(this, stack)
                }

                // Generate tab switching extensions
                tabs.forEach { tab ->
                    addTabSwitchingExtensions(this, tab)
                }

                // Generate pane switching extensions
                panes.forEach { pane ->
                    addPaneSwitchingExtensions(this, pane)
                }
            }
            .build()

        fileSpec.writeTo(codeGenerator, Dependencies(false))

        logger.info("Generated NavigatorExtensions with ${countExtensions(stacks, tabs, panes)} extensions")
    }

    // =========================================================================
    // Stack Destination Extensions
    // =========================================================================

    /**
     * Add navigation extensions for all destinations in a stack.
     *
     * Generates `to{Destination}()` functions that call `navigate()` on the Navigator.
     *
     * @param builder The FileSpec builder to add functions to
     * @param stack The stack container information
     */
    private fun addStackExtensions(builder: FileSpec.Builder, stack: StackInfo) {
        stack.destinations.forEach { destination ->
            builder.addFunction(buildDestinationExtension(stack, destination))
        }
    }

    /**
     * Build a navigation extension function for a single destination.
     *
     * For data objects: `fun Navigator.toFeed() = navigate(HomeDestination.Feed)`
     * For data classes: `fun Navigator.toDetail(id: String) = navigate(HomeDestination.Detail(id))`
     *
     * @param stack The parent stack containing this destination
     * @param destination The destination to generate an extension for
     * @return A FunSpec for the generated extension function
     */
    private fun buildDestinationExtension(stack: StackInfo, destination: DestinationInfo): FunSpec {
        val functionName = "to${destination.className}"
        val destinationType = ClassName(stack.packageName, stack.className, destination.className)

        return if (destination.isDataObject) {
            // Data object - no parameters
            FunSpec.builder(functionName)
                .addKdoc("Navigate to the ${destination.className} screen.")
                .receiver(NAVIGATOR)
                .addStatement("navigate(%T)", destinationType)
                .build()
        } else {
            // Data class - parameters required
            val funBuilder = FunSpec.builder(functionName)
                .addKdoc(buildDestinationKDoc(destination))
                .receiver(NAVIGATOR)

            // Add parameters from constructor
            destination.constructorParams.forEach { param ->
                val paramSpec = ParameterSpec.builder(
                    param.name,
                    param.type.toTypeName()
                ).build()
                funBuilder.addParameter(paramSpec)
            }

            // Build destination construction with all parameters
            val constructorArgs = destination.constructorParams.joinToString(", ") { it.name }
            funBuilder.addStatement("navigate(%T($constructorArgs))", destinationType)

            funBuilder.build()
        }
    }

    /**
     * Build KDoc for a destination extension with parameters.
     *
     * @param destination The destination to document
     * @return KDoc string with parameter documentation
     */
    private fun buildDestinationKDoc(destination: DestinationInfo): String {
        val paramDocs = destination.constructorParams.joinToString("\n") { param ->
            "@param ${param.name} ${param.name} parameter for ${destination.className}"
        }
        return """
            |Navigate to the ${destination.className} screen.
            |
            $paramDocs
        """.trimMargin()
    }

    // =========================================================================
    // Tab Switching Extensions
    // =========================================================================

    /**
     * Add tab switching extensions for all tabs in a tab container.
     *
     * Generates `switchTo{Tab}Tab()` functions that call `switchTab()` on the Navigator.
     *
     * @param builder The FileSpec builder to add functions to
     * @param tab The tab container information
     */
    private fun addTabSwitchingExtensions(builder: FileSpec.Builder, tab: TabInfo) {
        tab.tabs.forEach { tabItem ->
            builder.addFunction(buildTabSwitchExtension(tab, tabItem))
        }
    }

    /**
     * Build a tab switching extension function.
     *
     * Example: `fun Navigator.switchToHomeTab() = switchTab(MainTabs.Home)`
     *
     * @param tab The parent tab container
     * @param tabItem The tab item to generate an extension for
     * @return A FunSpec for the generated extension function
     */
    private fun buildTabSwitchExtension(tab: TabInfo, tabItem: TabItemInfo): FunSpec {
        val functionName = "switchTo${tabItem.destination.className}Tab"
        val tabType = ClassName(tab.packageName, tab.className, tabItem.destination.className)

        return FunSpec.builder(functionName)
            .addKdoc("Switch to the ${tabItem.label} tab.")
            .receiver(NAVIGATOR)
            .addStatement("switchTab(%T)", tabType)
            .build()
    }

    // =========================================================================
    // Pane Switching Extensions
    // =========================================================================

    /**
     * Add pane switching extensions for all panes in a pane container.
     *
     * Generates `switchTo{Pane}Pane()` functions that call `switchPane()` on the Navigator.
     *
     * @param builder The FileSpec builder to add functions to
     * @param pane The pane container information
     */
    private fun addPaneSwitchingExtensions(builder: FileSpec.Builder, pane: PaneInfo) {
        pane.panes.forEach { paneItem ->
            builder.addFunction(buildPaneSwitchExtension(pane, paneItem))
        }
    }

    /**
     * Build a pane switching extension function.
     *
     * Example: `fun Navigator.switchToDetailPanePane() = switchPane(MainPanes.DetailPane)`
     *
     * @param pane The parent pane container
     * @param paneItem The pane item to generate an extension for
     * @return A FunSpec for the generated extension function
     */
    private fun buildPaneSwitchExtension(pane: PaneInfo, paneItem: PaneItemInfo): FunSpec {
        val functionName = "switchTo${paneItem.destination.className}Pane"
        val paneType = ClassName(pane.packageName, pane.className, paneItem.destination.className)

        return FunSpec.builder(functionName)
            .addKdoc("Switch to the ${paneItem.destination.className} pane (${paneItem.role.name}).")
            .receiver(NAVIGATOR)
            .addStatement("switchPane(%T)", paneType)
            .build()
    }

    // =========================================================================
    // Helpers
    // =========================================================================

    /**
     * Count total number of extensions that will be generated.
     */
    private fun countExtensions(
        stacks: List<StackInfo>,
        tabs: List<TabInfo>,
        panes: List<PaneInfo>
    ): Int {
        val stackExtensions = stacks.sumOf { it.destinations.size }
        val tabExtensions = tabs.sumOf { it.tabs.size }
        val paneExtensions = panes.sumOf { it.panes.size }
        return stackExtensions + tabExtensions + paneExtensions
    }

    /**
     * Convert KSType to KotlinPoet TypeName.
     *
     * Handles primitive types and nullable types. Falls back to ClassName.bestGuess
     * for complex types.
     *
     * @return TypeName representation of this KSType
     */
    private fun KSType.toTypeName(): TypeName {
        val declaration = this.declaration
        val qualifiedName = declaration.qualifiedName?.asString() ?: return ANY

        val baseType = when (qualifiedName) {
            "kotlin.String" -> STRING
            "kotlin.Int" -> INT
            "kotlin.Long" -> LONG
            "kotlin.Boolean" -> BOOLEAN
            "kotlin.Float" -> FLOAT
            "kotlin.Double" -> DOUBLE
            else -> ClassName.bestGuess(qualifiedName)
        }
        return baseType.copy(nullable = this.isMarkedNullable)
    }
}
