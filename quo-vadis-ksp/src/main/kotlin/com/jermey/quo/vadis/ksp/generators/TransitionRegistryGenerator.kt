package com.jermey.quo.vadis.ksp.generators

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.jermey.quo.vadis.ksp.models.TransitionInfo
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.MemberName
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.STAR
import com.squareup.kotlinpoet.ksp.writeTo

/**
 * Generates the transition registry mapping destination classes to NavTransition instances.
 *
 * Consumes [TransitionInfo] models and produces a single `GeneratedTransitionRegistry.kt`
 * file containing:
 * - `object GeneratedTransitionRegistry : TransitionRegistry`
 * - `getTransition()` method with `when` expression dispatching to NavTransition instances
 *
 * ## Generated Code Pattern
 *
 * ```kotlin
 * public object GeneratedTransitionRegistry : TransitionRegistry {
 *
 *     override fun getTransition(destinationClass: KClass<*>): NavTransition? {
 *         return when (destinationClass) {
 *             com.example.DetailsScreen::class -> NavTransition.SlideVertical
 *             com.example.ModalScreen::class -> NavTransition.Fade
 *             com.example.CustomScreen::class -> com.example.CustomTransitionProvider().transition
 *             else -> null
 *         }
 *     }
 * }
 * ```
 *
 * ## TransitionType Mapping
 *
 * | TransitionType | Generated Code |
 * |----------------|----------------|
 * | SlideHorizontal | `NavTransition.SlideHorizontal` |
 * | SlideVertical | `NavTransition.SlideVertical` |
 * | Fade | `NavTransition.Fade` |
 * | None | `NavTransition.None` |
 * | Custom | `CustomClass().transition` |
 *
 * @property codeGenerator KSP code generator for writing output files
 * @property logger KSP logger for diagnostic output
 */
public class TransitionRegistryGenerator(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) {

    private companion object {
        private const val GENERATED_PACKAGE = "com.jermey.quo.vadis.generated"
        private const val REGISTRY_NAME = "GeneratedTransitionRegistry"

        // Core class references
        private val NAV_TRANSITION = ClassName(
            "com.jermey.quo.vadis.core.navigation.compose.animation",
            "NavTransition"
        )
        private val TRANSITION_REGISTRY = ClassName(
            "com.jermey.quo.vadis.core.navigation.compose.registry",
            "TransitionRegistry"
        )
        private val KCLASS = ClassName("kotlin.reflect", "KClass")

        // Mapping from TransitionType enum values to NavTransition companion properties
        private val PRESET_TRANSITIONS = setOf(
            "SlideHorizontal",
            "SlideVertical",
            "Fade",
            "None"
        )
    }

    /**
     * Generate the transition registry from extracted transition information.
     *
     * @param transitions List of TransitionInfo models from @Transition annotations
     * @param basePackage Base package for the generated code (unused, kept for API consistency)
     */
    public fun generate(
        transitions: List<TransitionInfo>,
        @Suppress("UNUSED_PARAMETER") basePackage: String = GENERATED_PACKAGE
    ) {
        if (transitions.isEmpty()) {
            logger.info("No @Transition annotations found, skipping TransitionRegistry generation")
            return
        }

        val fileSpec = buildFileSpec(transitions)

        // Collect source files for dependency tracking
        val sourceFiles = transitions.map { it.containingFile }

        val dependencies = Dependencies(
            aggregating = true,
            sources = sourceFiles.toTypedArray()
        )

        fileSpec.writeTo(codeGenerator, dependencies)

        logger.info(
            "Generated $REGISTRY_NAME with ${transitions.size} transition mappings"
        )
    }

    private fun buildFileSpec(transitions: List<TransitionInfo>): FileSpec {
        return FileSpec.builder(GENERATED_PACKAGE, REGISTRY_NAME)
            .addFileComment("DO NOT EDIT - Auto-generated by Quo Vadis KSP processor")
            .addType(buildRegistryObject(transitions))
            .build()
    }

    private fun buildRegistryObject(transitions: List<TransitionInfo>): TypeSpec {
        return TypeSpec.objectBuilder(REGISTRY_NAME)
            .addKdoc(
                """
                |KSP-generated transition registry mapping destination classes to NavTransition instances.
                |
                |Generated from @Transition annotations found in the codebase.
                |DO NOT EDIT - This file is auto-generated by Quo Vadis KSP processor.
                """.trimMargin()
            )
            .addSuperinterface(TRANSITION_REGISTRY)
            .addFunction(buildGetTransitionFunction(transitions))
            .build()
    }

    private fun buildGetTransitionFunction(transitions: List<TransitionInfo>): FunSpec {
        val returnType = NAV_TRANSITION.copy(nullable = true)
        val paramType = KCLASS.parameterizedBy(STAR)

        return FunSpec.builder("getTransition")
            .addModifiers(KModifier.OVERRIDE)
            .addParameter("destinationClass", paramType)
            .returns(returnType)
            .apply {
                if (transitions.isEmpty()) {
                    addStatement("return null")
                } else {
                    beginControlFlow("return when (destinationClass)")
                    transitions.forEach { info ->
                        addStatement(
                            "%L::class -> %L",
                            info.destinationQualifiedName,
                            buildTransitionExpression(info)
                        )
                    }
                    addStatement("else -> null")
                    endControlFlow()
                }
            }
            .build()
    }

    /**
     * Build the code expression for a transition value.
     *
     * For preset transitions: `NavTransition.SlideHorizontal`
     * For custom transitions: `com.example.CustomClass().transition`
     *
     * @param info The transition info containing type and optional custom class
     * @return CodeBlock representing the transition expression
     */
    private fun buildTransitionExpression(info: TransitionInfo): CodeBlock {
        return if (info.transitionType in PRESET_TRANSITIONS) {
            // Preset transition: NavTransition.SlideHorizontal
            CodeBlock.of(
                "%T.%L",
                NAV_TRANSITION,
                info.transitionType
            )
        } else {
            // Custom transition: instantiate the class and access .transition property
            // Assumes the custom class is an object or has a no-arg constructor
            val customClass = info.customTransitionClass
                ?: error("Custom transition requires customTransitionClass")
            CodeBlock.of(
                "%L().transition",
                customClass
            )
        }
    }
}
