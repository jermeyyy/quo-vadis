package com.jermey.quo.vadis.ksp.generators

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.jermey.quo.vadis.ksp.models.AdaptStrategy
import com.jermey.quo.vadis.ksp.models.PaneBackBehavior
import com.jermey.quo.vadis.ksp.models.PaneInfo
import com.jermey.quo.vadis.ksp.models.PaneRole
import com.jermey.quo.vadis.ksp.models.StackInfo
import com.jermey.quo.vadis.ksp.models.TabInfo
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.asTypeName
import com.squareup.kotlinpoet.ksp.writeTo

/**
 * Generates `build{Name}NavNode()` functions for navigation containers.
 *
 * This generator creates functions that construct initial NavNode trees
 * from @Stack, @Tab, and @Pane annotations. The generated functions return
 * properly typed NavNode instances (StackNode, TabNode, PaneNode) that can
 * be used to initialize navigation state.
 *
 * ## Generated Output
 *
 * Files are generated in a `generated` subpackage of the original package:
 * ```
 * {original.package}.generated/{ClassName}NavNodeBuilder.kt
 * ```
 *
 * ## Example Usage
 *
 * For a `@Stack(name = "home")` on `HomeDestination`:
 * ```kotlin
 * // Generated function
 * fun buildHomeDestinationNavNode(
 *     key: String = "home-stack",
 *     parentKey: String? = null
 * ): StackNode
 *
 * // Usage
 * val homeStack = buildHomeDestinationNavNode()
 * ```
 *
 * @property codeGenerator KSP code generator for writing output files
 * @property logger KSP logger for diagnostic output
 */
@Suppress("TooManyFunctions") // Generator needs separate methods for each node type and their code builders
class NavNodeBuilderGenerator(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) {

    companion object {
        private const val GENERATED_PACKAGE_SUFFIX = "generated"
        private const val FILE_COMMENT = "Generated by Quo Vadis KSP - DO NOT EDIT"

        // NavNode type class names from quo-vadis-core
        private const val NAVNODE_PACKAGE = "com.jermey.quo.vadis.core.navigation.core"
        private val SCREEN_NODE = ClassName(NAVNODE_PACKAGE, "ScreenNode")
        private val STACK_NODE = ClassName(NAVNODE_PACKAGE, "StackNode")
        private val TAB_NODE = ClassName(NAVNODE_PACKAGE, "TabNode")
        private val PANE_NODE = ClassName(NAVNODE_PACKAGE, "PaneNode")
        private val PANE_CONFIGURATION = ClassName(NAVNODE_PACKAGE, "PaneConfiguration")
        private val PANE_ROLE = ClassName(NAVNODE_PACKAGE, "PaneRole")
        private val ADAPT_STRATEGY = ClassName(NAVNODE_PACKAGE, "AdaptStrategy")
        private val PANE_BACK_BEHAVIOR = ClassName(NAVNODE_PACKAGE, "PaneBackBehavior")
    }

    /**
     * Generate NavNode builder for a @Stack container.
     *
     * Creates a `build{ClassName}NavNode()` function that returns a [StackNode]
     * initialized with the start destination as its first screen.
     *
     * @param stackInfo Extracted metadata from the @Stack annotation
     */
    fun generateStackBuilder(stackInfo: StackInfo) {
        val packageName = "${stackInfo.packageName}.$GENERATED_PACKAGE_SUFFIX"
        val fileName = "${stackInfo.className}NavNodeBuilder"

        logger.info("Generating stack builder: $packageName.$fileName")

        val fileSpec = FileSpec.builder(packageName, fileName)
            .addFileComment(FILE_COMMENT)
            .addFunction(buildStackNodeFunction(stackInfo))
            .build()

        fileSpec.writeTo(codeGenerator, Dependencies(false))
    }

    /**
     * Generate NavNode builder for a @Tab container.
     *
     * Creates a `build{ClassName}NavNode()` function that returns a [TabNode]
     * with all tab stacks initialized. Each tab references its root graph's
     * builder function.
     *
     * @param tabInfo Extracted metadata from the @Tab annotation
     * @param stackBuilders Map of stack class names to their StackInfo (reserved for future
     *        cross-package validation; currently tab builders resolve imports dynamically)
     */
    @Suppress("UnusedParameter") // stackBuilders reserved for future validation/optimization
    fun generateTabBuilder(tabInfo: TabInfo, stackBuilders: Map<String, StackInfo>) {
        val packageName = "${tabInfo.packageName}.$GENERATED_PACKAGE_SUFFIX"
        val fileName = "${tabInfo.className}NavNodeBuilder"

        logger.info("Generating tab builder: $packageName.$fileName")

        val fileSpec = FileSpec.builder(packageName, fileName)
            .addFileComment(FILE_COMMENT)
            .apply {
                // Add imports for tab root graph builders
                tabInfo.tabs.forEach { tabItem ->
                    val rootGraphName = tabItem.rootGraphClass.simpleName.asString()
                    val rootGraphPackage = tabItem.rootGraphClass.packageName.asString()
                    addImport(
                        "$rootGraphPackage.$GENERATED_PACKAGE_SUFFIX",
                        "build${rootGraphName}NavNode"
                    )
                }
            }
            .addFunction(buildTabNodeFunction(tabInfo))
            .build()

        fileSpec.writeTo(codeGenerator, Dependencies(false))
    }

    /**
     * Generate NavNode builder for a @Pane container.
     *
     * Creates a `build{ClassName}NavNode()` function that returns a [PaneNode]
     * with all pane configurations initialized. Each pane references its root
     * graph's builder function.
     *
     * @param paneInfo Extracted metadata from the @Pane annotation
     */
    fun generatePaneBuilder(paneInfo: PaneInfo) {
        val packageName = "${paneInfo.packageName}.$GENERATED_PACKAGE_SUFFIX"
        val fileName = "${paneInfo.className}NavNodeBuilder"

        logger.info("Generating pane builder: $packageName.$fileName")

        val fileSpec = FileSpec.builder(packageName, fileName)
            .addFileComment(FILE_COMMENT)
            .apply {
                // Add imports for pane root graph builders
                paneInfo.panes.forEach { paneItem ->
                    val rootGraphName = paneItem.rootGraphClass.simpleName.asString()
                    val rootGraphPackage = paneItem.rootGraphClass.packageName.asString()
                    addImport(
                        "$rootGraphPackage.$GENERATED_PACKAGE_SUFFIX",
                        "build${rootGraphName}NavNode"
                    )
                }
            }
            .addFunction(buildPaneNodeFunction(paneInfo))
            .build()

        fileSpec.writeTo(codeGenerator, Dependencies(false))
    }

    // =========================================================================
    // Private Builder Functions - Stack
    // =========================================================================

    private fun buildStackNodeFunction(stackInfo: StackInfo): FunSpec {
        val startDest = stackInfo.resolvedStartDestination
            ?: throw IllegalStateException(
                "No start destination resolved for ${stackInfo.className}. " +
                    "Ensure @Stack(startDestination = \"...\") matches a @Destination subclass."
            )

        return FunSpec.builder("build${stackInfo.className}NavNode")
            .addKdoc(
                """
                |Builds the initial NavNode tree for the "${stackInfo.name}" stack.
                |
                |This function creates a [%T] with [%T.%L] as the start destination.
                |The stack is initialized with a single screen, which can then be
                |modified through navigation operations.
                |
                |@param key Unique key for the root StackNode (default: "${stackInfo.name}-stack")
                |@param parentKey Parent node key, or null if this is a root node
                |@return A [%T] containing the initial navigation state
                """.trimMargin(),
                STACK_NODE,
                ClassName(stackInfo.packageName, stackInfo.className),
                startDest.className,
                STACK_NODE
            )
            .addParameter(
                ParameterSpec.builder("key", String::class)
                    .defaultValue("%S", "${stackInfo.name}-stack")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("parentKey", String::class.asTypeName().copy(nullable = true))
                    .defaultValue("null")
                    .build()
            )
            .returns(STACK_NODE)
            .addCode(buildStackNodeCode(stackInfo, startDest))
            .build()
    }

    private fun buildStackNodeCode(
        stackInfo: StackInfo,
        startDest: com.jermey.quo.vadis.ksp.models.DestinationInfo
    ): CodeBlock {
        val destinationClassName = ClassName(stackInfo.packageName, stackInfo.className)
        val screenKey = "\$key/${startDest.className.lowercase()}"

        return CodeBlock.builder()
            .add("return %T(\n", STACK_NODE)
            .indent()
            .add("key = key,\n")
            .add("parentKey = parentKey,\n")
            .add("children = listOf(\n")
            .indent()
            .add("%T(\n", SCREEN_NODE)
            .indent()
            .add("key = %S,\n", screenKey)
            .add("parentKey = key,\n")
            .add("destination = %T.%L\n", destinationClassName, startDest.className)
            .unindent()
            .add(")\n")
            .unindent()
            .add(")\n")
            .unindent()
            .add(")\n")
            .build()
    }

    // =========================================================================
    // Private Builder Functions - Tab
    // =========================================================================

    private fun buildTabNodeFunction(tabInfo: TabInfo): FunSpec {
        val initialTabIndex = tabInfo.tabs.indexOfFirst {
            it.destination.className == tabInfo.initialTab
        }.takeIf { it >= 0 } ?: 0

        return FunSpec.builder("build${tabInfo.className}NavNode")
            .addKdoc(
                """
                |Builds the initial NavNode tree for the "${tabInfo.name}" tab container.
                |
                |This function creates a [%T] with parallel navigation stacks for each tab.
                |Each tab maintains its own navigation history independently.
                |
                |@param key Unique key for the root TabNode (default: "${tabInfo.name}-tabs")
                |@param parentKey Parent node key, or null if this is a root node
                |@param initialTabIndex Index of the initially active tab (default: $initialTabIndex)
                |@return A [%T] containing all tab stacks
                """.trimMargin(),
                TAB_NODE,
                TAB_NODE
            )
            .addParameter(
                ParameterSpec.builder("key", String::class)
                    .defaultValue("%S", "${tabInfo.name}-tabs")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("parentKey", String::class.asTypeName().copy(nullable = true))
                    .defaultValue("null")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("initialTabIndex", Int::class)
                    .defaultValue("%L", initialTabIndex)
                    .build()
            )
            .returns(TAB_NODE)
            .addCode(buildTabNodeCode(tabInfo))
            .build()
    }

    private fun buildTabNodeCode(tabInfo: TabInfo): CodeBlock {
        val builder = CodeBlock.builder()
            .addStatement("return %T(", TAB_NODE)
            .indent()
            .addStatement("key = key,")
            .addStatement("parentKey = parentKey,")
            .addStatement("stacks = listOf(")
            .indent()

        tabInfo.tabs.forEachIndexed { index, tabItem ->
            val rootGraphName = tabItem.rootGraphClass.simpleName.asString()
            val tabKey = tabItem.destination.className.lowercase()

            builder.addStatement(
                "build${rootGraphName}NavNode(key = %P, parentKey = key)%L",
                "\$key/$tabKey",
                if (index < tabInfo.tabs.size - 1) "," else ""
            )
        }

        builder
            .unindent()
            .addStatement("),")
            .addStatement("activeStackIndex = initialTabIndex")
            .unindent()
            .addStatement(")")

        return builder.build()
    }

    // =========================================================================
    // Private Builder Functions - Pane
    // =========================================================================

    private fun buildPaneNodeFunction(paneInfo: PaneInfo): FunSpec {
        return FunSpec.builder("build${paneInfo.className}NavNode")
            .addKdoc(
                """
                |Builds the initial NavNode tree for the "${paneInfo.name}" pane container.
                |
                |This function creates a [%T] configured for adaptive layouts.
                |The pane container supports showing multiple panes simultaneously on
                |large screens while collapsing to single-pane on compact screens.
                |
                |@param key Unique key for the root PaneNode (default: "${paneInfo.name}-pane")
                |@param parentKey Parent node key, or null if this is a root node
                |@param activePaneRole Initially active pane role (default: [%T.Primary])
                |@return A [%T] with all pane configurations
                """.trimMargin(),
                PANE_NODE,
                PANE_ROLE,
                PANE_NODE
            )
            .addParameter(
                ParameterSpec.builder("key", String::class)
                    .defaultValue("%S", "${paneInfo.name}-pane")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("parentKey", String::class.asTypeName().copy(nullable = true))
                    .defaultValue("null")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("activePaneRole", PANE_ROLE)
                    .defaultValue("%T.Primary", PANE_ROLE)
                    .build()
            )
            .returns(PANE_NODE)
            .addCode(buildPaneNodeCode(paneInfo))
            .build()
    }

    private fun buildPaneNodeCode(paneInfo: PaneInfo): CodeBlock {
        val builder = CodeBlock.builder()
            .addStatement("return %T(", PANE_NODE)
            .indent()
            .addStatement("key = key,")
            .addStatement("parentKey = parentKey,")
            .addStatement("paneConfigurations = mapOf(")
            .indent()

        paneInfo.panes.forEachIndexed { index, paneItem ->
            val rootGraphName = paneItem.rootGraphClass.simpleName.asString()
            val paneKey = paneItem.destination.className.lowercase()
            val coreRole = mapPaneRoleToCore(paneItem.role)
            val coreAdaptStrategy = mapAdaptStrategyToCore(paneItem.adaptStrategy)

            builder.addStatement(
                "%T.%L to %T(",
                PANE_ROLE,
                coreRole,
                PANE_CONFIGURATION
            )
            builder.indent()
            builder.addStatement(
                "content = build${rootGraphName}NavNode(key = %P, parentKey = key),",
                "\$key/$paneKey"
            )
            builder.addStatement(
                "adaptStrategy = %T.%L",
                ADAPT_STRATEGY,
                coreAdaptStrategy
            )
            builder.unindent()
            builder.addStatement(")%L", if (index < paneInfo.panes.size - 1) "," else "")
        }

        val coreBackBehavior = mapPaneBackBehaviorToCore(paneInfo.backBehavior)

        builder
            .unindent()
            .addStatement("),")
            .addStatement("activePaneRole = activePaneRole,")
            .addStatement("backBehavior = %T.%L", PANE_BACK_BEHAVIOR, coreBackBehavior)
            .unindent()
            .addStatement(")")

        return builder.build()
    }

    // =========================================================================
    // Enum Mapping - Model enums to Core enums
    // =========================================================================

    /**
     * Maps KSP model PaneRole to core NavNode PaneRole.
     * Model uses SCREAMING_CASE, core uses PascalCase.
     */
    private fun mapPaneRoleToCore(role: PaneRole): String {
        return when (role) {
            PaneRole.PRIMARY -> "Primary"
            PaneRole.SECONDARY -> "Supporting" // Map SECONDARY -> Supporting
            PaneRole.EXTRA -> "Extra"
        }
    }

    /**
     * Maps KSP model AdaptStrategy to core NavNode AdaptStrategy.
     * Model uses SCREAMING_CASE, core uses PascalCase.
     */
    private fun mapAdaptStrategyToCore(strategy: AdaptStrategy): String {
        return when (strategy) {
            AdaptStrategy.HIDE -> "Hide"
            AdaptStrategy.COLLAPSE -> "Hide" // COLLAPSE maps to Hide (no direct equivalent)
            AdaptStrategy.OVERLAY -> "Levitate" // OVERLAY maps to Levitate
            AdaptStrategy.REFLOW -> "Reflow"
        }
    }

    /**
     * Maps KSP model PaneBackBehavior to core NavNode PaneBackBehavior.
     */
    private fun mapPaneBackBehaviorToCore(behavior: PaneBackBehavior): String {
        return when (behavior) {
            PaneBackBehavior.PopUntilScaffoldValueChange -> "PopUntilScaffoldValueChange"
            PaneBackBehavior.PopUntilContentChange -> "PopUntilContentChange"
            PaneBackBehavior.PopLatest -> "PopLatest"
        }
    }
}
