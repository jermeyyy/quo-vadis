package com.jermey.quo.vadis.ksp.generators

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.jermey.quo.vadis.ksp.generators.base.StringTemplates
import com.jermey.quo.vadis.ksp.models.AdaptStrategy
import com.jermey.quo.vadis.ksp.models.PaneBackBehavior
import com.jermey.quo.vadis.ksp.models.PaneInfo
import com.jermey.quo.vadis.ksp.models.PaneRole
import com.jermey.quo.vadis.ksp.models.StackInfo
import com.jermey.quo.vadis.ksp.models.TabInfo
import com.jermey.quo.vadis.ksp.models.TabItemType
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.asClassName
import com.squareup.kotlinpoet.asTypeName
import com.squareup.kotlinpoet.ksp.writeTo

/**
 * Generates `build{Name}NavNode()` functions for navigation containers.
 *
 * This generator creates functions that construct initial NavNode trees
 * from @Stack, @Tab, and @Pane annotations. The generated functions return
 * properly typed NavNode instances (StackNode, TabNode, PaneNode) that can
 * be used to initialize navigation state.
 *
 * ## Generated Output
 *
 * Files are generated in a `generated` subpackage of the original package:
 * ```
 * {original.package}.generated/{ClassName}NavNodeBuilder.kt
 * ```
 *
 * ## Example Usage
 *
 * For a `@Stack(name = "home")` on `HomeDestination`:
 * ```kotlin
 * // Generated function
 * fun buildHomeDestinationNavNode(
 *     key: String = "home-stack",
 *     parentKey: String? = null
 * ): StackNode
 *
 * // Usage
 * val homeStack = buildHomeDestinationNavNode()
 * ```
 *
 * @property codeGenerator KSP code generator for writing output files
 * @property logger KSP logger for diagnostic output
 */
@Suppress("TooManyFunctions") // Generator needs separate methods for each node type and their code builders
class NavNodeBuilderGenerator(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) {

    companion object {
        private const val GENERATED_PACKAGE_SUFFIX = "generated"
        private const val FILE_COMMENT = "Generated by Quo Vadis KSP - DO NOT EDIT"

        // NavNode type class names from quo-vadis-core
        private const val NAVNODE_PACKAGE = "com.jermey.quo.vadis.core.navigation.core"
        private val SCREEN_NODE = ClassName(NAVNODE_PACKAGE, "ScreenNode")
        private val STACK_NODE = ClassName(NAVNODE_PACKAGE, "StackNode")
        private val TAB_NODE = ClassName(NAVNODE_PACKAGE, "TabNode")
        private val PANE_NODE = ClassName(NAVNODE_PACKAGE, "PaneNode")
        private val PANE_CONFIGURATION = ClassName(NAVNODE_PACKAGE, "PaneConfiguration")
        private val PANE_ROLE = ClassName(NAVNODE_PACKAGE, "PaneRole")
        private val ADAPT_STRATEGY = ClassName(NAVNODE_PACKAGE, "AdaptStrategy")
        private val PANE_BACK_BEHAVIOR = ClassName(NAVNODE_PACKAGE, "PaneBackBehavior")
        private val GENERATED_TAB_METADATA = ClassName(NAVNODE_PACKAGE, "GeneratedTabMetadata")
    }

    /**
     * Generate NavNode builder for a @Stack container.
     *
     * Creates a `build{ClassName}NavNode()` function that returns a [StackNode]
     * initialized with the start destination as its first screen.
     *
     * @param stackInfo Extracted metadata from the @Stack annotation
     * @param addDeprecations When true, adds @Deprecated annotation to the generated function
     */
    fun generateStackBuilder(stackInfo: StackInfo, addDeprecations: Boolean = false) {
        val packageName = "${stackInfo.packageName}.$GENERATED_PACKAGE_SUFFIX"
        val fileName = "${stackInfo.className}NavNodeBuilder"

        logger.info("Generating stack builder: $packageName.$fileName")

        val fileSpec = FileSpec.builder(packageName, fileName)
            .addFileComment(FILE_COMMENT)
            .addFunction(buildStackNodeFunction(stackInfo, addDeprecations))
            .build()

        fileSpec.writeTo(codeGenerator, Dependencies(false))
    }

    /**
     * Generate NavNode builder for a @Tab container.
     *
     * Creates a `build{ClassName}NavNode()` function that returns a [TabNode]
     * with all tab stacks initialized. Each tab references its root graph's
     * builder function.
     *
     * Handles two tab types:
     * - [TabItemType.NESTED_STACK]: Calls the stack's builder function
     * - [TabItemType.FLAT_SCREEN]: Generates inline StackNode with single ScreenNode
     *
     * @param tabInfo Extracted metadata from the @Tab annotation
     * @param stackBuilders Map of stack class names to their StackInfo (reserved for future
     *        cross-package validation; currently tab builders resolve imports dynamically)
     * @param addDeprecations When true, adds @Deprecated annotation to the generated function
     */
    @Suppress("UnusedParameter") // stackBuilders reserved for future validation/optimization
    fun generateTabBuilder(tabInfo: TabInfo, stackBuilders: Map<String, StackInfo>, addDeprecations: Boolean = false) {
        val packageName = "${tabInfo.packageName}.$GENERATED_PACKAGE_SUFFIX"
        val fileName = "${tabInfo.className}NavNodeBuilder"

        logger.info("Generating tab builder: $packageName.$fileName")

        val fileSpec = FileSpec.builder(packageName, fileName)
            .addFileComment(FILE_COMMENT)
            .apply {
                // Add imports only for NESTED_STACK tab root graph builders
                // FLAT_SCREEN tabs generate inline code, no imports needed
                tabInfo.tabs
                    .filter { it.tabType == TabItemType.NESTED_STACK }
                    .forEach { tabItem ->
                        // For NESTED_STACK, use stackInfo class or fall back to tab class itself
                        val rootGraph = tabItem.stackInfo?.classDeclaration ?: tabItem.classDeclaration
                        val rootGraphName = rootGraph.simpleName.asString()
                        val rootGraphPackage = rootGraph.packageName.asString()
                        addImport(
                            "$rootGraphPackage.$GENERATED_PACKAGE_SUFFIX",
                            "build${rootGraphName}NavNode"
                        )
                    }
            }
            .addFunction(buildTabNodeFunction(tabInfo, addDeprecations))
            .addFunction(buildTabMetadataFunction(tabInfo))
            .build()

        fileSpec.writeTo(codeGenerator, Dependencies(false))
    }

    /**
     * Generate NavNode builder for a @Pane container.
     *
     * Creates a `build{ClassName}NavNode()` function that returns a [PaneNode]
     * with all pane configurations initialized. Each pane references its root
     * graph's builder function.
     *
     * @param paneInfo Extracted metadata from the @Pane annotation
     * @param addDeprecations When true, adds @Deprecated annotation to the generated function
     */
    fun generatePaneBuilder(paneInfo: PaneInfo, addDeprecations: Boolean = false) {
        val packageName = "${paneInfo.packageName}.$GENERATED_PACKAGE_SUFFIX"
        val fileName = "${paneInfo.className}NavNodeBuilder"

        logger.info("Generating pane builder: $packageName.$fileName")

        val fileSpec = FileSpec.builder(packageName, fileName)
            .addFileComment(FILE_COMMENT)
            .apply {
                // Add imports for pane root graph builders
                paneInfo.panes.forEach { paneItem ->
                    val rootGraphName = paneItem.rootGraphClass.simpleName.asString()
                    val rootGraphPackage = paneItem.rootGraphClass.packageName.asString()
                    addImport(
                        "$rootGraphPackage.$GENERATED_PACKAGE_SUFFIX",
                        "build${rootGraphName}NavNode"
                    )
                }
            }
            .addFunction(buildPaneNodeFunction(paneInfo, addDeprecations))
            .build()

        fileSpec.writeTo(codeGenerator, Dependencies(false))
    }

    // =========================================================================
    // Private Helper Functions
    // =========================================================================

    /**
     * Builds the @Deprecated annotation for legacy builder functions.
     *
     * @param functionName The name of the deprecated function
     * @param containerClass The container class name (without ::class)
     */
    private fun buildDeprecationAnnotation(functionName: String, containerClass: String): AnnotationSpec {
        return AnnotationSpec.builder(Deprecated::class)
            .addMember("message = %S", StringTemplates.deprecatedBuilderMessage(functionName, containerClass))
            .addMember(
                "replaceWith = %T(%S, %S)",
                ReplaceWith::class,
                "GeneratedNavigationConfig.buildNavNode($containerClass::class)",
                "com.jermey.quo.vadis.generated.GeneratedNavigationConfig"
            )
            .addMember("level = %T.%L", DeprecationLevel::class, "WARNING")
            .build()
    }

    // =========================================================================
    // Private Builder Functions - Stack
    // =========================================================================

    private fun buildStackNodeFunction(stackInfo: StackInfo, addDeprecations: Boolean): FunSpec {
        val startDest = stackInfo.resolvedStartDestination
            ?: throw IllegalStateException(
                "No start destination resolved for ${stackInfo.className}. " +
                    "Ensure @Stack(startDestination = \"...\") matches a @Destination subclass."
            )

        // Build proper ClassName for possibly nested stack class
        val stackClassName = buildClassName(stackInfo.classDeclaration)
        val functionName = "build${stackInfo.className}NavNode"

        return FunSpec.builder(functionName)
            .addKdoc(
                """
                |Builds the initial NavNode tree for the "${stackInfo.name}" stack.
                |
                |This function creates a [%T] with [%T.%L] as the start destination.
                |The stack is initialized with a single screen, which can then be
                |modified through navigation operations.
                |
                |@param key Unique key for the root StackNode (default: "${stackInfo.name}-stack")
                |@param parentKey Parent node key, or null if this is a root node
                |@return A [%T] containing the initial navigation state
                """.trimMargin(),
                STACK_NODE,
                stackClassName,
                startDest.className,
                STACK_NODE
            )
            .apply {
                if (addDeprecations) {
                    addAnnotation(buildDeprecationAnnotation(functionName, stackInfo.className))
                }
            }
            .addParameter(
                ParameterSpec.builder("key", String::class)
                    .defaultValue("%S", "${stackInfo.name}-stack")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("parentKey", String::class.asTypeName().copy(nullable = true))
                    .defaultValue("null")
                    .build()
            )
            .returns(STACK_NODE)
            .addCode(buildStackNodeCode(stackInfo, startDest))
            .build()
    }

    private fun buildStackNodeCode(
        stackInfo: StackInfo,
        startDest: com.jermey.quo.vadis.ksp.models.DestinationInfo
    ): CodeBlock {
        // Build proper ClassName for possibly nested stack class
        val destinationClassName = buildClassName(stackInfo.classDeclaration)
        val screenKey = "\$key/${startDest.className.lowercase()}"

        return CodeBlock.builder()
            .add("return %T(\n", STACK_NODE)
            .indent()
            .add("key = key,\n")
            .add("parentKey = parentKey,\n")
            .add("children = listOf(\n")
            .indent()
            .add("%T(\n", SCREEN_NODE)
            .indent()
            .add("key = %P,\n", screenKey)
            .add("parentKey = key,\n")
            .add("destination = %T.%L\n", destinationClassName, startDest.className)
            .unindent()
            .add(")\n")
            .unindent()
            .add("),\n")
            .add("scopeKey = %S\n", stackInfo.className)
            .unindent()
            .add(")\n")
            .build()
    }

    // =========================================================================
    // Private Builder Functions - Tab
    // =========================================================================

    private fun buildTabNodeFunction(tabInfo: TabInfo, addDeprecations: Boolean): FunSpec {
        // Calculate initial tab index: if initialTabClass is set, find its index; otherwise 0
        val initialTabIndex = tabInfo.initialTabClass?.let { initialClass ->
            val initialQualifiedName = initialClass.qualifiedName?.asString()
            tabInfo.tabs.indexOfFirst {
                it.classDeclaration.qualifiedName?.asString() == initialQualifiedName
            }.takeIf { it >= 0 }
        } ?: 0

        val functionName = "build${tabInfo.className}NavNode"

        return FunSpec.builder(functionName)
            .addKdoc(
                """
                |Builds the initial NavNode tree for the "${tabInfo.name}" tab container.
                |
                |This function creates a [%T] with parallel navigation stacks for each tab.
                |Each tab maintains its own navigation history independently.
                |
                |@param key Unique key for the root TabNode (default: "${tabInfo.name}-tabs")
                |@param parentKey Parent node key, or null if this is a root node
                |@param initialTabIndex Index of the initially active tab (default: $initialTabIndex)
                |@return A [%T] containing all tab stacks
                """.trimMargin(),
                TAB_NODE,
                TAB_NODE
            )
            .apply {
                if (addDeprecations) {
                    addAnnotation(buildDeprecationAnnotation(functionName, tabInfo.className))
                }
            }
            .addParameter(
                ParameterSpec.builder("key", String::class)
                    .defaultValue("%S", "${tabInfo.name}-tabs")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("parentKey", String::class.asTypeName().copy(nullable = true))
                    .defaultValue("null")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("initialTabIndex", Int::class)
                    .defaultValue("%L", initialTabIndex)
                    .build()
            )
            .returns(TAB_NODE)
            .addCode(buildTabNodeCode(tabInfo))
            .build()
    }

    private fun buildTabNodeCode(tabInfo: TabInfo): CodeBlock {
        val builder = CodeBlock.builder()
            .add("return %T(\n", TAB_NODE)
            .indent()
            .add("key = key,\n")
            .add("parentKey = parentKey,\n")
            .add("stacks = listOf(\n")
            .indent()

        tabInfo.tabs.forEachIndexed { index, tabItem ->
            // Always use classDeclaration for tab key - it's the tab item class name
            val tabKey = tabItem.classDeclaration.simpleName.asString().lowercase()
            val isLast = index == tabInfo.tabs.size - 1
            val comma = if (isLast) "" else ","

            when (tabItem.tabType) {
                TabItemType.FLAT_SCREEN -> {
                    // Generate inline StackNode with single ScreenNode
                    // For FLAT_SCREEN tabs, the tab class itself IS the destination
                    // Use "root" as screen key suffix to avoid duplicate keys
                    // (stack key is $key/tabKey, screen key is $key/tabKey/root)

                    // Build ClassName for possibly nested class
                    val destClassName = buildClassName(tabItem.classDeclaration)

                    builder.add(
                        "%T(\n" +
                            "    key = %P,\n" +
                            "    parentKey = key,\n" +
                            "    children = listOf(\n" +
                            "        %T(\n" +
                            "            key = %P,\n" +
                            "            parentKey = %P,\n" +
                            "            destination = %T\n" +
                            "        )\n" +
                            "    )\n" +
                            ")%L\n",
                        STACK_NODE,
                        "\$key/$tabKey",
                        SCREEN_NODE,
                        "\$key/$tabKey/root",
                        "\$key/$tabKey",
                        destClassName,
                        comma
                    )
                }
                TabItemType.NESTED_STACK -> {
                    // Use existing logic - call the stack's builder function
                    // For NESTED_STACK, use stackInfo class or fall back to tab class itself
                    val rootGraph = tabItem.stackInfo?.classDeclaration ?: tabItem.classDeclaration
                    val rootGraphName = rootGraph.simpleName.asString()

                    builder.add(
                        "build${rootGraphName}NavNode(key = %P, parentKey = key)%L\n",
                        "\$key/$tabKey",
                        comma
                    )
                }
            }
        }

        builder
            .unindent()
            .add("),\n")
            .add("activeStackIndex = initialTabIndex,\n")
            .add("wrapperKey = %S,\n", tabInfo.className)
            .add("scopeKey = %S,\n", tabInfo.className)
            .add("tabMetadata = listOf(\n")
            .indent()

        // Add inline tab metadata
        tabInfo.tabs.forEachIndexed { index, tabItem ->
            // Determine route based on tab type
            val route = when (tabItem.tabType) {
                TabItemType.FLAT_SCREEN -> tabItem.destinationInfo?.route ?: ""
                TabItemType.NESTED_STACK -> tabItem.stackInfo?.resolvedStartDestination?.route ?: ""
            }

            builder.add(
                "%T(label = %S, icon = %S, route = %S)%L\n",
                GENERATED_TAB_METADATA,
                tabItem.label,
                tabItem.icon,
                route,
                if (index < tabInfo.tabs.size - 1) "," else ""
            )
        }

        builder.unindent()
            .add(")\n")
            .unindent()
            .add(")\n")

        return builder.build()
    }

    /**
     * Builds a ClassName for a KSClassDeclaration, handling nested classes.
     *
     * For nested classes like `MainTabs.HomeTab`, this returns
     * `ClassName(packageName, "MainTabs", "HomeTab")`.
     */
    private fun buildClassName(
        classDeclaration: com.google.devtools.ksp.symbol.KSClassDeclaration
    ): ClassName {
        val packageName = classDeclaration.packageName.asString()
        val simpleNames = mutableListOf<String>()

        // Walk up the parent chain to collect all enclosing class names
        var current: com.google.devtools.ksp.symbol.KSDeclaration? = classDeclaration
        while (current is com.google.devtools.ksp.symbol.KSClassDeclaration) {
            simpleNames.add(0, current.simpleName.asString())
            current = current.parentDeclaration
        }

        return ClassName(packageName, simpleNames)
    }

    /**
     * Builds the function that returns tab metadata for a @Tab container.
     *
     * The generated function returns a list of [GeneratedTabMetadata] containing
     * label, icon string, and route for each tab. This can be used to build
     * UI components like bottom navigation bars.
     *
     * @param tabInfo Extracted metadata from the @Tab annotation
     * @return FunSpec for the `get{ClassName}Metadata()` function
     */
    private fun buildTabMetadataFunction(tabInfo: TabInfo): FunSpec {
        return FunSpec.builder("get${tabInfo.className}Metadata")
            .addKdoc(
                """
                |Returns metadata for all tabs in ${tabInfo.className}.
                |
                |This function provides tab display information (label, icon, route) that can
                |be used to build navigation UI components like bottom bars or tab rows.
                |
                |@return List of [%T] for each tab in order
                """.trimMargin(),
                GENERATED_TAB_METADATA
            )
            .returns(List::class.asClassName().parameterizedBy(GENERATED_TAB_METADATA))
            .addCode(buildTabMetadataCode(tabInfo))
            .build()
    }

    /**
     * Builds the code block that creates the list of GeneratedTabMetadata.
     *
     * For each tab, extracts:
     * - label: Display name from @TabItem
     * - icon: Icon identifier string from @TabItem
     * - route: Route from destinationInfo (FLAT_SCREEN) or stackInfo.resolvedStartDestination (NESTED_STACK)
     *
     * @param tabInfo Extracted metadata from the @Tab annotation
     * @return CodeBlock for the metadata list
     */
    private fun buildTabMetadataCode(tabInfo: TabInfo): CodeBlock {
        val builder = CodeBlock.builder()
            .add("return listOf(\n")
            .indent()

        tabInfo.tabs.forEachIndexed { index, tabItem ->
            // Determine route based on tab type
            val route = when (tabItem.tabType) {
                TabItemType.FLAT_SCREEN -> tabItem.destinationInfo?.route ?: ""
                TabItemType.NESTED_STACK -> tabItem.stackInfo?.resolvedStartDestination?.route ?: ""
            }

            builder.add(
                "%T(label = %S, icon = %S, route = %S)%L\n",
                GENERATED_TAB_METADATA,
                tabItem.label,
                tabItem.icon,
                route,
                if (index < tabInfo.tabs.size - 1) "," else ""
            )
        }

        builder.unindent().add(")\n")
        return builder.build()
    }

    // =========================================================================
    // Private Builder Functions - Pane
    // =========================================================================

    private fun buildPaneNodeFunction(paneInfo: PaneInfo, addDeprecations: Boolean): FunSpec {
        val functionName = "build${paneInfo.className}NavNode"

        return FunSpec.builder(functionName)
            .addKdoc(
                """
                |Builds the initial NavNode tree for the "${paneInfo.name}" pane container.
                |
                |This function creates a [%T] configured for adaptive layouts.
                |The pane container supports showing multiple panes simultaneously on
                |large screens while collapsing to single-pane on compact screens.
                |
                |@param key Unique key for the root PaneNode (default: "${paneInfo.name}-pane")
                |@param parentKey Parent node key, or null if this is a root node
                |@param activePaneRole Initially active pane role (default: [%T.Primary])
                |@return A [%T] with all pane configurations
                """.trimMargin(),
                PANE_NODE,
                PANE_ROLE,
                PANE_NODE
            )
            .apply {
                if (addDeprecations) {
                    addAnnotation(buildDeprecationAnnotation(functionName, paneInfo.className))
                }
            }
            .addParameter(
                ParameterSpec.builder("key", String::class)
                    .defaultValue("%S", "${paneInfo.name}-pane")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("parentKey", String::class.asTypeName().copy(nullable = true))
                    .defaultValue("null")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("activePaneRole", PANE_ROLE)
                    .defaultValue("%T.Primary", PANE_ROLE)
                    .build()
            )
            .returns(PANE_NODE)
            .addCode(buildPaneNodeCode(paneInfo))
            .build()
    }

    private fun buildPaneNodeCode(paneInfo: PaneInfo): CodeBlock {
        val builder = CodeBlock.builder()
            .addStatement("return %T(", PANE_NODE)
            .indent()
            .addStatement("key = key,")
            .addStatement("parentKey = parentKey,")
            .addStatement("paneConfigurations = mapOf(")
            .indent()

        paneInfo.panes.forEachIndexed { index, paneItem ->
            val rootGraphName = paneItem.rootGraphClass.simpleName.asString()
            val paneKey = paneItem.destination.className.lowercase()
            val coreRole = mapPaneRoleToCore(paneItem.role)
            val coreAdaptStrategy = mapAdaptStrategyToCore(paneItem.adaptStrategy)

            builder.addStatement(
                "%T.%L to %T(",
                PANE_ROLE,
                coreRole,
                PANE_CONFIGURATION
            )
            builder.indent()
            builder.addStatement(
                "content = build${rootGraphName}NavNode(key = %P, parentKey = key),",
                "\$key/$paneKey"
            )
            builder.addStatement(
                "adaptStrategy = %T.%L",
                ADAPT_STRATEGY,
                coreAdaptStrategy
            )
            builder.unindent()
            builder.addStatement(")%L", if (index < paneInfo.panes.size - 1) "," else "")
        }

        val coreBackBehavior = mapPaneBackBehaviorToCore(paneInfo.backBehavior)

        builder
            .unindent()
            .addStatement("),")
            .addStatement("activePaneRole = activePaneRole,")
            .addStatement("backBehavior = %T.%L,", PANE_BACK_BEHAVIOR, coreBackBehavior)
            .addStatement("scopeKey = %S", paneInfo.className)
            .unindent()
            .addStatement(")")

        return builder.build()
    }

    // =========================================================================
    // Enum Mapping - Model enums to Core enums
    // =========================================================================

    /**
     * Maps KSP model PaneRole to core NavNode PaneRole.
     * Model uses SCREAMING_CASE, core uses PascalCase.
     */
    private fun mapPaneRoleToCore(role: PaneRole): String {
        return when (role) {
            PaneRole.PRIMARY -> "Primary"
            PaneRole.SECONDARY -> "Supporting" // Map SECONDARY -> Supporting
            PaneRole.EXTRA -> "Extra"
        }
    }

    /**
     * Maps KSP model AdaptStrategy to core NavNode AdaptStrategy.
     * Model uses SCREAMING_CASE, core uses PascalCase.
     */
    private fun mapAdaptStrategyToCore(strategy: AdaptStrategy): String {
        return when (strategy) {
            AdaptStrategy.HIDE -> "Hide"
            AdaptStrategy.COLLAPSE -> "Hide" // COLLAPSE maps to Hide (no direct equivalent)
            AdaptStrategy.OVERLAY -> "Levitate" // OVERLAY maps to Levitate
            AdaptStrategy.REFLOW -> "Reflow"
        }
    }

    /**
     * Maps KSP model PaneBackBehavior to core NavNode PaneBackBehavior.
     */
    private fun mapPaneBackBehaviorToCore(behavior: PaneBackBehavior): String {
        return when (behavior) {
            PaneBackBehavior.PopUntilScaffoldValueChange -> "PopUntilScaffoldValueChange"
            PaneBackBehavior.PopUntilContentChange -> "PopUntilContentChange"
            PaneBackBehavior.PopLatest -> "PopLatest"
        }
    }
}
