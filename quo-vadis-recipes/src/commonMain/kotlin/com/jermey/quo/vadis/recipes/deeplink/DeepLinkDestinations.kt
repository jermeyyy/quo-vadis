package com.jermey.quo.vadis.recipes.deeplink

// NOTE: @Destination and @Argument annotations are imported but commented out in usage
// to avoid KSP processing. In production code, these annotations would be active.
// import com.jermey.quo.vadis.annotations.Argument
// import com.jermey.quo.vadis.annotations.Destination
import com.jermey.quo.vadis.core.navigation.core.Destination as BaseDestination

/**
 * # Deep Link Destination Definitions
 *
 * These destinations demonstrate deep link route patterns for the Quo Vadis
 * NavNode architecture. Each destination is annotated with `@Destination(route = "...")`
 * to enable automatic deep link handling.
 *
 * ## Route Pattern Syntax
 *
 * - **Static segments**: `products/featured`
 * - **Path parameters**: `products/{productId}`
 * - **Multiple parameters**: `category/{categoryId}/product/{productId}`
 * - **Query parameters**: Handled separately via `@Destination(route = "search?q={query}")`
 *
 * ## Generated Deep Link Handler
 *
 * KSP generates `GeneratedDeepLinkHandler` that:
 * 1. Parses URIs against route patterns
 * 2. Extracts path parameters
 * 3. Creates destination instances
 * 4. Supports reverse URI generation via `createDeepLinkUri()`
 *
 * ## LLM Integration Notes
 *
 * When implementing deep linking:
 * 1. Define route patterns in `@Destination(route = "...")` annotations
 * 2. Parameter names in routes must match constructor parameter names
 * 3. All path parameters are extracted as `String` - convert as needed
 * 4. Use `GeneratedDeepLinkHandler.handleDeepLink(uri)` to parse incoming URIs
 * 5. Handle `DeepLinkResult.NotMatched` gracefully (show error, fallback to home)
 *
 * @see com.jermey.quo.vadis.core.navigation.core.GeneratedDeepLinkHandler
 * @see com.jermey.quo.vadis.core.navigation.core.DeepLinkResult
 */

// ============================================================
// SIMPLE ROUTES - Single-level deep linking
// ============================================================

/**
 * Products navigation stack with deep-linkable routes.
 *
 * Demonstrates simple, flat route patterns:
 * - Static routes: `products`, `products/featured`
 * - Parameterized routes: `products/{productId}`
 *
 * ## Supported URIs
 *
 * | URI | Destination |
 * |-----|-------------|
 * | `myapp://products` | [List] |
 * | `myapp://products/featured` | [Featured] |
 * | `myapp://products/abc-123` | [Detail] with `productId = "abc-123"` |
 * | `https://example.com/products/xyz` | [Detail] with `productId = "xyz"` |
 *
 * ## Stack Configuration (Applied in Production)
 *
 * In a production app, this sealed class would be annotated with:
 * ```kotlin
 * @Stack(name = "products", startDestination = "List")
 * sealed class ProductsDestination : Destination
 * ```
 *
 * This triggers KSP to generate:
 * - `buildProductsDestinationNavNode()` function
 * - Deep link handler routes
 * - Screen registry entries
 *
 * ## KSP-Generated Handler (Conceptual)
 *
 * ```kotlin
 * // This is generated by KSP from @Destination annotations
 * object GeneratedProductsDeepLinkHandler : GeneratedDeepLinkHandler {
 *     override fun handleDeepLink(uri: String): DeepLinkResult {
 *         val path = extractPath(uri)
 *         return when {
 *             path == "products" -> DeepLinkResult.Matched(ProductsDestination.List)
 *             path == "products/featured" -> DeepLinkResult.Matched(ProductsDestination.Featured)
 *             path.matches(Regex("products/([^/]+)")) -> {
 *                 val productId = extractParam(path, "productId")
 *                 DeepLinkResult.Matched(ProductsDestination.Detail(productId))
 *             }
 *             else -> DeepLinkResult.NotMatched
 *         }
 *     }
 * }
 * ```
 */
// NOTE: @Stack annotation omitted to avoid KSP processing in recipes module.
// In production code, add: @Stack(name = "products", startDestination = "List")
sealed class ProductsDestination : BaseDestination {

    /**
     * Product list screen - root of the products stack.
     *
     * **Deep link**: `myapp://products`
     *
     * This is a static route with no parameters.
     *
     * In production code, add: @Destination(route = "products")
     */
    // @Destination(route = "products") - commented to avoid KSP processing in recipes module
    data object List : ProductsDestination()

    /**
     * Featured products screen.
     *
     * **Deep link**: `myapp://products/featured`
     *
     * Static nested route - note `featured` is a literal segment, not a parameter.
     *
     * In production code, add: @Destination(route = "products/featured")
     */
    // @Destination(route = "products/featured") - commented to avoid KSP processing in recipes module
    data object Featured : ProductsDestination()

    /**
     * Product detail screen with ID parameter.
     *
     * **Deep link**: `myapp://products/{productId}`
     *
     * ## Parameter Extraction
     *
     * The `{productId}` in the route template maps to the constructor parameter.
     * KSP matches parameter names between route and constructor.
     *
     * ## @Argument Annotation
     *
     * In production code, use `@Argument` on constructor params to mark navigation arguments:
     * ```kotlin
     * @Destination(route = "products/{productId}")
     * data class Detail(@Argument val productId: String) : ProductsDestination()
     * ```
     *
     * ## Example URIs
     *
     * - `myapp://products/abc-123` → `Detail(productId = "abc-123")`
     * - `https://example.com/products/xyz-789` → `Detail(productId = "xyz-789")`
     *
     * In production code, add:
     * - @Destination(route = "products/{productId}")
     * - @Argument on productId parameter
     *
     * @property productId The product identifier extracted from the URI path
     */
    // @Destination(route = "products/{productId}") - commented to avoid KSP processing in recipes module
    data class Detail(
        // @Argument - commented to avoid KSP processing in recipes module
        val productId: String
    ) : ProductsDestination()
}

// ============================================================
// NESTED ROUTES - Multi-level deep linking
// ============================================================

/**
 * Categories navigation with nested product routes.
 *
 * Demonstrates multi-level deep linking with hierarchical routes:
 * - `categories` → list all categories
 * - `categories/{categoryId}` → category detail
 * - `categories/{categoryId}/products/{productId}` → product within category
 *
 * ## Supported URIs
 *
 * | URI | Destination | Parameters |
 * |-----|-------------|------------|
 * | `myapp://categories` | [CategoryList] | (none) |
 * | `myapp://categories/electronics` | [CategoryDetail] | `categoryId = "electronics"` |
 * | `myapp://categories/electronics/products/phone-1` | [ProductInCategory] | `categoryId = "electronics"`, `productId = "phone-1"` |
 *
 * ## Stack Configuration (Applied in Production)
 *
 * In a production app, this sealed class would be annotated with:
 * ```kotlin
 * @Stack(name = "categories", startDestination = "CategoryList")
 * sealed class CategoryDestination : Destination
 * ```
 *
 * ## Path Reconstruction
 *
 * When a deep link targets a nested screen like `ProductInCategory`, the NavNode
 * architecture can optionally reconstruct the full navigation stack:
 *
 * ```
 * Deep link: myapp://categories/electronics/products/phone-123
 *
 * Option 1 - Direct (default):
 *   Stack: [ProductInCategory(electronics, phone-123)]
 *
 * Option 2 - Reconstructed:
 *   Stack: [CategoryList → CategoryDetail(electronics) → ProductInCategory(electronics, phone-123)]
 * ```
 *
 * ## LLM Integration Notes
 *
 * Multi-parameter routes:
 * 1. Parameters are extracted in order from the URI path
 * 2. All parameters must have matching constructor arguments
 * 3. Consider which back navigation experience you want (direct vs reconstructed)
 */
// NOTE: @Stack annotation omitted to avoid KSP processing in recipes module.
// In production code, add: @Stack(name = "categories", startDestination = "CategoryList")
sealed class CategoryDestination : BaseDestination {

    /**
     * Category list screen - root of the categories stack.
     *
     * **Deep link**: `myapp://categories`
     *
     * In production code, add: @Destination(route = "categories")
     */
    // @Destination(route = "categories") - commented to avoid KSP processing in recipes module
    data object CategoryList : CategoryDestination()

    /**
     * Category detail screen showing products in a category.
     *
     * **Deep link**: `myapp://categories/{categoryId}`
     *
     * In production code, add:
     * - @Destination(route = "categories/{categoryId}")
     * - @Argument on categoryId parameter
     *
     * @property categoryId The category identifier from the URI path
     */
    // @Destination(route = "categories/{categoryId}") - commented to avoid KSP processing in recipes module
    data class CategoryDetail(
        // @Argument - commented to avoid KSP processing in recipes module
        val categoryId: String
    ) : CategoryDestination()

    /**
     * Product within a category context.
     *
     * **Deep link**: `myapp://categories/{categoryId}/products/{productId}`
     *
     * ## Multi-Parameter Route
     *
     * This demonstrates extracting multiple path parameters from a single URI.
     * The route template defines the structure, and KSP generates the parsing logic.
     *
     * ## Example
     *
     * ```kotlin
     * // URI: myapp://categories/electronics/products/phone-123
     * // Extracted:
     * //   categoryId = "electronics"
     * //   productId = "phone-123"
     * val destination = ProductInCategory(
     *     categoryId = "electronics",
     *     productId = "phone-123"
     * )
     * ```
     *
     * ## Contextual Navigation
     *
     * Unlike [ProductsDestination.Detail], this destination includes category context.
     * This is useful when:
     * - Back navigation should return to the category
     * - Product display varies by category
     * - Analytics need category context
     *
     * In production code, add:
     * - @Destination(route = "categories/{categoryId}/products/{productId}")
     * - @Argument on both categoryId and productId parameters
     *
     * @property categoryId The category containing the product
     * @property productId The product identifier
     */
    // @Destination(route = "categories/{categoryId}/products/{productId}") - commented to avoid KSP processing in recipes module
    data class ProductInCategory(
        // @Argument - commented to avoid KSP processing in recipes module
        val categoryId: String,
        // @Argument - commented to avoid KSP processing in recipes module
        val productId: String
    ) : CategoryDestination()
}
